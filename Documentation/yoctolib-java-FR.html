<HTML>
<HEAD>
<title>JAVA API</title>
<link rel="apple-touch-icon-precomposed" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAAEXRFWHRTb2Z0d2FyZQBKVEwtRGV2J4CxQ84AAAAGYktHRAgICAgICCjFCb4AAAAJcEhZcwAAATsAAAE7AR/fb3EAAA34SURBVHiczVwHTBZNGp5vBeFEUWPHXhDFgsZuLLHEdqJYsJzGTvQEY4yiiAFrNBgTsZ4FsSRqTNRTsRCNvetZ0FPsigVFsf4WFPm/m2fCfNlv2TK738L9k4ysOzuzM8+85XnfWXA4nU6iVWJjY2uUKVNmaqVKlf5eqlSpSn5+fiV9fHy8iE5xOBxEtBg9a+dYvOTm5v7+/v37V1qysrOzD33+/HkFXedzzXG1AFq6dOmqJk2a/NPb27vYX2WRhTHW79+/89LT0/8VGRk5RQigmJiYOnXr1j1UvXr1BoW1kMIGTauP3liZmZn3MzIy+lBpeqIJUHx8/DgqNav/RktRA1JY7zADYE5Ozg8qTVHR0dHJBQCaMWNGzZYtW97zpaUoQLEDVEmSbH/Hz58/c9LS0hrExcVlsHfwhmrVqu2i9sY3Ly+PoFLddKv8vmj7n3/+SapWrUqqVKnCrrX6K++LtqNWqFCBUFNAsMlWxlBr9/Ly8qVz3uXahHxvNZHebKO3aGWbVjv/P/V8bAE1a9YkpUuXtm1cXqlXJTVq1CDUy5KAgAChzRQFis69TUJCwiQmZVOmTPGjdiezRIkS/nbqOaSnYcOG2BFy6dIlQt2prQa4WbNmpGLFimxB9+7dg5G1xVjz9h8/fnyh4wZIxYsX70a5jb8nu6nW7/nz50y13r9/z6oVNdWaA6QSG4B3XLt2jbx48cKUiolIFDU3/rR2A0AdrExSZHEiQKq1A1h5lT8DBxscHEwePHhAbt26Rd6+fWvZnun1wXspQB0kKj3NRBZhRbpQtAyoXj/KdllVW0DJkiWZ93r69KkpyVBzFMp1Ke9T4WkmUa8e6Ilq6U0SkwJARuNjwZUrVyaUoJI6deqwa9gBPMeB4n04LTGrQiJeUdkObByJiYm/6AS97SBayvY+ffrA2JGTJ08W6Fe2bFlmS+CBypcvX2BMTBDq8+rVK2aAv3z5wp5Bnw4dOpCDBw8WMPx2rEF+n25wrkR3xNuMATajbqjwYvL7kKqmTZuSvn37kpCQEEYF1CZbrFgxxqEoeSX9+vUjbdq0Yc+hPwdQRIXMSpRCWr0lO2yN1v3Xr18zbwPVwf/9/f1JaGgoad68uSELVpbAwEASFhbG1E8NICMVUgNQC1T5fcnq4kWe5S64c+fOpG3btmTAgAFMnawWytVI/fr1dW2Q3WuQCvMlNK4hhw4dIm/evGFqBXWzq8Dde7p4vXtciiQt1bLjJdwLKZIDthTYJivxm6i68bEkkQUbcSO9SSIkQLxkd4EtqlWrltBCPZEiyQ491WqHJ4L3KawCu6a186IqZMSLJLsMmpIgosLzUDZaaACVK1eOBcRWFy+ydslTFVJOSM5+GzRoQAq71KtXz/Lihdy82mCg8+3btyeNGzfWBcpot8B6C7vAvnmymbVr1yaNGjVy3VeuxxEVFeVUUu1OnToxL4HAEBQfA8kLH4QzY1zDlSOkALgYA6oVHx9f6ADh3UuWLGHzMBtSIOEGRo+Q5f79+4y3KftJaqh/+/aNqQkKOgMkeUV8lZ+eZOQNiatu3bqRESNGMMOMMXx8fEhRFLwPG2lFioKCgthGYq5g9mpS5oiIiHCqoQ31+vr1K8nIyHBDVbkj/F54eDhp3bo1Cy+SkpJYWDF16tQiAWnLli3k0aNHmtKjJkVdunRh9fHjx0xy0tPTifIIDP0kLaOclpbGOivblekHfm/nzp3kypUrLMCcPHkyi8GKqmAjzXgyhD4A586dO2Tbtm3k9u3b2kxajxgauUil19u+fTsDCe538ODBRQbQu3fv3ADR40Y9evRg5uDGjRtkx44d5NevX7rrlfTcntJTaaVCcc0lCTty+fLlIgMnJyeH/PHHH0LZzUGDBjHpwfwg8ZivEagOamucUAcksIwsP09RGCWb8HPcuHHMJhV2gRPZu3evmyTgWjnHXr16Mbt69uxZsm/fPpe3NThpJQ5qM5hl8vPzY/YDHgmeQRQILVAB5qxZs1gu6K9QAMjx48dJSkqKbpYRkvThwweSnZ3NbBsDSP4wXDeyfAgG80+hdYHQawfg8+bNKxBugCbMnDmTGUdQg/HjxxdIoGGiGzduZHYNOw+ugwNItYWfOXOGfPz4ke04r5y78fmgHVxNa+7fv39noOA5uTdzBAQEOLUWignhhBQuWw8IPdBAxIYMGeLWBkqAPBEvs2fPJnFxcW7PgGQuW7bMTUWgSsoCm3fu3DnT8+IkE9KCCrVU6y/pDQz9fvjwIbl58yZ58uQJS6Jjd4yiebnBO3bsGJMYXvAsT+KjtGrVyrWDvOAaUsfbUI4ePcoWIi/gL6dOnTJM08jbYdDB1cCb7t69y645OKpmBBJkJBnKe1A9nI1DspAMUyOQ8n5jx44lPXv2ZNc4ZcUHB9zu4XwLTFitgLXjGIiDB14GteVqCsmDSuhJDjwVIgPYE/RRhiRG15IVtYEUQV8hVTgXR94Z0vXp0yeXhMmlKDU1tUCKIv9TEwaCVsGYeIafxfOEPcqBAwcY2HLaAUkAGJA0SAbmh5qVlcVA5p6LV9g9vWv8lOQdeIUXY420yq/V7nEmC8AwKUgExBfn5jCK2GEEgvKPCxISEpgUQvyR9IKEYbFyyRkzZgzp2rWri8MsXLjQtUGQCtgwjI3Fv3z5kkkX3o1zNBBHqBLjMTpAGAGV/3/3ReOnSEe9di4dmCQWzoHjpXv37mTPnj2MAkBl4NEgWbxAdYcOHcqcBFImycnJjP3yArsD24ixsTl4F6RDOR/lZprZeH7toBNwitgdMzZKGciirlmzxrb06/Tp09knNXbNUfm1mls7NYJOKwNDNZBoUrNRyt2AdODQz66Ck1aolwhh9XSzHVTMncoGNTTl7dHR0WT48OH/N1Y8atQoVxrGTilSe9YRGBjoNNMR9gL2AeQMbpZ7Gflz4DCoMMQ8IYXs3cSJE20JPeAt5UZdjV0rKww7Qo3Dhw+bI7xBQUFOEVHF/wEOWPCRI0fIggULXB5GSFTzDWdkZCQZNmyYZXD41x5KADgwWqoFZ4BzNLDx9evXExGtYdeUkzhFDC0Cz4EDB5Jdu3aRxMRE12SsiPW0adPYWGYKEnh4N/JN8khc9L2QZJiGjh07MilavXq1kNY4goODncqBldcAB0Z206ZNLJ3qqafDbsF140RBpICITpgwwSWxmrst8N6IiAjSv39/FrqsWrXKPTBV6498kNbAqDExMcxrABxUK8ZP7V67du3I4sWL2TU4DdIQ169fdx3lILmFtCjKnDlzyNWrVy0ZXbVcOoJnGHqABPqh1Aa3sUJCQlTdPIwp2CwIGnYb1ch1muEaiL/279/PvNGkSZMKpCfw7MqVK9nBYO/evW33TkgJA6TTp0+zUAhsXzVpL2eSHGl0njt3LmnRogXZvXs32bx5syHjFGGscmONmA0FoQI7XlGwdK5aiK88YcJac4SxxgbhY66oqCimJUqH4kp3KMMHpF8RJsA1nj9/3jJd1wtVsFs8uSUPDeTP8jy3aGBpJkRCBRtHcIvYD+d7auuR1BYHbwFgVqxYwbL/otGv2iT0QEX6ATxKqx1t/CtYT+JDrc2E7YNdRRIfsaHqGGriB7GGCF64cEFTRaxMWAmEXELUxuIkVGVXTUmynl0CfYDbVwuR8q/FF++JzmuFLwBBC1SoH0QfCTa9cT2VZD01LWCDjMTTjN1Rm6jyWQCktXgc0aAduSCeSVTxMrbYRk3BMBpYRLqUkxX1dN7e3kzFtHYeSTh4U7BggISMoujOy+empQkiQEpmXLOR6pmxSzjuQV4bWUe9CcPVI+5D7nv+/PnsSEoEHDPzMthsyfAldrt5ZAMQ9OLEAx7EyHU/e/aMLFq0iAEKiUJ+SU3S7dpst80UcZFmOY5eP4QQiOaResDBoIjEoSJli9AEYQjO0PBTzRTY4WQU/cQfVkulGnEN+T2w1ZEjR7Kc8oYNG4QNLb/GCcXy5cuZmgEk+YGmKL0Q4U6qbl5ESqyoEy/4zZ/Ro0czz4R8jBJUUenENz0IMOHVYmNjGUhG6qS3sYYaRP/J8YQ/iNgwHBvjaOfixYtk3bp1bpKjJ51a7wW7BwMGP0Jkboc6aawhBwCl66Eqwh/0JoEjHnwKg3TF2rVrXckukQXpuW6kfPErmTgWEjEPVuwSfeYe5O+/egiLiqeaJ8DvgyHRhbN9ZPD42ZXZyF9LquUfHIjaSTNOhpbbkKAbVu2O0W7haAg8B3kdfiau5VKt2Dv5YaGom9fbbBV1uwmY/iNqd8wCiWQX8j3sl0IU/dRyL6KpDF7BxMGyzdhDMyES3YCrAAi5zEy7UxlIqeLoGL+vgU/8RGi+mcwAvBhy2jhSgqSaic1E1kPvv6b1qpSampqTl5cXZTVkUOo/v49PW3Amjy8tsBARN27GLuHDLnyxgQ8VsBF6gbJRcKs2Lyr1UVu3bs1x/fWXsLCwf9NOYWYT4nrtSLrjpSdOnNA8FLB6ZIyKL1YhQSCe8o+gjPLWRu+g4OyjLH+A25/HCQ0NreTr6wuXX9bqGbcnH33qAWj3uAbr+fjz58+GycnJWW5/HiclJSUrNzd3FL38YMbuGBlSEVvjSYhjImQwVHOsHRhwcFT/RBdVtSrUM2yng3XxdOfNHBNZPVIy8wWHnmpTO3yKgjMiKSkpU+iPvIWHh8+kQM2nA/ianYTdX1pYAcLEsznUfs2lwfNSU38FL//T/YpeXl7/oNLUj4phbVor0MH9rO68p8/aYWto+UbX/I4a4qe0HqCSs4NKzVstDP4HmBZinDvm9zIAAAAASUVORK5CYII="/>
<meta name="apple-mobile-web-app-capable" content="yes" />
<style type="text/css">
/*********************************************************************
 *
 * $Id: yoctolib-cpp-FR.html 3693 2013-03-27 15:43:21Z mvuilleu $
 *
 * Searchable documentation browser for Yoctopuce Library
 *
 * (note: the reference file to edit is yoctolib-cpp-FR.html)
 *
 * - - - - - - - - - License information: - - - - - - - - - 
 *
 * Copyright (C) 2011 and beyond by Yoctopuce Sarl, Switzerland.
 *
 * 1) If you have obtained this file from www.yoctopuce.com,
 *    Yoctopuce Sarl licenses to you (hereafter Licensee) the
 *    right to use, modify, copy, and integrate this source file
 *    into your own solution for the sole purpose of interfacing
 *    a Yoctopuce product with Licensee's solution.
 *
 *    The use of this file and all relationship between Yoctopuce 
 *    and Licensee are governed by Yoctopuce General Terms and 
 *    Conditions.
 *
 *    THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT
 *    WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING 
 *    WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS 
 *    FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO
 *    EVENT SHALL LICENSOR BE LIABLE FOR ANY INCIDENTAL, SPECIAL,
 *    INDIRECT OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, 
 *    COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR 
 *    SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT 
 *    LIMITED TO ANY DEFENSE THEREOF), ANY CLAIMS FOR INDEMNITY OR
 *    CONTRIBUTION, OR OTHER SIMILAR COSTS, WHETHER ASSERTED ON THE
 *    BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE), BREACH OF
 *    WARRANTY, OR OTHERWISE.
 *
 * 2) If your intent is not to interface with Yoctopuce products,
 *    you are not entitled to use, read or create any derived 
 *    material from this file.
 *
 *********************************************************************/
BODY
{ font-family: Arial, sans-serif;
  font-size: 14px;
  text-align : justify;
}

div#BannerLayer
{ position:absolute; 
  left:0px; 
  top:0px; 
  width:800px; 
  height:80px;
  overflow:hidden;
  Font-size:64px;
  font-weight:bold;
  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAABkCAIAAADITs03AAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzoyNjozNCArMDEwMCBiImgAAAAHdElNRQfbDA0GIhbUXPxTAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAAB9JREFUeNpjeP78ORMDAwPT////wTQ+NrHqRvWTrR8AfCxgH0BR2OYAAAAASUVORK5CYII=);
  }
div#MarginLayer
{ position:absolute; 
  left:0px; 
  top:80px; 
  width:250px; 
  height:490px;
  background-color:#f8f8f8;
  overflow:auto;
 
}

div#FunctionsLayer
{ position:absolute; 
  left:250px; 
  top:80px; 
  width:600px; 
  height:490px;
  overflow:auto;
}

div#FooterLayer
{ position:absolute; 
  left:0px; 
  top:570px; 
  width: 800px; 
  height:30px;
  background-color: #E0E0E0 ;
  overflow:hidden;
}

div#separatorLayer
{ position:absolute; 
  width:10px; 
  height:470px;
  border-left:2px solid #b0b0b0 ;
  overflow:hidden;
  cursor :col-resize; 
}

div.container
{ width:100%;
  height:100%;
}
 
span.classheader
{ display:inline-block;
  width:100%;
  background-color:#f0f0f0;
  padding-top:3px;
  padding-bottom:3px;
  margin-bottom:3px;
  margin-top:px;
} 

A.extLink
 { color : grey;
   text-decoration:none;
   font-size:10px;
 }
 
span.classheader A
 { color: navy;
   text-decoration:none;
   font-weight:bold;
 }

img.expandColapse
 { vertical-align: middle;
 }
 
div.methodsList
 { margin-top:0px;
   padding-top:0px;   
   padding-left:10px;
   margin-bottom:10px;
 } 

div.methodsList A
 { color: navy;
   text-decoration:none;
 }
 
div#FunctionsLayerInner
 { margin-left:10px;
   margin-top:10px;
   margin-right:20px;
 }
 
span.funcHeader
 { color: navy;
   text-decoration:none;
   font-size:25px;
   margin-botton:20px;
   font-weight:bold;
 }
  
span#pn , td.pn
 { font-weight:bold; 
   color:#004000;
   
 } 
 
td.pn
 {vertical-align:top}
 
span.paramAndRet
 {font-weight:bold;

 } 
 
table
 {font-size:14px;}
 
span.prototype
 { margin-left:10px;
   margin-right:10px;
   padding-top:5px;
   padding-bottom:5px;
   padding-left:5px;
   padding-right:5px;
   font-weight:bold;   
   background-color: #f8f8f8; 
   -moz-border-radius: 5px;
   -webkit-border-top-left-radius:  5px;
   -webkit-border-top-right-radius: 5px;
   -webkit-border-bottom-right-radius:  5px;
   -webkit-border-bottom-left-radius:  5px;
    color:navy;
 }
 
p.protolabel
 { border-top:1px  solid #f0f0f0;
 }
 
P.protoretval
 { margin-left:20px;}

.paramtable 
 { margin-left:20px; margin-top:0px;}
  
P.protoretval
 { margin-left:20px;}
 
input
 { border :  1px solid gray;
   border-radius: 2px;
  -moz-border-radius: 2px;
  -webkit-border-top-left-radius:  2px;
  -webkit-border-top-right-radius: 2px;
  -webkit-border-bottom-right-radius:  2px;
  -webkit-border-bottom-left-radius:  2px;
 }
 
td#langdt
 { vertical-align:bottom;
   text-align:right;
   color:#404040; 
 }
 
td#version
 { text-align:right;
   font-size:12px;
   color:grey;
 }
 
p.methodlist
 { border-top:1px solid #e0e0e0;
 } 
 
a.protoindex
 { text-decoration:none;
   font-weight:bold;
   color:navy;
 } 
 
span.synlist
 { margin-left:10px;
 } 
 
p.include
 { font-weight:bold;
   color:navy;
   margin-left:20px;
 }  
</style>

<SCRIPT type="text/JavaScript" language="javascript1.5">
<!--
var WinW; 
var WinH; 

var plusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIlhI9pwe2+nmQRAllbpvft8IWdgnAcOXYWpmqt6b2gLE7TZ6N6AQA7";
var minusimage="data:image/gif;base64,R0lGODlhEAAQAIAAAEJCQv///yH5BAAAAP8ALAAAAAAQABAAAAIihI9pwe2+nmRxvmobzmHnqCAUMIZkd3KjqqWqZ8GTLJl2AQA7";

var marginSize=250;
var resizeCallBacks= new Array(); 
var SVN_Id = '$Id: yoctolib-cpp-FR.html 3693 2013-03-27 15:43:21Z mvuilleu $';
var Version = (SVN_Id.split(' '))[3];
var doc = new Array();

//--- (generated code: YAPI)
doc['YAPI']={'':{syn:'Fonctions g\xE9n\xE9rales',inc:'import com.yoctopuce.YoctoAPI.YModule;',cmt:'<p>Ces quelques fonctions g\xE9n\xE9rales permettent l\x27initialisation et la configuration de la librairie Yoctopuce. Dans la plupart des cas, un appel \xE0 <tt>yRegisterHub()</tt> suffira en tout et pour tout. Ensuite, vous pourrez appeler la fonction globale <tt>yFind...()</tt> ou <tt>yFirst...()</tt> correspondant \xE0 votre module pour pouvoir interagir avec lui.</p>'}};
doc['YAPI']['CheckLogicalName']={syn:'V\xE9rifie si un nom donn\xE9 est valide comme nom logique pour un module ou une fonction.',lib:'YAPI.CheckLogicalName()',pro:'boolean CheckLogicalName(String <span id=pn>name</span>)',cmt:'<p>V\xE9rifie si un nom donn\xE9 est valide comme nom logique pour un module ou une fonction. Un nom logique valide est form\xE9 de 19 caract\xE8res au maximum, choisis parmi <tt>A..Z</tt>, <tt>a..z</tt>, <tt>0..9</tt>, <tt>_</tt> et <tt>-</tt>. Lorsqu\x27on configure un nom logique avec une cha\xEEne incorrecte, les caract\xE8res invalides sont ignor\xE9s.</p>',par:{name:'une cha\xEEne de caract\xE8res contenant le nom v\xE9rifier.'},ret:'<tt>true</tt> si le nom est valide, <tt>false</tt> dans le cas contraire.'};
doc['YAPI']['EnableUSBHost']={syn:'Cette fonction est utilis\xE9e uniquement sous Android.',lib:'YAPI.EnableUSBHost()',pro:'void EnableUSBHost(Object <span id=pn>osContext</span>)',cmt:'<p>Cette fonction est utilis\xE9e uniquement sous Android. Avant d\x27appeler <tt>yRegisterHub(\x22usb\x22)</tt> il faut activer le port USB host du systeme. Cette fonction prend en argument un objet de la classe android.content.Context (ou d\x27une sous-classe). Il n\x27est pas n\xE9cessaire d\x27appeler cette fonction pour acc\xE9der au modules \xE0 travers le r\xE9seau.</p>',par:{osContext:'un objet de classe android.content.Context (ou une sous-classe) En cas d\x27erreur, d\xE9clenche une exception'}};
doc['YAPI']['FreeAPI']={syn:'Lib\xE8re la m\xE9moire dynamique utilis\xE9e par la librairie Yoctopuce.',lib:'YAPI.FreeAPI()',pro:'void FreeAPI()',cmt:'<p>Lib\xE8re la m\xE9moire dynamique utilis\xE9e par la librairie Yoctopuce. Il n\x27est en g\xE9n\xE9ral pas n\xE9cessaire d\x27appeler cette fonction, sauf si vous d\xE9sirez lib\xE9rer tous les blocs de m\xE9moire allou\xE9s dynamiquement dans le but d\x27identifier une source de blocs perdus par exemple. Vous ne devez plus appeler aucune fonction de la librairie apr\xE8s avoir appel\xE9 <tt>yFreeAPI()</tt>, sous peine de crash.</p>'};
doc['YAPI']['GetAPIVersion']={syn:'Retourne la version de la librairie Yoctopuce utilis\xE9e.',lib:'YAPI.GetAPIVersion()',pro:'String GetAPIVersion()',cmt:'<p>Retourne la version de la librairie Yoctopuce utilis\xE9e. La version est retourn\xE9e sous forme d\x27une cha\xEEne de caract\xE8res au format <tt>\x22Majeure.Mineure.NoBuild\x22</tt>, par exemple <tt>\x221.01.5535\x22</tt>. Pour les langages utilisant une DLL externe (par exemple C#, VisualBasic ou Delphi), la cha\xEEne contient en outre la version de la DLL au m\xEAme format, par exemple <tt>\x221.01.5535 (1.01.5439)\x22</tt>.</p><p> Si vous d\xE9sirez v\xE9rifier dans votre code que la version de la librairie est compatible avec celle que vous avez utilis\xE9 durant le d\xE9veloppement, v\xE9rifiez que le num\xE9ro majeur soit strictement \xE9gal et que le num\xE9ro mineur soit \xE9gal ou sup\xE9rieur. Le num\xE9ro de build n\x27est pas significatif par rapport \xE0 la compatibilit\xE9 de la librairie.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la version de la librairie.'};
doc['YAPI']['GetTickCount']={syn:'Retourne la valeur du compteur monotone de temps (en millisecondes).',lib:'YAPI.GetTickCount()',pro:'long GetTickCount()',cmt:'<p>Retourne la valeur du compteur monotone de temps (en millisecondes). Ce compteur peut \xEAtre utilis\xE9 pour calculer des d\xE9lais en rapport avec les modules Yoctopuce, dont la base de temps est aussi la milliseconde.</p>',ret:'un long entier contenant la valeur du compteur de millisecondes.'};
doc['YAPI']['HandleEvents']={syn:'Maintient la communication de la librairie avec les modules Yoctopuce.',lib:'YAPI.HandleEvents()',pro:'void HandleEvents()',cmt:'<p>Maintient la communication de la librairie avec les modules Yoctopuce. Si votre programme inclut des longues boucles d\x27attente, vous pouvez y inclure un appel \xE0 cette fonction pour que la librairie prenne en charge les informations mise en attente par les modules sur les canaux de communication. Ce n\x27est pas strictement indispensable mais cela peut am\xE9liorer la r\xE9activit\xE9 des la librairie pour les commandes suivantes.</p><p> Cette fonction peut signaler une erreur au cas \xE0 la communication avec un module Yoctopuce ne se passerait pas comme attendu.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['YAPI']['InitAPI']={syn:'Initialise la librairie de programmation de Yoctopuce explicitement.',lib:'YAPI.InitAPI()',pro:'int InitAPI(int <span id=pn>mode</span>)',cmt:'<p>Initialise la librairie de programmation de Yoctopuce explicitement. Il n\x27est pas indispensable d\x27appeler <tt>yInitAPI()</tt>, la librairie sera automatiquement initialis\xE9e de toute mani\xE8re au premier appel \xE0 <tt>yRegisterHub()</tt>.</p><p> Lorsque cette fonctin est utilis\xE9e avec comme <tt>mode</tt> la valeur <tt>Y_DETECT_NONE</tt>, il faut explicitement appeler <tt>yRegisterHub()</tt> pour indiquer \xE0 la librairie sur quel VirtualHub les modules sont connect\xE9s, avant d\x27essayer d\x27y acc\xE9der.</p>',par:{mode:'un entier sp\xE9cifiant le type de d\xE9tection automatique de modules \xE0 utiliser. Les valeurs possibles sont <tt>Y_DETECT_NONE</tt>, <tt>Y_DETECT_USB</tt>, <tt>Y_DETECT_NET</tt> et <tt>Y_DETECT_ALL</tt>.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['YAPI']['RegisterDeviceArrivalCallback']={syn:'Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque fois qu\x27un module est branch\xE9.',lib:'YAPI.RegisterDeviceArrivalCallback()',pro:'void RegisterDeviceArrivalCallback(DeviceArrivalCallback <span id=pn>arrivalCallback</span>)',cmt:'<p>Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque fois qu\x27un module est branch\xE9. Le callback sera appel\xE9 pendant l\x27\xE9xecution de la fonction <tt>yHandleDeviceList</tt>, que vous devrez appeler r\xE9guli\xE8rement.</p>',par:{arrivalCallback:'une proc\xE9dure qui prend un <tt>YModule</tt> en param\xE8tre, ou <tt>null</tt> pour supprimer un callback d\xE9ja enregistr\xE9.'}};
doc['YAPI']['RegisterDeviceRemovalCallback']={syn:'Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque fois qu\x27un module est d\xE9branch\xE9.',lib:'YAPI.RegisterDeviceRemovalCallback()',pro:'void RegisterDeviceRemovalCallback(DeviceRemovalCallback <span id=pn>removalCallback</span>)',cmt:'<p>Enregistre une fonction de callback qui sera appel\xE9e \xE0 chaque fois qu\x27un module est d\xE9branch\xE9. Le callback sera appel\xE9 pendant l\x27\xE9xecution de la fonction <tt>yHandleDeviceList</tt>, que vous devrez appeler r\xE9guli\xE8rement.</p>',par:{removalCallback:'une proc\xE9dure qui prend un <tt>YModule</tt> en param\xE8tre, ou <tt>null</tt> pour supprimer un callback d\xE9ja enregistr\xE9.'}};
doc['YAPI']['RegisterHub']={syn:'Configure la librairie Yoctopuce pour utiliser les modules connect\xE9s sur une machine donn\xE9e.',lib:'YAPI.RegisterHub()',pro:'int RegisterHub(String <span id=pn>url</span>)',cmt:'<p>Configure la librairie Yoctopuce pour utiliser les modules connect\xE9s sur une machine donn\xE9e. Dans le cas d\x27une utilisation avec la passerelle VirtualHub, vous devez donner en param\xE8tre l\x27adresse de la machine o\xF9 tourne le VirtualHub (typiquement <tt>\x22http://127.0.0.1:4444\x22</tt>, qui d\xE9signe la machine locale). Si vous utilisez un langage qui a un acc\xE8s direct \xE0 USB, vous pouvez utiliser la pseudo-adresse <tt>\x22usb\x22</tt> \xE0 la place.</p><p> Attention, seule une application peut fonctionner \xE0 la fois sur une machine donn\xE9e en acc\xE8s direct \xE0 USB, sinon il y aurait un conflit d\x27acc\xE8s aux modules. Cela signifie en particulier que vous devez stopper le VirtualHub avant de lancer une application utilisant l\x27acc\xE8s direct \xE0 USB. Cette limitation peut \xEAtre contourn\xE9e en passant par un VirtualHub plut\xF4t que d\x27utiliser directement USB. Si vous d\xE9sirez vous connecter \xE0 un VirtualHub sur lequel le controle d\x27acc\xE8s a \xE9t\xE9 activ\xE9, vous devez donner le param\xE8tre url sous la forme: <tt>http://nom:mot_de_passe</p>',par:{url:'une cha\xEEne de caract\xE8res contenant <ui>\x22usb\x22</ui> ou l\x27URL racine du VirtualHub \xE0 utiliser.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['YAPI']['RegisterLogFunction']={syn:'Enregistre une fonction de callback qui sera appell\xE9e \xE0 chaque fois que l\x27API a quelque chose \xE0 dire.',lib:'YAPI.RegisterLogFunction()',pro:'void RegisterLogFunction(LogCallback <span id=pn>logfun</span>)',cmt:'<p>Enregistre une fonction de callback qui sera appell\xE9e \xE0 chaque fois que l\x27API a quelque chose \xE0 dire. Utile pour d\xE9bugger le fonctionnement de l\x27API.</p>',par:{logfun:'une procedure qui prend une cha\xEEne de caract\xE8re en param\xE8tre, ou <tt>null</tt> pour supprimer un callback d\xE9ja enregistr\xE9.'}};
doc['YAPI']['Sleep']={syn:'Effectue une pause dans l\x27ex\xE9cution du programme pour une dur\xE9e sp\xE9cifi\xE9e.',lib:'YAPI.Sleep()',pro:'void Sleep(long <span id=pn>ms_duration</span>)',cmt:'<p>Effectue une pause dans l\x27ex\xE9cution du programme pour une dur\xE9e sp\xE9cifi\xE9e. L\x27attente est passive, c\x27est-\xE0-dire qu\x27elle n\x27occupe pas significativement le processeur, de sorte \xE0 le laisser disponible pour les autres processus fonctionnant sur la machine. Durant l\x27attente, la librairie va n\xE9anmoins continuer \xE0 lire p\xE9riodiquement les informations en provenance des modules Yoctopuce en appelant la fonction <tt>yHandleEvents()</tt> afin de se maintenir \xE0 jour.</p><p> Cette fonction peut signaler une erreur au cas \xE0 la communication avec un module Yoctopuce ne se passerait pas comme attendu.</p>',par:{ms_duration:'un entier correspondant \xE0 la dur\xE9e de la pause, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['YAPI']['UnregisterHub']={syn:'Configure la librairie Yoctopuce pour ne plus utiliser les modules connect\xE9s sur une machine pr\xE9alablement enregistrer avec RegisterHub.',lib:'YAPI.UnregisterHub()',pro:'void UnregisterHub(String <span id=pn>url</span>)',cmt:'<p>Configure la librairie Yoctopuce pour ne plus utiliser les modules connect\xE9s sur une machine pr\xE9alablement enregistrer avec RegisterHub.</p>',par:{url:'une cha\xEEne de caract\xE8res contenant <ui>\x22usb\x22</ui> ou l\x27URL racine du VirtualHub \xE0 ne plus utiliser.'}};
doc['YAPI']['UpdateDeviceList']={syn:'Force une mise-\xE0-jour de la liste des modules Yoctopuce connect\xE9s.',lib:'YAPI.UpdateDeviceList()',pro:'int UpdateDeviceList()',cmt:'<p>Force une mise-\xE0-jour de la liste des modules Yoctopuce connect\xE9s. La librairie va v\xE9rifier sur les machines ou ports USB pr\xE9c\xE9demment enregistr\xE9s en utilisant la fonction <tt>yRegisterHub</tt> si un module a \xE9t\xE9 connect\xE9 ou d\xE9connect\xE9, et le cas \xE9ch\xE9ant appeler les fonctions de callback d\xE9finies par l\x27utilisateur.</p><p> Cette fonction peut \xEAtre appel\xE9e aussi souvent que d\xE9sir\xE9, afin de rendre l\x27application r\xE9active aux \xE9v\xE9nements de hot-plug.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: YAPI)
//--- (generated code: DataStream)
doc['DataStream']={'':{syn:'S\xE9quence de donn\xE9es enregistr\xE9es',inc:'import com.yoctopuce.YoctoAPI.YDataLogger;',cmt:'<p>Les objets DataStream repr\xE9sentent des s\xE9quences de mesures enregistr\xE9es. Ils sont retourn\xE9s par l\x27enregistreur de donn\xE9es pr\xE9sent dans les senseurs de Yoctopuce.</p>'}};
doc['DataStream']['get_columnCount']={syn:'Retourne le nombre de colonnes de donn\xE9es contenus dans la s\xE9quence.',lib:'datastream.get_columnCount()',pro:'int get_columnCount()',cmt:'<p>Retourne le nombre de colonnes de donn\xE9es contenus dans la s\xE9quence. La s\xE9mantique des donn\xE9es pr\xE9sentes dans chaque colonne peut \xEAtre obtenue \xE0 l\x27aide de la m\xE9thode <tt>get_columnNames()</tt>.</p><p> Cette m\xE9thode d\xE9clanche le chargement de toutes les donn\xE9es de la s\xE9quence, si cela n\x27\xE9tait pas encore fait.</p>',ret:'un entier positif correspondant au nombre de colonnes.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne z\xE9ro.'};
doc['DataStream']['get_data']={syn:'Retourne une mesure unique de la s\xE9quence, sp\xE9cifi\xE9e par l\x27index de l\x27enregistrement (ligne) et de la mesure (colonne).',lib:'datastream.get_data()',pro:'double get_data(int <span id=pn>row</span>, int <span id=pn>col</span>)',cmt:'<p>Retourne une mesure unique de la s\xE9quence, sp\xE9cifi\xE9e par l\x27index de l\x27enregistrement (ligne) et de la mesure (colonne). La s\xE9mentique des donn\xE9es pr\xE9sentes dans chaque colonne peut \xEAtre obtenue \xE0 l\x27aide de la m\xE9thode get_columnNames().</p><p> Cette m\xE9thode d\xE9clanche le chargement de toutes les donn\xE9es de la s\xE9quence, si cela n\x27\xE9tait pas encore fait.</p>',par:{row:'index de l\x27enregistrement (ligne)',col:'index de la mesure (colonne)'},ret:'un nombre d\xE9cimal',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne Y_DATA_INVALID.'};
doc['DataStream']['get_dataRows']={syn:'Retourne toutes les donn\xE9es mesur\xE9es contenues dans la s\xE9quence, sous forme d\x27une liste de vecteurs (table bidimensionnelle).',lib:'datastream.get_dataRows()',pro:'ArrayList&lt;ArrayList&lt;Double&gt;&gt; get_dataRows()',cmt:'<p>Retourne toutes les donn\xE9es mesur\xE9es contenues dans la s\xE9quence, sous forme d\x27une liste de vecteurs (table bidimensionnelle). La s\xE9mentique des donn\xE9es pr\xE9sentes dans chaque colonne peut \xEAtre obtenue \xE0 l\x27aide de la m\xE9thode <tt>get_columnNames()</tt>.</p><p> Cette m\xE9thode d\xE9clanche le chargement de toutes les donn\xE9es de la s\xE9quence, si cela n\x27\xE9tait pas encore fait.</p>',ret:'une liste d\x27enregistrements, chaque enregistrement \xE9tant lui-m\xEAme une liste de nombres d\xE9cimaux.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne une liste vide.'};
doc['DataStream']['get_dataSamplesInterval']={syn:'Retourne le nombre de secondes entre chaque mesure de la s\xE9quence.',lib:'datastream.get_dataSamplesInterval()',pro:'int get_dataSamplesInterval()',cmt:'<p>Retourne le nombre de secondes entre chaque mesure de la s\xE9quence. Par d\xE9faut, l\x27enregistreur m\xE9morise une mesure par seconde, mais la cr\xE9ation de s\xE9quences d\x27archive synth\xE9tisant de plus longue p\xE9riode peut produire des s\xE9quences plus espac\xE9es.</p><p> Cette m\xE9thode ne provoque pas d\x27acc\xE8s au module, les donn\xE9es \xE9tant pr\xE9charg\xE9es dans l\x27objet au moment o\xF9 il est instanci\xE9.</p>',ret:'un entier positif correspondant au nombre de secondes entre deux mesures cons\xE9cutives.'};
doc['DataStream']['get_rowCount']={syn:'Retourne le nombre d\x27enregistrement contenus dans la s\xE9quence.',lib:'datastream.get_rowCount()',pro:'int get_rowCount()',cmt:'<p>Retourne le nombre d\x27enregistrement contenus dans la s\xE9quence.</p><p> Cette m\xE9thode d\xE9clanche le chargement de toutes les donn\xE9es de la s\xE9quence, si cela n\x27\xE9tait pas encore fait.</p>',ret:'un entier positif correspondant au nombre d\x27enregistrements.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne z\xE9ro.'};
doc['DataStream']['get_runIndex']={syn:'Retourne le num\xE9ro de Run de la s\xE9quence de donn\xE9es.',lib:'datastream.get_runIndex()',pro:'int get_runIndex()',cmt:'<p>Retourne le num\xE9ro de Run de la s\xE9quence de donn\xE9es. Un Run peut \xEAtre compos\xE9 de plusieurs s\xE9quences, couvrant diff\xE9rents intervalles de temps.</p><p> Cette m\xE9thode ne provoque pas d\x27acc\xE8s au module, les donn\xE9es \xE9tant pr\xE9charg\xE9es dans l\x27objet au moment o\xF9 il est instanci\xE9.</p>',ret:'un entier positif correspondant au num\xE9ro du Run'};
doc['DataStream']['get_startTime']={syn:'Retourne le nombre de secondes entre le d\xE9but du Run (mise sous tension du module) et le d\xE9but de la s\xE9quence de donn\xE9es.',lib:'datastream.get_startTime()',pro:'int get_startTime()',cmt:'<p>Retourne le nombre de secondes entre le d\xE9but du Run (mise sous tension du module) et le d\xE9but de la s\xE9quence de donn\xE9es. Si vous d\xE9sirez obtenir l\x27heure absolue du d\xE9but de la s\xE9quence, utilisez <tt>get_startTimeUTC()</tt>.</p><p> Cette m\xE9thode ne provoque pas d\x27acc\xE8s au module, les donn\xE9es \xE9tant pr\xE9charg\xE9es dans l\x27objet au moment o\xF9 il est instanci\xE9.</p>',ret:'un entier positif correspondant au nombre de secondes \xE9coul\xE9es entre le d\xE9but du Run et le d\xE9but de la s\xE9quence enregistr\xE9e.'};
doc['DataStream']['get_startTimeUTC']={syn:'Retourne l\x27heure absolue du d\xE9but de la s\xE9quence de donn\xE9es, sous forme du nombre de secondes depuis le 1er janvier 1970 (date/heure au format Unix).',lib:'datastream.get_startTimeUTC()',pro:'long get_startTimeUTC()',cmt:'<p>Retourne l\x27heure absolue du d\xE9but de la s\xE9quence de donn\xE9es, sous forme du nombre de secondes depuis le 1er janvier 1970 (date/heure au format Unix). Si l\x27heure UTC n\x27\xE9tait pas configur\xE9e dans l\x27enregistreur de donn\xE9es au d\xE9but de la s\xE9quence, cette m\xE9thode retourne 0.</p><p> Cette m\xE9thode ne provoque pas d\x27acc\xE8s au module, les donn\xE9es \xE9tant pr\xE9charg\xE9es dans l\x27objet au moment o\xF9 il est instanci\xE9.</p>',ret:'un entier positif correspondant au nombre de secondes \xE9coul\xE9es entre le 1er janvier 1970 et le d\xE9but de la s\xE9quence enregistr\xE9e.'};
//--- (end of generated code: DataStream)
//--- (generated code: Module)
var Language='JAVA';
var IncludeLabel='Pour utiliser les fonctions d\xE9crites ici, vous devez inclure:';
var ParamLabel='Param\xE8tres :';
var ReturnLabel='Retourne :';
var AbbrevHint='L\x27API supporte deux syntaxes, une premi\xE8re purement orient\xE9e objet, et une seconde abr\xE9g\xE9e.';
var NotFound='Aucune correspondance trouv\xE9e';
var AbbrevLabel='Utiliser les noms abr\xE9g\xE9s';
var UseShortcuts=null;
var sub={YAPI_SUCCESS:'YAPI.SUCCESS',YAPI_NOT_INITIALIZED:'YAPI.NOT_INITIALIZED',YAPI_INVALID_ARGUMENT:'YAPI.INVALID_ARGUMENT',YAPI_NOT_SUPPORTED:'YAPI.NOT_SUPPORTED',YAPI_DEVICE_NOT_FOUND:'YAPI.DEVICE_NOT_FOUND',YAPI_VERSION_MISMATCH:'YAPI.VERSION_MISMATCH',YAPI_DEVICE_BUSY:'YAPI.DEVICE_BUSY',YAPI_TIMEOUT:'YAPI.TIMEOUT',YAPI_IO_ERROR:'YAPI.IO_ERROR',YAPI_NO_MORE_DATA:'YAPI.NO_MORE_DATA',YAPI_EXHAUSTED:'YAPI.EXHAUSTED',YAPI_DOUBLE_ACCES:'YAPI.DOUBLE_ACCES',YAPI_UNAUTHORIZED:'YAPI.UNAUTHORIZED',null:'null'};
doc['Module']={'':{syn:'Interface de contr\xF4le du module',inc:'import com.yoctopuce.YoctoAPI.YModule;',cmt:'<p>Cette interface est la m\xEAme pour tous les modules USB de Yoctopuce. Elle permet de contr\xF4ler les param\xE8tres g\xE9n\xE9raux du module, et d\x27\xE9num\xE9rer les fonctions fournies par chaque module.</p>'}};
doc['Module']['FindModule']={syn:'Permet de retrouver un module d\x27apr\xE8s son num\xE9ro de s\xE9rie ou son nom logique.',lib:'YModule.FindModule()',pro:'YModule FindModule(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver un module d\x27apr\xE8s son num\xE9ro de s\xE9rie ou son nom logique. Cette fonction n\x27exige pas que le module soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YModule.isOnline()</tt> pour tester si le module est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res contenant soit le num\xE9ro de s\xE9rie, soit le nom logique du module d\xE9sir\xE9'},ret:'un objet de classe <tt>YModule</tt> qui permet ensuite de contr\xF4ler le module ou d\x27obtenir de plus amples informations sur le module.'};
doc['Module']['FirstModule']={syn:'Commence l\x27\xE9num\xE9ration des modules accessibles par la librairie.',lib:'YModule.FirstModule()',pro:'YModule FirstModule()',cmt:'<p>Commence l\x27\xE9num\xE9ration des modules accessibles par la librairie. Utiliser la fonction <tt>YModule.nextModule()</tt> pour it\xE9rer sur les autres modules.</p>',ret:'un pointeur sur un objet <tt>YModule</tt>, correspondant au premier module accessible en ligne, ou <tt>null</tt> si aucun module n\x27a \xE9t\xE9 trouv\xE9.'};
doc['Module']['describe']={syn:'Retourne un court texte d\xE9crivant le module.',lib:'module.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant le module. Ce texte peut contenir soit le nom logique du module, soit son num\xE9ro de s\xE9rie.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant le module'};
doc['Module']['get_beacon']={syn:'Retourne l\x27\xE9tat de la balise de localisation.',lib:'module.get_beacon()',pro:'int get_beacon()',cmt:'<p>Retourne l\x27\xE9tat de la balise de localisation.</p>',ret:'soit <tt>Y_BEACON_OFF</tt>, soit <tt>Y_BEACON_ON</tt>, selon l\x27\xE9tat de la balise de localisation',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_BEACON_INVALID</tt>.'};
doc['Module']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27objet module.',lib:'module.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27objet module. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du module'};
doc['Module']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27objet module.',lib:'module.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de l\x27objet module. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation du module'};
doc['Module']['get_firmwareRelease']={syn:'Retourne la version du logiciel embarqu\xE9 du module.',lib:'module.get_firmwareRelease()',pro:'String get_firmwareRelease()',cmt:'<p>Retourne la version du logiciel embarqu\xE9 du module.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la version du logiciel embarqu\xE9 du module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FIRMWARERELEASE_INVALID</tt>.'};
doc['Module']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'module.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Module']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'module.get_moduleDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Module']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'module.get_moduleId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Module']['get_hardwareId']={syn:'Retourne l\x27identifiant unique du module.',lib:'module.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant unique du module. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module suivi de la cha\xEEne \x22.module\x22.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction'};
doc['Module']['get_logicalName']={syn:'Retourne le nom logique du module.',lib:'module.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique du module.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Module']['get_luminosity']={syn:'Retourne la luminosit\xE9 des leds informatives du module (valeur entre 0 et 100).',lib:'module.get_luminosity()',pro:'int get_luminosity()',cmt:'<p>Retourne la luminosit\xE9 des leds informatives du module (valeur entre 0 et 100).</p>',ret:'un entier repr\xE9sentant la luminosit\xE9 des leds informatives du module (valeur entre 0 et 100)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LUMINOSITY_INVALID</tt>.'};
doc['Module']['get_persistentSettings']={syn:'Retourne l\x27\xE9tat courant des r\xE9glages persistents du module.',lib:'module.get_persistentSettings()',pro:'int get_persistentSettings()',cmt:'<p>Retourne l\x27\xE9tat courant des r\xE9glages persistents du module.</p>',ret:'une valeur parmi <tt>Y_PERSISTENTSETTINGS_LOADED</tt>, <tt>Y_PERSISTENTSETTINGS_SAVED</tt> et <tt>Y_PERSISTENTSETTINGS_MODIFIED</tt> repr\xE9sentant l\x27\xE9tat courant des r\xE9glages persistents du module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PERSISTENTSETTINGS_INVALID</tt>.'};
doc['Module']['get_productId']={syn:'Retourne l\x27identifiant USB du module, pr\xE9programm\xE9 en usine.',lib:'module.get_productId()',pro:'int get_productId()',cmt:'<p>Retourne l\x27identifiant USB du module, pr\xE9programm\xE9 en usine.</p>',ret:'un entier repr\xE9sentant l\x27identifiant USB du module, pr\xE9programm\xE9 en usine',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PRODUCTID_INVALID</tt>.'};
doc['Module']['get_productName']={syn:'Retourne le nom commercial du module, pr\xE9programm\xE9 en usine.',lib:'module.get_productName()',pro:'String get_productName()',cmt:'<p>Retourne le nom commercial du module, pr\xE9programm\xE9 en usine.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom commercial du module, pr\xE9programm\xE9 en usine',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PRODUCTNAME_INVALID</tt>.'};
doc['Module']['get_productRelease']={syn:'Retourne le num\xE9ro de version mat\xE9riel du module, pr\xE9programm\xE9 en usine.',lib:'module.get_productRelease()',pro:'int get_productRelease()',cmt:'<p>Retourne le num\xE9ro de version mat\xE9riel du module, pr\xE9programm\xE9 en usine.</p>',ret:'un entier repr\xE9sentant le num\xE9ro de version mat\xE9riel du module, pr\xE9programm\xE9 en usine',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PRODUCTRELEASE_INVALID</tt>.'};
doc['Module']['get_rebootCountdown']={syn:'Retourne le nombre de secondes restantes avant un red\xE9marrage du module, ou z\xE9ro si aucun red\xE9marrage n\x27a \xE9t\xE9 agend\xE9.',lib:'module.get_rebootCountdown()',pro:'int get_rebootCountdown()',cmt:'<p>Retourne le nombre de secondes restantes avant un red\xE9marrage du module, ou z\xE9ro si aucun red\xE9marrage n\x27a \xE9t\xE9 agend\xE9.</p>',ret:'un entier repr\xE9sentant le nombre de secondes restantes avant un red\xE9marrage du module, ou z\xE9ro si aucun red\xE9marrage n\x27a \xE9t\xE9 agend\xE9',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_REBOOTCOUNTDOWN_INVALID</tt>.'};
doc['Module']['get_serialNumber']={syn:'Retourne le num\xE9ro de s\xE9rie du module, pr\xE9programm\xE9 en usine.',lib:'module.get_serialNumber()',pro:'String get_serialNumber()',cmt:'<p>Retourne le num\xE9ro de s\xE9rie du module, pr\xE9programm\xE9 en usine.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le num\xE9ro de s\xE9rie du module, pr\xE9programm\xE9 en usine',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_SERIALNUMBER_INVALID</tt>.'};
doc['Module']['get_upTime']={syn:'Retourne le numbre de millisecondes \xE9coul\xE9es depuis la mise sous tension du module ',lib:'module.get_upTime()',pro:'long get_upTime()',cmt:'<p>Retourne le numbre de millisecondes \xE9coul\xE9es depuis la mise sous tension du module</p>',ret:'un entier repr\xE9sentant le numbre de millisecondes \xE9coul\xE9es depuis la mise sous tension du module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UPTIME_INVALID</tt>.'};
doc['Module']['get_usbBandwidth']={syn:'Retourne le nombre d\x27interface USB utilis\xE9 par le module.',lib:'module.get_usbBandwidth()',pro:'int get_usbBandwidth()',cmt:'<p>Retourne le nombre d\x27interface USB utilis\xE9 par le module.</p>',ret:'soit <tt>Y_USBBANDWIDTH_SIMPLE</tt>, soit <tt>Y_USBBANDWIDTH_DOUBLE</tt>, selon le nombre d\x27interface USB utilis\xE9 par le module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_USBBANDWIDTH_INVALID</tt>.'};
doc['Module']['get_usbCurrent']={syn:'Retourne le courant consomm\xE9 par le module sur le bus USB, en milliamp\xE8res.',lib:'module.get_usbCurrent()',pro:'long get_usbCurrent()',cmt:'<p>Retourne le courant consomm\xE9 par le module sur le bus USB, en milliamp\xE8res.</p>',ret:'un entier repr\xE9sentant le courant consomm\xE9 par le module sur le bus USB, en milliamp\xE8res',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_USBCURRENT_INVALID</tt>.'};
doc['Module']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'module.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Module']['isOnline']={syn:'V\xE9rifie si le module est joignable, sans d\xE9clencher d\x27erreur.',lib:'module.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs du module en cache sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si le module est joignable, <tt>false</tt> sinon'};
doc['Module']['load']={syn:'Met en cache les valeurs courantes du module, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'module.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes du module, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['nextModule']={syn:'Continue l\x27\xE9num\xE9ration des modules commenc\xE9e \xE0 l\x27aide de <tt>yFirstModule()</tt>.',lib:'module.nextModule()',pro:'YModule nextModule()',cmt:'<p>Continue l\x27\xE9num\xE9ration des modules commenc\xE9e \xE0 l\x27aide de <tt>yFirstModule()</tt>.</p>',ret:'un pointeur sur un objet <tt>YModule</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Module']['reboot']={syn:'Agende un simple red\xE9marrage du module dans un nombre donn\xE9 de secondes.',lib:'module.reboot()',pro:'int reboot(int <span id=pn>secBeforeReboot</span>)',cmt:'<p>Agende un simple red\xE9marrage du module dans un nombre donn\xE9 de secondes.</p>',par:{secBeforeReboot:'nombre de secondes avant de red\xE9marrer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['revertFromFlash']={syn:'Recharge les r\xE9glages stock\xE9s dans le m\xE9moire non volatile du module, comme \xE0 la mise sous tension du module.',lib:'module.revertFromFlash()',pro:'int revertFromFlash()',cmt:'<p>Recharge les r\xE9glages stock\xE9s dans le m\xE9moire non volatile du module, comme \xE0 la mise sous tension du module.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['saveToFlash']={syn:'Sauve les r\xE9glages courants dans la m\xE9moire non volatile du module.',lib:'module.saveToFlash()',pro:'int saveToFlash()',cmt:'<p>Sauve les r\xE9glages courants dans la m\xE9moire non volatile du module. Attention le nombre total de sauvegardes possibles durant la vie du module est limit\xE9 (environ 100000 cycles). N\x27appelez pas cette fonction dans une boucle.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['set_beacon']={syn:'Allume ou \xE9teint la balise de localisation du module.',lib:'module.set_beacon()',pro:'int set_beacon(int <span id=pn>newval</span>)',cmt:'<p>Allume ou \xE9teint la balise de localisation du module.</p>',par:{newval:'soit <tt>Y_BEACON_OFF</tt>, soit <tt>Y_BEACON_ON</tt>'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['set_logicalName']={syn:'Change le nom logique du module.',lib:'module.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Change le nom logique du module. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['set_luminosity']={syn:'Modifie la luminosit\xE9 des leds informatives du module.',lib:'module.set_luminosity()',pro:'int set_luminosity(int <span id=pn>newval</span>)',cmt:'<p>Modifie la luminosit\xE9 des leds informatives du module. Le param\xEAtre est une valeur entre 0 et 100. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'un entier repr\xE9sentant la luminosit\xE9 des leds informatives du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['set_usbBandwidth']={syn:'Modifie le nombre d\x27interface USB utilis\xE9 par le module.',lib:'module.set_usbBandwidth()',pro:'int set_usbBandwidth(int <span id=pn>newval</span>)',cmt:'<p>Modifie le nombre d\x27interface USB utilis\xE9 par le module. Vous devez red\xE9marrer le module apr\xE8s avoir chang\xE9 ce r\xE9glage.</p>',par:{newval:'soit <tt>Y_USBBANDWIDTH_SIMPLE</tt>, soit <tt>Y_USBBANDWIDTH_DOUBLE</tt>, selon le nombre d\x27interface USB utilis\xE9 par le module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Module']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'module.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Module']['triggerFirmwareUpdate']={syn:'Agende un red\xE9marrage du module en mode sp\xE9cial de reprogrammation du logiciel embarqu\xE9.',lib:'module.triggerFirmwareUpdate()',pro:'int triggerFirmwareUpdate(int <span id=pn>secBeforeReboot</span>)',cmt:'<p>Agende un red\xE9marrage du module en mode sp\xE9cial de reprogrammation du logiciel embarqu\xE9.</p>',par:{secBeforeReboot:'nombre de secondes avant de red\xE9marrer'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Module)
//--- (generated code: LightSensor)
doc['LightSensor']={'':{syn:'Interface de la fonction LightSensor',inc:'import com.yoctopuce.YoctoAPI.YLightSensor;',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
doc['LightSensor']['FindLightSensor']={syn:'Permet de retrouver un capteur de lumi\xE8re d\x27apr\xE8s un identifiant donn\xE9.',lib:'YLightSensor.FindLightSensor()',pro:'YLightSensor FindLightSensor(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de lumi\xE8re d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le capteur de lumi\xE8re soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YLightSensor.isOnline()</tt> pour tester si le capteur de lumi\xE8re est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de lumi\xE8re sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YLightSensor</tt> qui permet ensuite de contr\xF4ler le capteur de lumi\xE8re.'};
doc['LightSensor']['FirstLightSensor']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de lumi\xE8re accessibles par la librairie.',lib:'YLightSensor.FirstLightSensor()',pro:'YLightSensor FirstLightSensor()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de lumi\xE8re accessibles par la librairie. Utiliser la fonction <tt>YLightSensor.nextLightSensor()</tt> pour it\xE9rer sur les autres capteurs de lumi\xE8re.</p>',ret:'un pointeur sur un objet <tt>YLightSensor</tt>, correspondant \xE0 le premier capteur de lumi\xE8re accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de lumi\xE8re disponibles.'};
doc['LightSensor']['calibrate']={syn:'Modifie le param\xE8tre de calibration sp\xE9cifique du senseur de sorte \xE0 ce que la valeur actuelle corresponde \xE0 une consigne donn\xE9e (correction lin\xE9aire).',lib:'lightsensor.calibrate()',pro:'int calibrate(double <span id=pn>calibratedVal</span>)',cmt:'<p>Modifie le param\xE8tre de calibration sp\xE9cifique du senseur de sorte \xE0 ce que la valeur actuelle corresponde \xE0 une consigne donn\xE9e (correction lin\xE9aire).</p>',par:{calibratedVal:'la consigne de valeur d\xE9sir\xE9e. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['LightSensor']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'lightsensor.calibrateFromPoints()',pro:'int calibrateFromPoints(ArrayList&lt;Double&gt; <span id=pn>rawValues</span>,&nbsp;ArrayList&lt;Double&gt; <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. </p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['LightSensor']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'lightsensor.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['LightSensor']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de lumi\xE8re (pas plus de 6 caract\xE8res).',lib:'lightsensor.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de lumi\xE8re (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de lumi\xE8re (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['LightSensor']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'lightsensor.get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['LightSensor']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'lightsensor.get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'lightsensor.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['LightSensor']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'lightsensor.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['LightSensor']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'lightsensor.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['LightSensor']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'lightsensor.get_lightsensorDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['LightSensor']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'lightsensor.get_lightsensorId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['LightSensor']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'lightsensor.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['LightSensor']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e.',lib:'lightsensor.get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur maximale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_logicalName']={syn:'Retourne le nom logique du capteur de lumi\xE8re.',lib:'lightsensor.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de lumi\xE8re.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de lumi\xE8re',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['LightSensor']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e.',lib:'lightsensor.get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur minimale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['LightSensor']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'lightsensor.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['LightSensor']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'lightsensor.get_resolution()',pro:'double get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['LightSensor']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'lightsensor.get_unit()',pro:'String get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['LightSensor']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'lightsensor.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['LightSensor']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'lightsensor.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['LightSensor']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'lightsensor.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['LightSensor']['nextLightSensor']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de lumi\xE8re commenc\xE9e \xE0 l\x27aide de <tt>yFirstLightSensor()</tt>.',lib:'lightsensor.nextLightSensor()',pro:'YLightSensor nextLightSensor()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de lumi\xE8re commenc\xE9e \xE0 l\x27aide de <tt>yFirstLightSensor()</tt>.</p>',ret:'un pointeur sur un objet <tt>YLightSensor</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['LightSensor']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'lightsensor.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['LightSensor']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'lightsensor.set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['LightSensor']['set_logicalName']={syn:'Modifie le nom logique du capteur de lumi\xE8re.',lib:'lightsensor.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de lumi\xE8re. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de lumi\xE8re'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['LightSensor']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'lightsensor.set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['LightSensor']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'lightsensor.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: LightSensor)
//--- (generated code: Temperature)
doc['Temperature']={'':{syn:'Interface de la fonction Temperature',inc:'import com.yoctopuce.YoctoAPI.YTemperature;',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
doc['Temperature']['FindTemperature']={syn:'Permet de retrouver un capteur de temp\xE9rature d\x27apr\xE8s un identifiant donn\xE9.',lib:'YTemperature.FindTemperature()',pro:'YTemperature FindTemperature(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de temp\xE9rature d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le capteur de temp\xE9rature soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YTemperature.isOnline()</tt> pour tester si le capteur de temp\xE9rature est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de temp\xE9rature sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YTemperature</tt> qui permet ensuite de contr\xF4ler le capteur de temp\xE9rature.'};
doc['Temperature']['FirstTemperature']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de temp\xE9rature accessibles par la librairie.',lib:'YTemperature.FirstTemperature()',pro:'YTemperature FirstTemperature()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de temp\xE9rature accessibles par la librairie. Utiliser la fonction <tt>YTemperature.nextTemperature()</tt> pour it\xE9rer sur les autres capteurs de temp\xE9rature.</p>',ret:'un pointeur sur un objet <tt>YTemperature</tt>, correspondant \xE0 le premier capteur de temp\xE9rature accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de temp\xE9rature disponibles.'};
doc['Temperature']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'temperature.calibrateFromPoints()',pro:'int calibrateFromPoints(ArrayList&lt;Double&gt; <span id=pn>rawValues</span>,&nbsp;ArrayList&lt;Double&gt; <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. </p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'temperature.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Temperature']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de temp\xE9rature (pas plus de 6 caract\xE8res).',lib:'temperature.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de temp\xE9rature (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de temp\xE9rature (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Temperature']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'temperature.get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Temperature']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'temperature.get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Temperature']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'temperature.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Temperature']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'temperature.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Temperature']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'temperature.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Temperature']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'temperature.get_temperatureDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Temperature']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'temperature.get_temperatureId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Temperature']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'temperature.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Temperature']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e.',lib:'temperature.get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur maximale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Temperature']['get_logicalName']={syn:'Retourne le nom logique du capteur de temp\xE9rature.',lib:'temperature.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de temp\xE9rature.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de temp\xE9rature',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Temperature']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e.',lib:'temperature.get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur minimale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Temperature']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'temperature.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Temperature']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'temperature.get_resolution()',pro:'double get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Temperature']['get_sensorType']={syn:'Retourne le type de capteur de temp\xE9rature utilis\xE9 par le module ',lib:'temperature.get_sensorType()',pro:'int get_sensorType()',cmt:'<p>Retourne le type de capteur de temp\xE9rature utilis\xE9 par le module</p>',ret:'une valeur parmi <tt>Y_SENSORTYPE_DIGITAL</tt>, <tt>Y_SENSORTYPE_TYPE_K</tt>, <tt>Y_SENSORTYPE_TYPE_E</tt>, <tt>Y_SENSORTYPE_TYPE_J</tt>, <tt>Y_SENSORTYPE_TYPE_N</tt>, <tt>Y_SENSORTYPE_TYPE_R</tt>, <tt>Y_SENSORTYPE_TYPE_S</tt> et <tt>Y_SENSORTYPE_TYPE_T</tt> repr\xE9sentant le type de capteur de temp\xE9rature utilis\xE9 par le module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_SENSORTYPE_INVALID</tt>.'};
doc['Temperature']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'temperature.get_unit()',pro:'String get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Temperature']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'temperature.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Temperature']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'temperature.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Temperature']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'temperature.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['nextTemperature']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de temp\xE9rature commenc\xE9e \xE0 l\x27aide de <tt>yFirstTemperature()</tt>.',lib:'temperature.nextTemperature()',pro:'YTemperature nextTemperature()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de temp\xE9rature commenc\xE9e \xE0 l\x27aide de <tt>yFirstTemperature()</tt>.</p>',ret:'un pointeur sur un objet <tt>YTemperature</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Temperature']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'temperature.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Temperature']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'temperature.set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['set_logicalName']={syn:'Modifie le nom logique du capteur de temp\xE9rature.',lib:'temperature.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de temp\xE9rature. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de temp\xE9rature'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'temperature.set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['set_sensorType']={syn:'Change le type de senseur utilis\xE9 par le module.',lib:'temperature.set_sensorType()',pro:'int set_sensorType(int <span id=pn>newval</span>)',cmt:'<p>Change le type de senseur utilis\xE9 par le module. Cette function sert \xE0 sp\xE9cifier le type de thermocouple (K,E, etc..) raccord\xE9 au module. Cette fonction n\x27aura pas d\x27effet si le module utilise un capteur digital. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une valeur parmi <tt>Y_SENSORTYPE_DIGITAL</tt>, <tt>Y_SENSORTYPE_TYPE_K</tt>, <tt>Y_SENSORTYPE_TYPE_E</tt>, <tt>Y_SENSORTYPE_TYPE_J</tt>, <tt>Y_SENSORTYPE_TYPE_N</tt>, <tt>Y_SENSORTYPE_TYPE_R</tt>, <tt>Y_SENSORTYPE_TYPE_S</tt> et <tt>Y_SENSORTYPE_TYPE_T</tt>'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Temperature']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'temperature.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Temperature)
//--- (generated code: DataLogger)
doc['DataLogger']={'':{syn:'Interface de la fonction DataLogger',inc:'import com.yoctopuce.YoctoAPI.YDataLogger;',cmt:'<p>Les capteurs de Yoctopuce sont \xE9quip\xE9s d\x27une m\xE9moire non-volatile permettant de m\xE9moriser les donn\xE9es mesur\xE9es d\x27une mani\xE8re autonome, sans n\xE9cessiter le suivi permanent d\x27un ordinateur. La librairie de programmation Yoctopuce permet de contr\xF4ler le fonctionnement de l\x27enregistreur de donn\xE9es interne. Dans la mesure o\xF9 les capteurs n\x27ont pas de pile int\xE9gr\xE9e, ils ne contiennent pas de r\xE9f\xE9rence de temps absolue. C\x27est pourquoi les mesures sont simplement index\xE9es par le num\xE9ro de Run (p\xE9riode continue de fonctionnement lors d\x27une mise sous tension), et \xE0 l\x27intervalle de temps depuis le d\xE9but du Run. Il est par contre possible d\x27indiquer par logiciel \xE0 l\x27enregistreur de donn\xE9es l\x27heure UTC \xE0 un moment donn\xE9e, afin qu\x27il en tienne compte jusqu\x27\xE0 la prochaine mise hors tension.</p>'}};
doc['DataLogger']['FindDataLogger']={syn:'Permet de retrouver un enregistreur de donn\xE9es d\x27apr\xE8s un identifiant donn\xE9.',lib:'YDataLogger.FindDataLogger()',pro:'YDataLogger FindDataLogger(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver un enregistreur de donn\xE9es d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que l\x27enregistreur de donn\xE9es soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YDataLogger.isOnline()</tt> pour tester si l\x27enregistreur de donn\xE9es est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27enregistreur de donn\xE9es sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YDataLogger</tt> qui permet ensuite de contr\xF4ler l\x27enregistreur de donn\xE9es.'};
doc['DataLogger']['FirstDataLogger']={syn:'Commence l\x27\xE9num\xE9ration des enregistreurs de donn\xE9es accessibles par la librairie.',lib:'YDataLogger.FirstDataLogger()',pro:'YDataLogger FirstDataLogger()',cmt:'<p>Commence l\x27\xE9num\xE9ration des enregistreurs de donn\xE9es accessibles par la librairie. Utiliser la fonction <tt>YDataLogger.nextDataLogger()</tt> pour it\xE9rer sur les autres enregistreurs de donn\xE9es.</p>',ret:'un pointeur sur un objet <tt>YDataLogger</tt>, correspondant \xE0 le premier enregistreur de donn\xE9es accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de enregistreurs de donn\xE9es disponibles.'};
doc['DataLogger']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'datalogger.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['DataLogger']['forgetAllDataStreams']={syn:'Efface tout l\x27historique des mesures de l\x27enregistreur de donn\xE9es.',lib:'datalogger.forgetAllDataStreams()',pro:'int forgetAllDataStreams()',cmt:'<p>Efface tout l\x27historique des mesures de l\x27enregistreur de donn\xE9es. Cette m\xE9thode remet aussi \xE0 z\xE9ro le compteur de Runs.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27enregistreur de donn\xE9es (pas plus de 6 caract\xE8res).',lib:'datalogger.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27enregistreur de donn\xE9es (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27enregistreur de donn\xE9es (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DataLogger']['get_autoStart']={syn:'Retourne le mode d\x27activation automatique de l\x27enregistreur de donn\xE9es \xE0 la mise sous tension.',lib:'datalogger.get_autoStart()',pro:'int get_autoStart()',cmt:'<p>Retourne le mode d\x27activation automatique de l\x27enregistreur de donn\xE9es \xE0 la mise sous tension.</p>',ret:'soit <tt>Y_AUTOSTART_OFF</tt>, soit <tt>Y_AUTOSTART_ON</tt>, selon le mode d\x27activation automatique de l\x27enregistreur de donn\xE9es \xE0 la mise sous tension',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_AUTOSTART_INVALID</tt>.'};
doc['DataLogger']['get_currentRunIndex']={syn:'Retourne le num\xE9ro du Run actuel, correspondant au nombre de fois que le module a \xE9t\xE9 mis sous tension avec la fonction d\x27enregistreur de donn\xE9es active.',lib:'datalogger.get_currentRunIndex()',pro:'int get_currentRunIndex()',cmt:'<p>Retourne le num\xE9ro du Run actuel, correspondant au nombre de fois que le module a \xE9t\xE9 mis sous tension avec la fonction d\x27enregistreur de donn\xE9es active.</p>',ret:'un entier repr\xE9sentant le num\xE9ro du Run actuel, correspondant au nombre de fois que le module a \xE9t\xE9 mis sous tension avec la fonction d\x27enregistreur de donn\xE9es active',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRUNINDEX_INVALID</tt>.'};
doc['DataLogger']['get_dataRun']={syn:'Retourne un objet YDataRun contenant toutes les donn\xE9es mesur\xE9es pour une p\xE9riode d\x27enclanchement du module donn\xE9e (un Run).',lib:'datalogger.get_dataRun()',pro:'YDataRun get_dataRun(int <span id=pn>runIdx</span>)',cmt:'<p>Retourne un objet YDataRun contenant toutes les donn\xE9es mesur\xE9es pour une p\xE9riode d\x27enclanchement du module donn\xE9e (un Run). Cet objet pourra \xEAtre utilis\xE9 pour r\xE9cup\xE9rer les mesures (valeur min, valeur moyenne et valeur max) avec la granularit\xE9 d\xE9sir\xE9e.</p>',par:{runIdx:'l\x27index du Run d\xE9sir\xE9'},ret:'un objet <tt>YDataRun</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['get_dataStreams']={syn:'Construit une liste de toutes les s\xE9quences de mesures m\xE9moris\xE9es par l\x27enregistreur.',lib:'datalogger.get_dataStreams()',pro:'int get_dataStreams(ArrayList&lt;YDataStream&gt; <span id=pn>v</span>)',cmt:'<p>Construit une liste de toutes les s\xE9quences de mesures m\xE9moris\xE9es par l\x27enregistreur. L\x27appelant doit passer par r\xE9f\xE9rence un tableau vide pout stocker les objets YDataStream, et la m\xE9thode va les remplire avec des objets d\xE9crivant les s\xE9quences de donn\xE9es disponibles.</p>',par:{v:'un tableau de YDataStreams qui sera rempli avec les s\xE9quences trouv\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'datalogger.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['DataLogger']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'datalogger.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['DataLogger']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'datalogger.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['DataLogger']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'datalogger.get_dataloggerDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['DataLogger']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'datalogger.get_dataloggerId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['DataLogger']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'datalogger.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DataLogger']['get_logicalName']={syn:'Retourne le nom logique de l\x27enregistreur de donn\xE9es.',lib:'datalogger.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27enregistreur de donn\xE9es.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DataLogger']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'datalogger.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['DataLogger']['get_oldestRunIndex']={syn:'Retourne le num\xE9ro du Run le plus ancien pour lequel la m\xE9moire non-volatile contient encore des donn\xE9es.',lib:'datalogger.get_oldestRunIndex()',pro:'int get_oldestRunIndex()',cmt:'<p>Retourne le num\xE9ro du Run le plus ancien pour lequel la m\xE9moire non-volatile contient encore des donn\xE9es.</p>',ret:'un entier repr\xE9sentant le num\xE9ro du Run le plus ancien pour lequel la m\xE9moire non-volatile contient encore des donn\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_OLDESTRUNINDEX_INVALID</tt>.'};
doc['DataLogger']['get_recording']={syn:'Retourne l\x27\xE9tat d\x27activation de l\x27enregistreur de donn\xE9es.',lib:'datalogger.get_recording()',pro:'int get_recording()',cmt:'<p>Retourne l\x27\xE9tat d\x27activation de l\x27enregistreur de donn\xE9es.</p>',ret:'soit <tt>Y_RECORDING_OFF</tt>, soit <tt>Y_RECORDING_ON</tt>, selon l\x27\xE9tat d\x27activation de l\x27enregistreur de donn\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RECORDING_INVALID</tt>.'};
doc['DataLogger']['get_timeUTC']={syn:'Retourne le timestamp Unix de l\x27heure UTC actuelle, lorsqu\x27elle est connue.',lib:'datalogger.get_timeUTC()',pro:'long get_timeUTC()',cmt:'<p>Retourne le timestamp Unix de l\x27heure UTC actuelle, lorsqu\x27elle est connue.</p>',ret:'un entier repr\xE9sentant le timestamp Unix de l\x27heure UTC actuelle, lorsqu\x27elle est connue',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_TIMEUTC_INVALID</tt>.'};
doc['DataLogger']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'datalogger.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['DataLogger']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'datalogger.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['DataLogger']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'datalogger.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['nextDataLogger']={syn:'Continue l\x27\xE9num\xE9ration des enregistreurs de donn\xE9es commenc\xE9e \xE0 l\x27aide de <tt>yFirstDataLogger()</tt>.',lib:'datalogger.nextDataLogger()',pro:'YDataLogger nextDataLogger()',cmt:'<p>Continue l\x27\xE9num\xE9ration des enregistreurs de donn\xE9es commenc\xE9e \xE0 l\x27aide de <tt>yFirstDataLogger()</tt>.</p>',ret:'un pointeur sur un objet <tt>YDataLogger</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['DataLogger']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'datalogger.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['DataLogger']['set_autoStart']={syn:'Modifie le mode d\x27activation automatique de l\x27enregistreur de donn\xE9es \xE0 la mise sous tension.',lib:'datalogger.set_autoStart()',pro:'int set_autoStart(int <span id=pn>newval</span>)',cmt:'<p>Modifie le mode d\x27activation automatique de l\x27enregistreur de donn\xE9es \xE0 la mise sous tension. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'soit <tt>Y_AUTOSTART_OFF</tt>, soit <tt>Y_AUTOSTART_ON</tt>, selon le mode d\x27activation automatique de l\x27enregistreur de donn\xE9es \xE0 la mise sous tension'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['set_logicalName']={syn:'Modifie le nom logique de l\x27enregistreur de donn\xE9es.',lib:'datalogger.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27enregistreur de donn\xE9es. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27enregistreur de donn\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['set_recording']={syn:'Modifie l\x27\xE9tat d\x27activation de l\x27enregistreur de donn\xE9es.',lib:'datalogger.set_recording()',pro:'int set_recording(int <span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat d\x27activation de l\x27enregistreur de donn\xE9es.</p>',par:{newval:'soit <tt>Y_RECORDING_OFF</tt>, soit <tt>Y_RECORDING_ON</tt>, selon l\x27\xE9tat d\x27activation de l\x27enregistreur de donn\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['set_timeUTC']={syn:'Modifie la r\xE9f\xE9rence de temps UTC, afin de l\x27attacher aux donn\xE9es enregistr\xE9es.',lib:'datalogger.set_timeUTC()',pro:'int set_timeUTC(long <span id=pn>newval</span>)',cmt:'<p>Modifie la r\xE9f\xE9rence de temps UTC, afin de l\x27attacher aux donn\xE9es enregistr\xE9es.</p>',par:{newval:'un entier repr\xE9sentant la r\xE9f\xE9rence de temps UTC, afin de l\x27attacher aux donn\xE9es enregistr\xE9es'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DataLogger']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'datalogger.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: DataLogger)
//--- (generated code: DataRun)
doc['DataRun']={'':{syn:'S\xE9quence de donn\xE9es mise en forme',inc:'import com.yoctopuce.YoctoAPI.YDataLogger;',cmt:'<p>Un Run est un intervalle de temps pendant lequel un module est sous tension. Les objets YDataRun fournissent un acc\xE8s facilit\xE9 \xE0 toutes les mesures collect\xE9es durant un Run donn\xE9, y compris en permettant la lecture par mesure distantes d\x27un intervalle sp\xE9cifi\xE9.</p>'}};
doc['DataRun']['get_averageValue']={syn:'Retourne la valeur moyenne des mesures observ\xE9es au moment choisi.',lib:'datarun.get_averageValue()',pro:'double get_averageValue(String <span id=pn>measureName</span>, int <span id=pn>pos</span>)',cmt:'<p>Retourne la valeur moyenne des mesures observ\xE9es au moment choisi.</p>',par:{measureName:'le nom de la mesure d\xE9sir\xE9e (un des noms retourn\xE9s par <tt>get_measureNames</tt>)',pos:'l\x27index de la position d\xE9sir\xE9e, entre 0 et la valeur de <tt>get_valueCount</tt>'},ret:'une nombre flottant (la valeur moyenne).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne Y_AVERAGEVALUE_INVALID.'};
doc['DataRun']['get_duration']={syn:'Retourne la dur\xE9e (en secondes) du Run.',lib:'datarun.get_duration()',pro:'long get_duration()',cmt:'<p>Retourne la dur\xE9e (en secondes) du Run. Lorsque cette m\xE9thode est appell\xE9e dur le Run courant et que l\x27enregistreur de donn\xE9es est actif, l\x27appel \xE0 cette m\xE9thode force un rechargement de la derni\xE8re s\xE9quence du module pour s\x27assurer que la r\xE9ponse prend en compte les derni\xE8res donn\xE9es enregistr\xE9es.</p>',ret:'un entier positif correspondant au nombre de secondes \xE9coul\xE9es entre le d\xE9but du Run (quand le module a \xE9t\xE9 mis sous tension) et la derni\xE8re mesure enregistr\xE9e.'};
doc['DataRun']['get_maxValue']={syn:'Retourne la valeur maximale des mesures observ\xE9es au moment choisi.',lib:'datarun.get_maxValue()',pro:'double get_maxValue(String <span id=pn>measureName</span>, int <span id=pn>pos</span>)',cmt:'<p>Retourne la valeur maximale des mesures observ\xE9es au moment choisi.</p>',par:{measureName:'le nom de la mesure d\xE9sir\xE9e (un des noms retourn\xE9s par <tt>get_measureNames</tt>)',pos:'l\x27index de la position d\xE9sir\xE9e, entre 0 et la valeur de <tt>get_valueCount</tt>'},ret:'une nombre flottant (la valeur maximale).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne Y_MAXVALUE_INVALID.'};
doc['DataRun']['get_measureNames']={syn:'Retourne les noms des valeurs mesur\xE9es par l\x27enregistreur de donn\xE9es.',lib:'datarun.get_measureNames()',pro:'ArrayList&lt;String&gt; get_measureNames()',cmt:'<p>Retourne les noms des valeurs mesur\xE9es par l\x27enregistreur de donn\xE9es. Dans la plupart des cas, le nom des colonnes correspond \xE0 l\x27identifiant mat\xE9riel du capteur qui a produit la mesure.</p>',ret:'une liste de cha\xEEne de caract\xE8res (les noms des mesures)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne une liste vide.'};
doc['DataRun']['get_minValue']={syn:'Retourne la valeur minimale des mesures observ\xE9es au moment choisi.',lib:'datarun.get_minValue()',pro:'double get_minValue(String <span id=pn>measureName</span>, int <span id=pn>pos</span>)',cmt:'<p>Retourne la valeur minimale des mesures observ\xE9es au moment choisi.</p>',par:{measureName:'le nom de la mesure d\xE9sir\xE9e (un des noms retourn\xE9s par <tt>get_measureNames</tt>)',pos:'l\x27index de la position d\xE9sir\xE9e, entre 0 et la valeur de <tt>get_valueCount</tt>'},ret:'une nombre flottant (la valeur minimale).',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne Y_MINVALUE_INVALID.'};
doc['DataRun']['get_valueCount']={syn:'Retourne le nombre de valeurs accessibles dans ce Run, \xE9tant donn\xE9 l\x27intervalle de temps choisi entre les valeurs.',lib:'datarun.get_valueCount()',pro:'int get_valueCount()',cmt:'<p>Retourne le nombre de valeurs accessibles dans ce Run, \xE9tant donn\xE9 l\x27intervalle de temps choisi entre les valeurs. Lorsque cette m\xE9thode est appell\xE9e dur le Run courant et que l\x27enregistreur de donn\xE9es est actif, l\x27appel \xE0 cette m\xE9thode force un rechargement de la derni\xE8re s\xE9quence du module pour s\x27assurer que la r\xE9ponse prend en compte les derni\xE8res donn\xE9es enregistr\xE9es.</p>',ret:'un entier positif correspondant \xE0 la dur\xE9e du Run divis\xE9e par l\x27intervalle entre les valeurs.'};
doc['DataRun']['get_valueInterval']={syn:'Retourne l\x27intervalle de temps repr\xE9sent\xE9 par chaque valeur de ce run.',lib:'datarun.get_valueInterval()',pro:'int get_valueInterval()',cmt:'<p>Retourne l\x27intervalle de temps repr\xE9sent\xE9 par chaque valeur de ce run. La valeur par d\xE9faut correspond \xE0 la plus grande granularit\xE9 des mesures archiv\xE9es dans la flash de l\x27enregistreur de donn\xE9es pour ce Run, mais l\x27intervalle \xE0 utiliser peut \xEAtre configur\xE9 librement si d\xE9sir\xE9.</p>',ret:'un entier positif correspondant au nombre de secondes couvertes par chaque valeur repr\xE9sent\xE9e dans le Run.'};
doc['DataRun']['set_valueInterval']={syn:'Change l\x27intervalle de temps repr\xE9sent\xE9 par chaque valeur de ce run.',lib:'datarun.set_valueInterval()',pro:'void set_valueInterval(int <span id=pn>valueInterval</span>)',cmt:'<p>Change l\x27intervalle de temps repr\xE9sent\xE9 par chaque valeur de ce run. La valeur par d\xE9faut correspond \xE0 la plus grande granularit\xE9 des mesures archiv\xE9es dans la flash de l\x27enregistreur de donn\xE9es pour ce Run, mais l\x27intervalle \xE0 utiliser peut \xEAtre configur\xE9 librement si d\xE9sir\xE9.</p>',par:{valueInterval:'un nombre entier de secondes.'},ret:'nothing'};
//--- (end of generated code: DataRun)
//--- (generated code: Humidity)
doc['Humidity']={'':{syn:'Interface de la fonction Humidity',inc:'import com.yoctopuce.YoctoAPI.YHumidity;',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
doc['Humidity']['FindHumidity']={syn:'Permet de retrouver un capteur d\x27humidit\xE9 d\x27apr\xE8s un identifiant donn\xE9.',lib:'YHumidity.FindHumidity()',pro:'YHumidity FindHumidity(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur d\x27humidit\xE9 d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le capteur d\x27humidit\xE9 soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YHumidity.isOnline()</tt> pour tester si le capteur d\x27humidit\xE9 est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur d\x27humidit\xE9 sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YHumidity</tt> qui permet ensuite de contr\xF4ler le capteur d\x27humidit\xE9.'};
doc['Humidity']['FirstHumidity']={syn:'Commence l\x27\xE9num\xE9ration des capteurs d\x27humidit\xE9 accessibles par la librairie.',lib:'YHumidity.FirstHumidity()',pro:'YHumidity FirstHumidity()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs d\x27humidit\xE9 accessibles par la librairie. Utiliser la fonction <tt>YHumidity.nextHumidity()</tt> pour it\xE9rer sur les autres capteurs d\x27humidit\xE9.</p>',ret:'un pointeur sur un objet <tt>YHumidity</tt>, correspondant \xE0 le premier capteur d\x27humidit\xE9 accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs d\x27humidit\xE9 disponibles.'};
doc['Humidity']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'humidity.calibrateFromPoints()',pro:'int calibrateFromPoints(ArrayList&lt;Double&gt; <span id=pn>rawValues</span>,&nbsp;ArrayList&lt;Double&gt; <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. </p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Humidity']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'humidity.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Humidity']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur d\x27humidit\xE9 (pas plus de 6 caract\xE8res).',lib:'humidity.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur d\x27humidit\xE9 (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur d\x27humidit\xE9 (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Humidity']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'humidity.get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Humidity']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'humidity.get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Humidity']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'humidity.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Humidity']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'humidity.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Humidity']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'humidity.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Humidity']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'humidity.get_humidityDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Humidity']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'humidity.get_humidityId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Humidity']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'humidity.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Humidity']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e.',lib:'humidity.get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur maximale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Humidity']['get_logicalName']={syn:'Retourne le nom logique du capteur d\x27humidit\xE9.',lib:'humidity.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique du capteur d\x27humidit\xE9.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur d\x27humidit\xE9',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Humidity']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e.',lib:'humidity.get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur minimale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Humidity']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'humidity.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Humidity']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'humidity.get_resolution()',pro:'double get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Humidity']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'humidity.get_unit()',pro:'String get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Humidity']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'humidity.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Humidity']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'humidity.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Humidity']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'humidity.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Humidity']['nextHumidity']={syn:'Continue l\x27\xE9num\xE9ration des capteurs d\x27humidit\xE9 commenc\xE9e \xE0 l\x27aide de <tt>yFirstHumidity()</tt>.',lib:'humidity.nextHumidity()',pro:'YHumidity nextHumidity()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs d\x27humidit\xE9 commenc\xE9e \xE0 l\x27aide de <tt>yFirstHumidity()</tt>.</p>',ret:'un pointeur sur un objet <tt>YHumidity</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Humidity']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'humidity.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Humidity']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'humidity.set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Humidity']['set_logicalName']={syn:'Modifie le nom logique du capteur d\x27humidit\xE9.',lib:'humidity.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur d\x27humidit\xE9. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur d\x27humidit\xE9'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Humidity']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'humidity.set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Humidity']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'humidity.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Humidity)
//--- (generated code: Co2)
doc['Co2']={'':{syn:'Interface de la fonction CO2',inc:'require_once(&#039;yocto_co2.java&#039;);',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
//--- (end of generated code: Co2)
//--- (generated code: CarbonDioxide)
doc['CarbonDioxide']={'':{syn:'Interface de la fonction CarbonDioxide',inc:'import com.yoctopuce.YoctoAPI.YCarbonDioxide;',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
doc['CarbonDioxide']['FindCarbonDioxide']={syn:'Permet de retrouver un capteur de CO2 d\x27apr\xE8s un identifiant donn\xE9.',lib:'YCarbonDioxide.FindCarbonDioxide()',pro:'YCarbonDioxide FindCarbonDioxide(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de CO2 d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le capteur de CO2 soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YCarbonDioxide.isOnline()</tt> pour tester si le capteur de CO2 est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de CO2 sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YCarbonDioxide</tt> qui permet ensuite de contr\xF4ler le capteur de CO2.'};
doc['CarbonDioxide']['FirstCarbonDioxide']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de CO2 accessibles par la librairie.',lib:'YCarbonDioxide.FirstCarbonDioxide()',pro:'YCarbonDioxide FirstCarbonDioxide()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de CO2 accessibles par la librairie. Utiliser la fonction <tt>YCarbonDioxide.nextCarbonDioxide()</tt> pour it\xE9rer sur les autres capteurs de CO2.</p>',ret:'un pointeur sur un objet <tt>YCarbonDioxide</tt>, correspondant \xE0 le premier capteur de CO2 accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de CO2 disponibles.'};
doc['CarbonDioxide']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'carbondioxide.calibrateFromPoints()',pro:'int calibrateFromPoints(ArrayList&lt;Double&gt; <span id=pn>rawValues</span>,&nbsp;ArrayList&lt;Double&gt; <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. </p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CarbonDioxide']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'carbondioxide.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['CarbonDioxide']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de CO2 (pas plus de 6 caract\xE8res).',lib:'carbondioxide.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de CO2 (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de CO2 (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'carbondioxide.get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'carbondioxide.get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'carbondioxide.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['CarbonDioxide']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'carbondioxide.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['CarbonDioxide']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'carbondioxide.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['CarbonDioxide']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'carbondioxide.get_carbondioxideDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['CarbonDioxide']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'carbondioxide.get_carbondioxideId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['CarbonDioxide']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'carbondioxide.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['CarbonDioxide']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e.',lib:'carbondioxide.get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur maximale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_logicalName']={syn:'Retourne le nom logique du capteur de CO2.',lib:'carbondioxide.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de CO2.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de CO2',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['CarbonDioxide']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e.',lib:'carbondioxide.get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur minimale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['CarbonDioxide']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'carbondioxide.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['CarbonDioxide']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'carbondioxide.get_resolution()',pro:'double get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['CarbonDioxide']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'carbondioxide.get_unit()',pro:'String get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['CarbonDioxide']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'carbondioxide.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['CarbonDioxide']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'carbondioxide.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['CarbonDioxide']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'carbondioxide.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CarbonDioxide']['nextCarbonDioxide']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de CO2 commenc\xE9e \xE0 l\x27aide de <tt>yFirstCarbonDioxide()</tt>.',lib:'carbondioxide.nextCarbonDioxide()',pro:'YCarbonDioxide nextCarbonDioxide()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de CO2 commenc\xE9e \xE0 l\x27aide de <tt>yFirstCarbonDioxide()</tt>.</p>',ret:'un pointeur sur un objet <tt>YCarbonDioxide</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['CarbonDioxide']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'carbondioxide.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['CarbonDioxide']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'carbondioxide.set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CarbonDioxide']['set_logicalName']={syn:'Modifie le nom logique du capteur de CO2.',lib:'carbondioxide.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de CO2. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de CO2'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CarbonDioxide']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'carbondioxide.set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['CarbonDioxide']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'carbondioxide.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: CarbonDioxide)
//--- (generated code: Vsource)
doc['Vsource']={'':{syn:'Interface de la fonction Vsource',inc:'require_once(&#039;yocto_vsource.java&#039;);'}};
//--- (end of generated code: Vsource)
//--- (generated code: VSource)
doc['VSource']={'':{syn:'Interface de la fonction Source de tension',inc:'import com.yoctopuce.YoctoAPI.YVSource;',cmt:'<p>La librairie de programmation Yoctopuce permet de commande la tension de srotir du module. Vous pouvez affecter une valeur fixe,ou faire des transition de voltage.</p>'}};
doc['VSource']['FindVSource']={syn:'Permet de retrouver une source de tension d\x27apr\xE8s un identifiant donn\xE9.',lib:'YVSource.FindVSource()',pro:'YVSource FindVSource(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver une source de tension d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que la source de tension soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YVSource.isOnline()</tt> pour tester si la source de tension est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence la source de tension sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YVSource</tt> qui permet ensuite de contr\xF4ler la source de tension.'};
doc['VSource']['FirstVSource']={syn:'Commence l\x27\xE9num\xE9ration des sources de tension accessibles par la librairie.',lib:'YVSource.FirstVSource()',pro:'YVSource FirstVSource()',cmt:'<p>Commence l\x27\xE9num\xE9ration des sources de tension accessibles par la librairie. Utiliser la fonction <tt>YVSource.nextVSource()</tt> pour it\xE9rer sur les autres sources de tension.</p>',ret:'un pointeur sur un objet <tt>YVSource</tt>, correspondant \xE0 la premi\xE8re source de tension accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de sources de tension disponibles.'};
doc['VSource']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'vsource.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['VSource']['get_advertisedValue']={syn:'Retourne la valeur courante de la source de tension (pas plus de 6 caract\xE8res).',lib:'vsource.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante de la source de tension (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de la source de tension (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['VSource']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'vsource.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['VSource']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'vsource.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['VSource']['get_extPowerFailure']={syn:'Rend TRUE si le voltage de l\x27alimentation externe est trop bas.',lib:'vsource.get_extPowerFailure()',pro:'int get_extPowerFailure()',cmt:'<p>Rend TRUE si le voltage de l\x27alimentation externe est trop bas.</p>',ret:'soit <tt>Y_EXTPOWERFAILURE_FALSE</tt>, soit <tt>Y_EXTPOWERFAILURE_TRUE</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_EXTPOWERFAILURE_INVALID</tt>.'};
doc['VSource']['get_failure']={syn:'Indique si le module est en condition d\x27erreur.',lib:'vsource.get_failure()',pro:'int get_failure()',cmt:'<p>Indique si le module est en condition d\x27erreur. Il possible de savoir de quelle erreur il s\x27agit en testant get_overheat, get_overcurrent etc... Lorsqu\x27un condition d\x27erreur est rencont\xE9e, la tension de sortie est mise \xE0 z\xE9ro est ne peut pas \xEAtre chang\xE9e tant la fonction reset() n\x27aura pas appell\xE9e.</p>',ret:'soit <tt>Y_FAILURE_FALSE</tt>, soit <tt>Y_FAILURE_TRUE</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FAILURE_INVALID</tt>.'};
doc['VSource']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'vsource.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['VSource']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'vsource.get_vsourceDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['VSource']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'vsource.get_vsourceId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['VSource']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'vsource.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['VSource']['get_logicalName']={syn:'Retourne le nom logique de la source de tension.',lib:'vsource.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique de la source de tension.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la source de tension',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['VSource']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'vsource.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['VSource']['get_overCurrent']={syn:'Rend TRUE si l\x27appareil connect\xE9 \xE0 la sortie du module consomme trop de courant.',lib:'vsource.get_overCurrent()',pro:'int get_overCurrent()',cmt:'<p>Rend TRUE si l\x27appareil connect\xE9 \xE0 la sortie du module consomme trop de courant.</p>',ret:'soit <tt>Y_OVERCURRENT_FALSE</tt>, soit <tt>Y_OVERCURRENT_TRUE</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_OVERCURRENT_INVALID</tt>.'};
doc['VSource']['get_overHeat']={syn:'Rend TRUE si le module est en surchauffe.',lib:'vsource.get_overHeat()',pro:'int get_overHeat()',cmt:'<p>Rend TRUE si le module est en surchauffe.</p>',ret:'soit <tt>Y_OVERHEAT_FALSE</tt>, soit <tt>Y_OVERHEAT_TRUE</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_OVERHEAT_INVALID</tt>.'};
doc['VSource']['get_overLoad']={syn:'Rend TRUE si le module n\x27est pas capable de tenir la tension de sortie demand\xE9e.',lib:'vsource.get_overLoad()',pro:'int get_overLoad()',cmt:'<p>Rend TRUE si le module n\x27est pas capable de tenir la tension de sortie demand\xE9e.</p>',ret:'soit <tt>Y_OVERLOAD_FALSE</tt>, soit <tt>Y_OVERLOAD_TRUE</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_OVERLOAD_INVALID</tt>.'};
doc['VSource']['get_regulationFailure']={syn:'Rend TRUE si le voltage de sortie de trop \xE9lev\xE9 par report \xE0 la tension demand\xE9e demand\xE9e.',lib:'vsource.get_regulationFailure()',pro:'int get_regulationFailure()',cmt:'<p>Rend TRUE si le voltage de sortie de trop \xE9lev\xE9 par report \xE0 la tension demand\xE9e demand\xE9e.</p>',ret:'soit <tt>Y_REGULATIONFAILURE_FALSE</tt>, soit <tt>Y_REGULATIONFAILURE_TRUE</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_REGULATIONFAILURE_INVALID</tt>.'};
doc['VSource']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la tension est exprim\xE9e.',lib:'vsource.get_unit()',pro:'String get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la tension est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la tension est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['VSource']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'vsource.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['VSource']['get_voltage']={syn:'Retourne la valeur de la commande de tension de sortie en mV ',lib:'vsource.get_voltage()',pro:'int get_voltage()',cmt:'<p>Retourne la valeur de la commande de tension de sortie en mV</p>',ret:'un entier repr\xE9sentant la valeur de la commande de tension de sortie en mV',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_VOLTAGE_INVALID</tt>.'};
doc['VSource']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'vsource.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['VSource']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'vsource.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['VSource']['nextVSource']={syn:'Continue l\x27\xE9num\xE9ration des sources de tension commenc\xE9e \xE0 l\x27aide de <tt>yFirstVSource()</tt>.',lib:'vsource.nextVSource()',pro:'YVSource nextVSource()',cmt:'<p>Continue l\x27\xE9num\xE9ration des sources de tension commenc\xE9e \xE0 l\x27aide de <tt>yFirstVSource()</tt>.</p>',ret:'un pointeur sur un objet <tt>YVSource</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['VSource']['pulse']={syn:'Active la sortie \xE0 une tension donn\xE9e, et pour dur\xE9e sp\xE9cifi\xE9e, puis revient ensuite spontan\xE9ment \xE0 z\xE9ro volt.',lib:'vsource.pulse()',pro:'int pulse(int <span id=pn>voltage</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Active la sortie \xE0 une tension donn\xE9e, et pour dur\xE9e sp\xE9cifi\xE9e, puis revient ensuite spontan\xE9ment \xE0 z\xE9ro volt.</p>',par:{voltage:'tension demand\xE9e, en millivolts',ms_duration:'dur\xE9e de l\x27impulsion, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['VSource']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'vsource.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['VSource']['set_logicalName']={syn:'Modifie le nom logique de la source de tension.',lib:'vsource.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de la source de tension. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la source de tension'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['VSource']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'vsource.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['VSource']['set_voltage']={syn:'R\xE8gle la tension de sortie du module (en milliVolts).',lib:'vsource.set_voltage()',pro:'int set_voltage(int <span id=pn>newval</span>)',cmt:'<p>R\xE8gle la tension de sortie du module (en milliVolts).</p>',par:{newval:'un entier'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['VSource']['voltageMove']={syn:'D\xE9clenche une variation constante de la sortie vers une valeur donn\xE9e.',lib:'vsource.voltageMove()',pro:'int voltageMove(int <span id=pn>target</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>D\xE9clenche une variation constante de la sortie vers une valeur donn\xE9e. </p>',par:{target:'nouvelle valeur de sortie \xE0 la fin de la transition, en milliVolts.',ms_duration:'dur\xE9e de la transition, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: VSource)
//--- (generated code: Current)
doc['Current']={'':{syn:'Interface de la fonction Current',inc:'import com.yoctopuce.YoctoAPI.YCurrent;',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
doc['Current']['FindCurrent']={syn:'Permet de retrouver un capteur de courant d\x27apr\xE8s un identifiant donn\xE9.',lib:'YCurrent.FindCurrent()',pro:'YCurrent FindCurrent(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de courant d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le capteur de courant soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YCurrent.isOnline()</tt> pour tester si le capteur de courant est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de courant sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YCurrent</tt> qui permet ensuite de contr\xF4ler le capteur de courant.'};
doc['Current']['FirstCurrent']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de courant accessibles par la librairie.',lib:'YCurrent.FirstCurrent()',pro:'YCurrent FirstCurrent()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de courant accessibles par la librairie. Utiliser la fonction <tt>YCurrent.nextCurrent()</tt> pour it\xE9rer sur les autres capteurs de courant.</p>',ret:'un pointeur sur un objet <tt>YCurrent</tt>, correspondant \xE0 le premier capteur de courant accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de courant disponibles.'};
doc['Current']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'current.calibrateFromPoints()',pro:'int calibrateFromPoints(ArrayList&lt;Double&gt; <span id=pn>rawValues</span>,&nbsp;ArrayList&lt;Double&gt; <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. </p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Current']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'current.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Current']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de courant (pas plus de 6 caract\xE8res).',lib:'current.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de courant (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de courant (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Current']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'current.get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Current']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'current.get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Current']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'current.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Current']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'current.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Current']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'current.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Current']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'current.get_currentDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Current']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'current.get_currentId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Current']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'current.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Current']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e.',lib:'current.get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur maximale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Current']['get_logicalName']={syn:'Retourne le nom logique du capteur de courant.',lib:'current.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de courant.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de courant',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Current']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e.',lib:'current.get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur minimale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Current']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'current.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Current']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'current.get_resolution()',pro:'double get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Current']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'current.get_unit()',pro:'String get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Current']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'current.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Current']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'current.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Current']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'current.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Current']['nextCurrent']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de courant commenc\xE9e \xE0 l\x27aide de <tt>yFirstCurrent()</tt>.',lib:'current.nextCurrent()',pro:'YCurrent nextCurrent()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de courant commenc\xE9e \xE0 l\x27aide de <tt>yFirstCurrent()</tt>.</p>',ret:'un pointeur sur un objet <tt>YCurrent</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Current']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'current.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Current']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'current.set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Current']['set_logicalName']={syn:'Modifie le nom logique du capteur de courant.',lib:'current.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de courant. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de courant'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Current']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'current.set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Current']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'current.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Current)
//--- (generated code: DualPower)
doc['DualPower']={'':{syn:'Interface de contr\xF4le de l\x27alimentation',inc:'import com.yoctopuce.YoctoAPI.YDualPower;',cmt:'<p>La librairie de programmation Yoctopuce permet de contr\xF4ler la source d\x27alimentation qui doit \xEAtre utilis\xE9e pour les fonctions du module consommant beaucoup de courant. Le module est par ailleurs capable de couper automatiquement l\x27alimentation externe lorsqu\x27il d\xE9tecte que la tension a trop chut\xE9 (batterie \xE9puis\xE9e).</p>'}};
doc['DualPower']['FindDualPower']={syn:'Permet de retrouver un contr\xF4le d\x27alimentation d\x27apr\xE8s un identifiant donn\xE9.',lib:'YDualPower.FindDualPower()',pro:'YDualPower FindDualPower(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver un contr\xF4le d\x27alimentation d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le contr\xF4le d\x27alimentation soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YDualPower.isOnline()</tt> pour tester si le contr\xF4le d\x27alimentation est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le contr\xF4le d\x27alimentation sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YDualPower</tt> qui permet ensuite de contr\xF4ler le contr\xF4le d\x27alimentation.'};
doc['DualPower']['FirstDualPower']={syn:'Commence l\x27\xE9num\xE9ration des contr\xF4les d\x27alimentation accessibles par la librairie.',lib:'YDualPower.FirstDualPower()',pro:'YDualPower FirstDualPower()',cmt:'<p>Commence l\x27\xE9num\xE9ration des contr\xF4les d\x27alimentation accessibles par la librairie. Utiliser la fonction <tt>YDualPower.nextDualPower()</tt> pour it\xE9rer sur les autres contr\xF4les d\x27alimentation.</p>',ret:'un pointeur sur un objet <tt>YDualPower</tt>, correspondant \xE0 le premier contr\xF4le d\x27alimentation accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de contr\xF4les d\x27alimentation disponibles.'};
doc['DualPower']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'dualpower.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['DualPower']['get_advertisedValue']={syn:'Retourne la valeur courante du contr\xF4le d\x27alimentation (pas plus de 6 caract\xE8res).',lib:'dualpower.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante du contr\xF4le d\x27alimentation (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du contr\xF4le d\x27alimentation (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['DualPower']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'dualpower.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['DualPower']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'dualpower.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['DualPower']['get_extVoltage']={syn:'Retourne la tension mesur\xE9e sur l\x27alimentation de puissance externe, en millivolts.',lib:'dualpower.get_extVoltage()',pro:'int get_extVoltage()',cmt:'<p>Retourne la tension mesur\xE9e sur l\x27alimentation de puissance externe, en millivolts.</p>',ret:'un entier repr\xE9sentant la tension mesur\xE9e sur l\x27alimentation de puissance externe, en millivolts',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_EXTVOLTAGE_INVALID</tt>.'};
doc['DualPower']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'dualpower.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['DualPower']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'dualpower.get_dualpowerDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['DualPower']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'dualpower.get_dualpowerId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['DualPower']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'dualpower.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['DualPower']['get_logicalName']={syn:'Retourne le nom logique du contr\xF4le d\x27alimentation.',lib:'dualpower.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique du contr\xF4le d\x27alimentation.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du contr\xF4le d\x27alimentation',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['DualPower']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'dualpower.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['DualPower']['get_powerControl']={syn:'Retourne le mode d\x27alimentation choisi pour les fonctions du module consommant beaucoup de courant.',lib:'dualpower.get_powerControl()',pro:'int get_powerControl()',cmt:'<p>Retourne le mode d\x27alimentation choisi pour les fonctions du module consommant beaucoup de courant.</p>',ret:'une valeur parmi <tt>Y_POWERCONTROL_AUTO</tt>, <tt>Y_POWERCONTROL_FROM_USB</tt>, <tt>Y_POWERCONTROL_FROM_EXT</tt> et <tt>Y_POWERCONTROL_OFF</tt> repr\xE9sentant le mode d\x27alimentation choisi pour les fonctions du module consommant beaucoup de courant',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_POWERCONTROL_INVALID</tt>.'};
doc['DualPower']['get_powerState']={syn:'Retourne la source d\x27alimentation active pour les fonctions du module consommant beaucoup de courant.',lib:'dualpower.get_powerState()',pro:'int get_powerState()',cmt:'<p>Retourne la source d\x27alimentation active pour les fonctions du module consommant beaucoup de courant.</p>',ret:'une valeur parmi <tt>Y_POWERSTATE_OFF</tt>, <tt>Y_POWERSTATE_FROM_USB</tt> et <tt>Y_POWERSTATE_FROM_EXT</tt> repr\xE9sentant la source d\x27alimentation active pour les fonctions du module consommant beaucoup de courant',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_POWERSTATE_INVALID</tt>.'};
doc['DualPower']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'dualpower.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['DualPower']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'dualpower.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['DualPower']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'dualpower.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DualPower']['nextDualPower']={syn:'Continue l\x27\xE9num\xE9ration des contr\xF4les d\x27alimentation commenc\xE9e \xE0 l\x27aide de <tt>yFirstDualPower()</tt>.',lib:'dualpower.nextDualPower()',pro:'YDualPower nextDualPower()',cmt:'<p>Continue l\x27\xE9num\xE9ration des contr\xF4les d\x27alimentation commenc\xE9e \xE0 l\x27aide de <tt>yFirstDualPower()</tt>.</p>',ret:'un pointeur sur un objet <tt>YDualPower</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['DualPower']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'dualpower.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['DualPower']['set_logicalName']={syn:'Modifie le nom logique du contr\xF4le d\x27alimentation.',lib:'dualpower.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du contr\xF4le d\x27alimentation. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du contr\xF4le d\x27alimentation'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DualPower']['set_powerControl']={syn:'Modifie le mode d\x27alimentation choisi pour les fonctions du module consommant beaucoup de courant.',lib:'dualpower.set_powerControl()',pro:'int set_powerControl(int <span id=pn>newval</span>)',cmt:'<p>Modifie le mode d\x27alimentation choisi pour les fonctions du module consommant beaucoup de courant.</p>',par:{newval:'une valeur parmi <tt>Y_POWERCONTROL_AUTO</tt>, <tt>Y_POWERCONTROL_FROM_USB</tt>, <tt>Y_POWERCONTROL_FROM_EXT</tt> et <tt>Y_POWERCONTROL_OFF</tt> repr\xE9sentant le mode d\x27alimentation choisi pour les fonctions du module consommant beaucoup de courant'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DualPower']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'dualpower.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: DualPower)
//--- (generated code: Servo)
doc['Servo']={'':{syn:'Interface de la fonction Servo',inc:'import com.yoctopuce.YoctoAPI.YServo;',cmt:'<p>La librairie de programmation Yoctopuce permet non seulement de d\xE9placer le servo vers une position donn\xE9e, mais aussi de sp\xE9cifier l\x27interval de temps dans lequel le mouvement doit \xEAtre fait, de sorte \xE0 pouvoir synchroniser un mouvement sur plusieurs servos.</p>'}};
doc['Servo']['FindServo']={syn:'Permet de retrouver un servo d\x27apr\xE8s un identifiant donn\xE9.',lib:'YServo.FindServo()',pro:'YServo FindServo(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver un servo d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le servo soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YServo.isOnline()</tt> pour tester si le servo est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le servo sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YServo</tt> qui permet ensuite de contr\xF4ler le servo.'};
doc['Servo']['FirstServo']={syn:'Commence l\x27\xE9num\xE9ration des servo accessibles par la librairie.',lib:'YServo.FirstServo()',pro:'YServo FirstServo()',cmt:'<p>Commence l\x27\xE9num\xE9ration des servo accessibles par la librairie. Utiliser la fonction <tt>YServo.nextServo()</tt> pour it\xE9rer sur les autres servo.</p>',ret:'un pointeur sur un objet <tt>YServo</tt>, correspondant \xE0 le premier servo accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de servo disponibles.'};
doc['Servo']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'servo.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Servo']['get_advertisedValue']={syn:'Retourne la valeur courante du servo (pas plus de 6 caract\xE8res).',lib:'servo.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante du servo (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du servo (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Servo']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'servo.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Servo']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'servo.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Servo']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'servo.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Servo']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'servo.get_servoDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Servo']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'servo.get_servoId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Servo']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'servo.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Servo']['get_logicalName']={syn:'Retourne le nom logique du servo.',lib:'servo.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique du servo.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du servo',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Servo']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'servo.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Servo']['get_neutral']={syn:'Retourne la dur\xE9e en microsecondes de l\x27impulsion correspondant au neutre du servo.',lib:'servo.get_neutral()',pro:'int get_neutral()',cmt:'<p>Retourne la dur\xE9e en microsecondes de l\x27impulsion correspondant au neutre du servo.</p>',ret:'un entier repr\xE9sentant la dur\xE9e en microsecondes de l\x27impulsion correspondant au neutre du servo',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_NEUTRAL_INVALID</tt>.'};
doc['Servo']['get_position']={syn:'Retourne la position courante du servo.',lib:'servo.get_position()',pro:'int get_position()',cmt:'<p>Retourne la position courante du servo.</p>',ret:'un entier repr\xE9sentant la position courante du servo',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_POSITION_INVALID</tt>.'};
doc['Servo']['get_range']={syn:'Retourne la plage d\x27utilisation du servo.',lib:'servo.get_range()',pro:'int get_range()',cmt:'<p>Retourne la plage d\x27utilisation du servo.</p>',ret:'un entier repr\xE9sentant la plage d\x27utilisation du servo',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RANGE_INVALID</tt>.'};
doc['Servo']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'servo.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Servo']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'servo.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Servo']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'servo.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Servo']['move']={syn:'D\xE9clenche un mouvement \xE0 vitesse constante vers une position donn\xE9e.',lib:'servo.move()',pro:'int move(int <span id=pn>target</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>D\xE9clenche un mouvement \xE0 vitesse constante vers une position donn\xE9e.</p>',par:{target:'nouvelle position \xE0 la fin du mouvement',ms_duration:'dur\xE9e totale du mouvement, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Servo']['nextServo']={syn:'Continue l\x27\xE9num\xE9ration des servo commenc\xE9e \xE0 l\x27aide de <tt>yFirstServo()</tt>.',lib:'servo.nextServo()',pro:'YServo nextServo()',cmt:'<p>Continue l\x27\xE9num\xE9ration des servo commenc\xE9e \xE0 l\x27aide de <tt>yFirstServo()</tt>.</p>',ret:'un pointeur sur un objet <tt>YServo</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Servo']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'servo.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Servo']['set_logicalName']={syn:'Modifie le nom logique du servo.',lib:'servo.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du servo. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du servo'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Servo']['set_neutral']={syn:'Modifie la dur\xE9e de l\x27impulsion correspondant \xE0 la position neutre du servo.',lib:'servo.set_neutral()',pro:'int set_neutral(int <span id=pn>newval</span>)',cmt:'<p>Modifie la dur\xE9e de l\x27impulsion correspondant \xE0 la position neutre du servo. La dur\xE9e est sp\xE9cifi\xE9e en microsecondes, et la valeur standard est 1500 [us]. Ce r\xE9glage permet de d\xE9caler la plage d\x27utilisation du servo. Attention, l\x27utilisation d\x27une plage sup\xE9rieure aux caract\xE9ristiques du servo risque fortement d\x27endommager le servo.</p>',par:{newval:'un entier repr\xE9sentant la dur\xE9e de l\x27impulsion correspondant \xE0 la position neutre du servo'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Servo']['set_position']={syn:'Modifie imm\xE9diatement la consigne de position du servo.',lib:'servo.set_position()',pro:'int set_position(int <span id=pn>newval</span>)',cmt:'<p>Modifie imm\xE9diatement la consigne de position du servo.</p>',par:{newval:'un entier repr\xE9sentant imm\xE9diatement la consigne de position du servo'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Servo']['set_range']={syn:'Modifie la plage d\x27utilisation du servo, en pourcents.',lib:'servo.set_range()',pro:'int set_range(int <span id=pn>newval</span>)',cmt:'<p>Modifie la plage d\x27utilisation du servo, en pourcents. La valeur 100% correspond \xE0 un signal de commande standard, variant de 1 [ms] \xE0 2 [ms]. Pour les servos supportent une plage double, de 0.5 [ms] \xE0 2.5 [ms], vous pouvez utiliser une valeur allant jusqu\x27\xE0 200%. Attention, l\x27utilisation d\x27une plage sup\xE9rieure aux caract\xE9ristiques du servo risque fortement d\x27endommager le servo.</p>',par:{newval:'un entier repr\xE9sentant la plage d\x27utilisation du servo, en pourcents'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Servo']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'servo.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Servo)
//--- (generated code: Relay)
doc['Relay']={'':{syn:'Interface de la fonction Relay',inc:'import com.yoctopuce.YoctoAPI.YRelay;',cmt:'<p>La librairie de programmation Yoctopuce permet simplement de changer l\x27\xE9tat du relais. Le changement d\x27\xE9tat n\x27est pas persistant: le relais retournera spontan\xE9ment \xE0 sa position de repos d\xE8s que le module est mis hors tension ou red\xE9marr\xE9. La librairie permet aussi de cr\xE9er des courtes impulsions de dur\xE9e d\xE9termin\xE9e. Pour les modules dot\xE9s de deux sorties par relais (relai inverseur), les deux sorties sont appel\xE9es A et B, la sortie A correspondant a la position de repos (hors tension) et la sortie B correspondant \xE0 l\x27\xE9tat actif. Si vous pr\xE9f\xE9reriez l\x27\xE9tat par d\xE9faut oppos\xE9, vous pouvez simplement changer vos fils sur le bornier.</p>'}};
doc['Relay']['FindRelay']={syn:'Permet de retrouver un relais d\x27apr\xE8s un identifiant donn\xE9.',lib:'YRelay.FindRelay()',pro:'YRelay FindRelay(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver un relais d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le relais soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YRelay.isOnline()</tt> pour tester si le relais est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le relais sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YRelay</tt> qui permet ensuite de contr\xF4ler le relais.'};
doc['Relay']['FirstRelay']={syn:'Commence l\x27\xE9num\xE9ration des relais accessibles par la librairie.',lib:'YRelay.FirstRelay()',pro:'YRelay FirstRelay()',cmt:'<p>Commence l\x27\xE9num\xE9ration des relais accessibles par la librairie. Utiliser la fonction <tt>YRelay.nextRelay()</tt> pour it\xE9rer sur les autres relais.</p>',ret:'un pointeur sur un objet <tt>YRelay</tt>, correspondant \xE0 le premier relais accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de relais disponibles.'};
doc['Relay']['delayedPulse']={syn:'Pr\xE9-programme une impulsion ',lib:'relay.delayedPulse()',pro:'int delayedPulse(int <span id=pn>ms_delay</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Pr\xE9-programme une impulsion</p>',par:{ms_delay:'delai d\x27attente avant l\x27implusion, en millisecondes',ms_duration:'dur\xE9e de l\x27impulsion, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Relay']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'relay.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Relay']['get_advertisedValue']={syn:'Retourne la valeur courante du relais (pas plus de 6 caract\xE8res).',lib:'relay.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante du relais (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du relais (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Relay']['get_countdown']={syn:'Retourne le nombre de millisecondes restantes avant le d\xE9clenchement d\x27une impulsion pr\xE9programm\xE9e par un appel \xE0 delayedPulse().',lib:'relay.get_countdown()',pro:'long get_countdown()',cmt:'<p>Retourne le nombre de millisecondes restantes avant le d\xE9clenchement d\x27une impulsion pr\xE9programm\xE9e par un appel \xE0 delayedPulse(). Si aucune impulsion n\x27est programm\xE9e, retourne z\xE9ro.</p>',ret:'un entier repr\xE9sentant le nombre de millisecondes restantes avant le d\xE9clenchement d\x27une impulsion pr\xE9programm\xE9e par un appel \xE0 delayedPulse()',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_COUNTDOWN_INVALID</tt>.'};
doc['Relay']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'relay.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Relay']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'relay.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Relay']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'relay.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Relay']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'relay.get_relayDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Relay']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'relay.get_relayId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Relay']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'relay.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Relay']['get_logicalName']={syn:'Retourne le nom logique du relais.',lib:'relay.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique du relais.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du relais',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Relay']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'relay.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Relay']['get_output']={syn:'Retourne l\x27\xE9tat de la sortie du relais, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.',lib:'relay.get_output()',pro:'int get_output()',cmt:'<p>Retourne l\x27\xE9tat de la sortie du relais, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.</p>',ret:'soit <tt>Y_OUTPUT_OFF</tt>, soit <tt>Y_OUTPUT_ON</tt>, selon l\x27\xE9tat de la sortie du relais, lorsqu\x27il est utilis\xE9 comme un simple interrupteur',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_OUTPUT_INVALID</tt>.'};
doc['Relay']['get_pulseTimer']={syn:'Retourne le nombre de millisecondes restantes avant le retour \xE0 la position de repos (\xE9tat A), durant la g\xE9n\xE9ration d\x27une impulsion mesur\xE9e.',lib:'relay.get_pulseTimer()',pro:'long get_pulseTimer()',cmt:'<p>Retourne le nombre de millisecondes restantes avant le retour \xE0 la position de repos (\xE9tat A), durant la g\xE9n\xE9ration d\x27une impulsion mesur\xE9e. Si aucune impulsion n\x27est en cours, retourne z\xE9ro.</p>',ret:'un entier repr\xE9sentant le nombre de millisecondes restantes avant le retour \xE0 la position de repos (\xE9tat A), durant la g\xE9n\xE9ration d\x27une impulsion mesur\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['Relay']['get_state']={syn:'Retourne l\x27\xE9tat du relais (A pour la position de repos, B pour l\x27\xE9tat actif).',lib:'relay.get_state()',pro:'int get_state()',cmt:'<p>Retourne l\x27\xE9tat du relais (A pour la position de repos, B pour l\x27\xE9tat actif).</p>',ret:'soit <tt>Y_STATE_A</tt>, soit <tt>Y_STATE_B</tt>, selon l\x27\xE9tat du relais (A pour la position de repos, B pour l\x27\xE9tat actif)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_STATE_INVALID</tt>.'};
doc['Relay']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'relay.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Relay']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'relay.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Relay']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'relay.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Relay']['nextRelay']={syn:'Continue l\x27\xE9num\xE9ration des relais commenc\xE9e \xE0 l\x27aide de <tt>yFirstRelay()</tt>.',lib:'relay.nextRelay()',pro:'YRelay nextRelay()',cmt:'<p>Continue l\x27\xE9num\xE9ration des relais commenc\xE9e \xE0 l\x27aide de <tt>yFirstRelay()</tt>.</p>',ret:'un pointeur sur un objet <tt>YRelay</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Relay']['pulse']={syn:'Commute le relais \xE0 l\x27\xE9tat B (actif) pour un dur\xE9e sp\xE9cifi\xE9e, puis revient ensuite spontan\xE9ment vers l\x27\xE9tat A (\xE9tat de repos).',lib:'relay.pulse()',pro:'int pulse(int <span id=pn>ms_duration</span>)',cmt:'<p>Commute le relais \xE0 l\x27\xE9tat B (actif) pour un dur\xE9e sp\xE9cifi\xE9e, puis revient ensuite spontan\xE9ment vers l\x27\xE9tat A (\xE9tat de repos).</p>',par:{ms_duration:'dur\xE9e de l\x27impulsion, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Relay']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'relay.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Relay']['set_logicalName']={syn:'Modifie le nom logique du relais.',lib:'relay.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du relais. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du relais'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Relay']['set_output']={syn:'Modifie l\x27\xE9tat de la sortie du relais, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.',lib:'relay.set_output()',pro:'int set_output(int <span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat de la sortie du relais, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.</p>',par:{newval:'soit <tt>Y_OUTPUT_OFF</tt>, soit <tt>Y_OUTPUT_ON</tt>, selon l\x27\xE9tat de la sortie du relais, lorsqu\x27il est utilis\xE9 comme un simple interrupteur'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Relay']['set_state']={syn:'Modifie l\x27\xE9tat du relais (A pour la position de repos, B pour l\x27\xE9tat actif).',lib:'relay.set_state()',pro:'int set_state(int <span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat du relais (A pour la position de repos, B pour l\x27\xE9tat actif).</p>',par:{newval:'soit <tt>Y_STATE_A</tt>, soit <tt>Y_STATE_B</tt>, selon l\x27\xE9tat du relais (A pour la position de repos, B pour l\x27\xE9tat actif)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Relay']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'relay.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Relay)
//--- (generated code: Pressure)
doc['Pressure']={'':{syn:'Interface de la fonction Pressure',inc:'import com.yoctopuce.YoctoAPI.YPressure;',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
doc['Pressure']['FindPressure']={syn:'Permet de retrouver un capteur de pression d\x27apr\xE8s un identifiant donn\xE9.',lib:'YPressure.FindPressure()',pro:'YPressure FindPressure(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de pression d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le capteur de pression soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YPressure.isOnline()</tt> pour tester si le capteur de pression est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de pression sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YPressure</tt> qui permet ensuite de contr\xF4ler le capteur de pression.'};
doc['Pressure']['FirstPressure']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de pression accessibles par la librairie.',lib:'YPressure.FirstPressure()',pro:'YPressure FirstPressure()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de pression accessibles par la librairie. Utiliser la fonction <tt>YPressure.nextPressure()</tt> pour it\xE9rer sur les autres capteurs de pression.</p>',ret:'un pointeur sur un objet <tt>YPressure</tt>, correspondant \xE0 le premier capteur de pression accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de pression disponibles.'};
doc['Pressure']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'pressure.calibrateFromPoints()',pro:'int calibrateFromPoints(ArrayList&lt;Double&gt; <span id=pn>rawValues</span>,&nbsp;ArrayList&lt;Double&gt; <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. </p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Pressure']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'pressure.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Pressure']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de pression (pas plus de 6 caract\xE8res).',lib:'pressure.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de pression (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de pression (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Pressure']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'pressure.get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Pressure']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'pressure.get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Pressure']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'pressure.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Pressure']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'pressure.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Pressure']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'pressure.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Pressure']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'pressure.get_pressureDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Pressure']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'pressure.get_pressureId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Pressure']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'pressure.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Pressure']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e.',lib:'pressure.get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur maximale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Pressure']['get_logicalName']={syn:'Retourne le nom logique du capteur de pression.',lib:'pressure.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de pression.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de pression',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Pressure']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e.',lib:'pressure.get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur minimale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Pressure']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'pressure.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Pressure']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'pressure.get_resolution()',pro:'double get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Pressure']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'pressure.get_unit()',pro:'String get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Pressure']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'pressure.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Pressure']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'pressure.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Pressure']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'pressure.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Pressure']['nextPressure']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de pression commenc\xE9e \xE0 l\x27aide de <tt>yFirstPressure()</tt>.',lib:'pressure.nextPressure()',pro:'YPressure nextPressure()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de pression commenc\xE9e \xE0 l\x27aide de <tt>yFirstPressure()</tt>.</p>',ret:'un pointeur sur un objet <tt>YPressure</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Pressure']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'pressure.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Pressure']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'pressure.set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Pressure']['set_logicalName']={syn:'Modifie le nom logique du capteur de pression.',lib:'pressure.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de pression. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de pression'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Pressure']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'pressure.set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Pressure']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'pressure.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Pressure)
//--- (generated code: ColorLed)
doc['ColorLed']={'':{syn:'Interface de la fonction ColorLed',inc:'import com.yoctopuce.YoctoAPI.YColorLed;',cmt:'<p>La librairie de programmation Yoctopuce permet de piloter une led couleur aussi bien en coordonn\xE9es RGB qu\x27en coordonn\xE9es HSL, les conversions RGB vers HSL \xE9tant faites automatiquement par le module. Ceci permet ais\xE9ment d\x27allumer la led avec une certaine teinte et d\x27en faire progressivement varier la saturation ou la luminosit\xE9. Si n\xE9cessaire, vous trouverez plus d\x27information sur la diff\xE9rence entre RGB et HSL dans la section suivante.</p>'}};
doc['ColorLed']['FindColorLed']={syn:'Permet de retrouver une led RGB d\x27apr\xE8s un identifiant donn\xE9.',lib:'YColorLed.FindColorLed()',pro:'YColorLed FindColorLed(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver une led RGB d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que la led RGB soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YColorLed.isOnline()</tt> pour tester si la led RGB est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence la led RGB sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YColorLed</tt> qui permet ensuite de contr\xF4ler la led RGB.'};
doc['ColorLed']['FirstColorLed']={syn:'Commence l\x27\xE9num\xE9ration des leds RGB accessibles par la librairie.',lib:'YColorLed.FirstColorLed()',pro:'YColorLed FirstColorLed()',cmt:'<p>Commence l\x27\xE9num\xE9ration des leds RGB accessibles par la librairie. Utiliser la fonction <tt>YColorLed.nextColorLed()</tt> pour it\xE9rer sur les autres leds RGB.</p>',ret:'un pointeur sur un objet <tt>YColorLed</tt>, correspondant \xE0 la premi\xE8re led RGB accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de leds RGB disponibles.'};
doc['ColorLed']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'colorled.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['ColorLed']['get_advertisedValue']={syn:'Retourne la valeur courante de la led RGB (pas plus de 6 caract\xE8res).',lib:'colorled.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante de la led RGB (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de la led RGB (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['ColorLed']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'colorled.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['ColorLed']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'colorled.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['ColorLed']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'colorled.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['ColorLed']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'colorled.get_colorledDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['ColorLed']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'colorled.get_colorledId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['ColorLed']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'colorled.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['ColorLed']['get_hslColor']={syn:'Retourne la couleur HSL courante de la led.',lib:'colorled.get_hslColor()',pro:'long get_hslColor()',cmt:'<p>Retourne la couleur HSL courante de la led.</p>',ret:'un entier repr\xE9sentant la couleur HSL courante de la led',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HSLCOLOR_INVALID</tt>.'};
doc['ColorLed']['get_logicalName']={syn:'Retourne le nom logique de la led RGB.',lib:'colorled.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique de la led RGB.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la led RGB',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['ColorLed']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'colorled.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['ColorLed']['get_rgbColor']={syn:'Retourne la couleur RGB courante de la led.',lib:'colorled.get_rgbColor()',pro:'long get_rgbColor()',cmt:'<p>Retourne la couleur RGB courante de la led.</p>',ret:'un entier repr\xE9sentant la couleur RGB courante de la led',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RGBCOLOR_INVALID</tt>.'};
doc['ColorLed']['get_rgbColorAtPowerOn']={syn:'Retourne la couleur configur\xE9e pour \xEAtre affichage \xE0 l\x27allumage du module.',lib:'colorled.get_rgbColorAtPowerOn()',pro:'long get_rgbColorAtPowerOn()',cmt:'<p>Retourne la couleur configur\xE9e pour \xEAtre affichage \xE0 l\x27allumage du module.</p>',ret:'un entier repr\xE9sentant la couleur configur\xE9e pour \xEAtre affichage \xE0 l\x27allumage du module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RGBCOLORATPOWERON_INVALID</tt>.'};
doc['ColorLed']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'colorled.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['ColorLed']['hslMove']={syn:'Effectue une transition continue dans l\x27espace HSL entre la couleur courante et une nouvelle couleur.',lib:'colorled.hslMove()',pro:'int hslMove(int <span id=pn>hsl_target</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Effectue une transition continue dans l\x27espace HSL entre la couleur courante et une nouvelle couleur.</p>',par:{hsl_target:'couleur HSL d\xE9sir\xE9e \xE0 la fin de la transition',ms_duration:'dur\xE9e de la transition, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'colorled.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['ColorLed']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'colorled.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['nextColorLed']={syn:'Continue l\x27\xE9num\xE9ration des leds RGB commenc\xE9e \xE0 l\x27aide de <tt>yFirstColorLed()</tt>.',lib:'colorled.nextColorLed()',pro:'YColorLed nextColorLed()',cmt:'<p>Continue l\x27\xE9num\xE9ration des leds RGB commenc\xE9e \xE0 l\x27aide de <tt>yFirstColorLed()</tt>.</p>',ret:'un pointeur sur un objet <tt>YColorLed</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['ColorLed']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'colorled.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['ColorLed']['rgbMove']={syn:'Effectue une transition continue dans l\x27espace RGB entre la couleur courante et une nouvelle couleur.',lib:'colorled.rgbMove()',pro:'int rgbMove(int <span id=pn>rgb_target</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Effectue une transition continue dans l\x27espace RGB entre la couleur courante et une nouvelle couleur.</p>',par:{rgb_target:'couleur RGB d\xE9sir\xE9e \xE0 la fin de la transition',ms_duration:'dur\xE9e de la transition, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['set_hslColor']={syn:'Modifie la couleur courante de la led, en utilisant une couleur HSL sp\xE9cifi\xE9e.',lib:'colorled.set_hslColor()',pro:'int set_hslColor(long <span id=pn>newval</span>)',cmt:'<p>Modifie la couleur courante de la led, en utilisant une couleur HSL sp\xE9cifi\xE9e. L\x27encodage est r\xE9alis\xE9 de la mani\xE8re suivante: 0xHHSSLL.</p>',par:{newval:'un entier repr\xE9sentant la couleur courante de la led, en utilisant une couleur HSL sp\xE9cifi\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['set_logicalName']={syn:'Modifie le nom logique de la led RGB.',lib:'colorled.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de la led RGB. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la led RGB'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['set_rgbColor']={syn:'Modifie la couleur courante de la led, en utilisant une couleur RGB (Rouge Vert Bleu).',lib:'colorled.set_rgbColor()',pro:'int set_rgbColor(long <span id=pn>newval</span>)',cmt:'<p>Modifie la couleur courante de la led, en utilisant une couleur RGB (Rouge Vert Bleu). L\x27encodage est r\xE9alis\xE9 de la mani\xE8re suivante: 0xRRGGBB.</p>',par:{newval:'un entier repr\xE9sentant la couleur courante de la led, en utilisant une couleur RGB (Rouge Vert Bleu)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['set_rgbColorAtPowerOn']={syn:'Modifie la couleur que la led va afficher spontan\xE9ment \xE0 l\x27allumage du module.',lib:'colorled.set_rgbColorAtPowerOn()',pro:'int set_rgbColorAtPowerOn(long <span id=pn>newval</span>)',cmt:'<p>Modifie la couleur que la led va afficher spontan\xE9ment \xE0 l\x27allumage du module. Cette couleur sera affich\xE9e des que le module sera sous tension. Ne pas oublier d\x27appeler la fonction <tt>saveToFlash()</tt> du module correspondant pour que ce param\xE8tre soit m\xE9moris\xE9.</p>',par:{newval:'un entier repr\xE9sentant la couleur que la led va afficher spontan\xE9ment \xE0 l\x27allumage du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['ColorLed']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'colorled.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: ColorLed)
//--- (generated code: HubPort)
doc['HubPort']={'':{syn:'Interface d\x27un port de Yocto-hub',inc:'import com.yoctopuce.YoctoAPI.YHubPort;'}};
doc['HubPort']['FindHubPort']={syn:'Permet de retrouver un port de Yocto-hub d\x27apr\xE8s un identifiant donn\xE9.',lib:'YHubPort.FindHubPort()',pro:'YHubPort FindHubPort(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver un port de Yocto-hub d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le port de Yocto-hub soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YHubPort.isOnline()</tt> pour tester si le port de Yocto-hub est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le port de Yocto-hub sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YHubPort</tt> qui permet ensuite de contr\xF4ler le port de Yocto-hub.'};
doc['HubPort']['FirstHubPort']={syn:'Commence l\x27\xE9num\xE9ration des port de Yocto-hub accessibles par la librairie.',lib:'YHubPort.FirstHubPort()',pro:'YHubPort FirstHubPort()',cmt:'<p>Commence l\x27\xE9num\xE9ration des port de Yocto-hub accessibles par la librairie. Utiliser la fonction <tt>YHubPort.nextHubPort()</tt> pour it\xE9rer sur les autres port de Yocto-hub.</p>',ret:'un pointeur sur un objet <tt>YHubPort</tt>, correspondant \xE0 le premier port de Yocto-hub accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de port de Yocto-hub disponibles.'};
doc['HubPort']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'hubport.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['HubPort']['get_advertisedValue']={syn:'Retourne la valeur courante du port de Yocto-hub (pas plus de 6 caract\xE8res).',lib:'hubport.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante du port de Yocto-hub (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du port de Yocto-hub (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['HubPort']['get_baudRate']={syn:'Retourne la vitesse de transfert utilis\xE9e par le port de Yocto-hub, en kbps.',lib:'hubport.get_baudRate()',pro:'int get_baudRate()',cmt:'<p>Retourne la vitesse de transfert utilis\xE9e par le port de Yocto-hub, en kbps. La valeur par d\xE9faut est 1000 kbps, une valeur inf\xE9rieure r\xE9v\xE8le des probl\xE8mes de communication.</p>',ret:'un entier repr\xE9sentant la vitesse de transfert utilis\xE9e par le port de Yocto-hub, en kbps',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_BAUDRATE_INVALID</tt>.'};
doc['HubPort']['get_enabled']={syn:'Retourne vrai si le port du Yocto-hub est aliment\xE9, faux sinon.',lib:'hubport.get_enabled()',pro:'int get_enabled()',cmt:'<p>Retourne vrai si le port du Yocto-hub est aliment\xE9, faux sinon.</p>',ret:'soit <tt>Y_ENABLED_FALSE</tt>, soit <tt>Y_ENABLED_TRUE</tt>, selon vrai si le port du Yocto-hub est aliment\xE9, faux sinon',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ENABLED_INVALID</tt>.'};
doc['HubPort']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'hubport.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['HubPort']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'hubport.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['HubPort']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'hubport.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['HubPort']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'hubport.get_hubportDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['HubPort']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'hubport.get_hubportId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['HubPort']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'hubport.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['HubPort']['get_logicalName']={syn:'Retourne le nom logique du port de Yocto-hub, qui est toujours le num\xE9ro de s\xE9rie du module qui y est connect\xE9.',lib:'hubport.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique du port de Yocto-hub, qui est toujours le num\xE9ro de s\xE9rie du module qui y est connect\xE9.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du port de Yocto-hub, qui est toujours le num\xE9ro de s\xE9rie du module qui y est connect\xE9',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['HubPort']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'hubport.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['HubPort']['get_portState']={syn:'Retourne l\x27\xE9tat actuel du port de Yocto-hub.',lib:'hubport.get_portState()',pro:'int get_portState()',cmt:'<p>Retourne l\x27\xE9tat actuel du port de Yocto-hub.</p>',ret:'une valeur parmi <tt>Y_PORTSTATE_OFF</tt>, <tt>Y_PORTSTATE_ON</tt> et <tt>Y_PORTSTATE_RUN</tt> repr\xE9sentant l\x27\xE9tat actuel du port de Yocto-hub',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PORTSTATE_INVALID</tt>.'};
doc['HubPort']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'hubport.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['HubPort']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'hubport.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['HubPort']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'hubport.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['HubPort']['nextHubPort']={syn:'Continue l\x27\xE9num\xE9ration des port de Yocto-hub commenc\xE9e \xE0 l\x27aide de <tt>yFirstHubPort()</tt>.',lib:'hubport.nextHubPort()',pro:'YHubPort nextHubPort()',cmt:'<p>Continue l\x27\xE9num\xE9ration des port de Yocto-hub commenc\xE9e \xE0 l\x27aide de <tt>yFirstHubPort()</tt>.</p>',ret:'un pointeur sur un objet <tt>YHubPort</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['HubPort']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'hubport.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['HubPort']['set_enabled']={syn:'Modifie le mode d\x27activation du port du Yocto-hub.',lib:'hubport.set_enabled()',pro:'int set_enabled(int <span id=pn>newval</span>)',cmt:'<p>Modifie le mode d\x27activation du port du Yocto-hub. Si le port est actif, il * sera aliment\xE9. Sinon, l\x27alimentation du module est coup\xE9e.</p>',par:{newval:'soit <tt>Y_ENABLED_FALSE</tt>, soit <tt>Y_ENABLED_TRUE</tt>, selon le mode d\x27activation du port du Yocto-hub'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['HubPort']['set_logicalName']={syn:'Il n\x27est pas possible de configurer le nom logique d\x27un port de Yocto-hub.',lib:'hubport.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Il n\x27est pas possible de configurer le nom logique d\x27un port de Yocto-hub. Son nom est automatiquement configur\xE9 comme le num\xE9ro de s\xE9rie du module qui y est connect\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['HubPort']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'hubport.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: HubPort)
//--- (generated code: AnButton)
doc['AnButton']={'':{syn:'Interface de la fonction AnButton',inc:'import com.yoctopuce.YoctoAPI.YAnButton;',cmt:'<p>La librairie de programmation Yoctopuce permet aussi bien de mesurer l\x27\xE9tat d\x27un simple bouton que de lire un potentiom\xE8tre analogique (r\xE9sistance variable), comme par exmple bouton rotatif continue, une poign\xE9e de commande de gaz ou un joystick. Le module est capable de se calibrer sur les valeurs minimales et maximales du potentiom\xE8tre, et de restituer une valeur calibr\xE9e variant proportionnellement avec la position du potentiom\xE8tre, ind\xE9pendant de sa r\xE9sistance totale.</p>'}};
doc['AnButton']['FindAnButton']={syn:'Permet de retrouver une entr\xE9e analogique d\x27apr\xE8s un identifiant donn\xE9.',lib:'YAnButton.FindAnButton()',pro:'YAnButton FindAnButton(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver une entr\xE9e analogique d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que l\x27entr\xE9e analogique soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YAnButton.isOnline()</tt> pour tester si l\x27entr\xE9e analogique est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27entr\xE9e analogique sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YAnButton</tt> qui permet ensuite de contr\xF4ler l\x27entr\xE9e analogique.'};
doc['AnButton']['FirstAnButton']={syn:'Commence l\x27\xE9num\xE9ration des entr\xE9es analogiques accessibles par la librairie.',lib:'YAnButton.FirstAnButton()',pro:'YAnButton FirstAnButton()',cmt:'<p>Commence l\x27\xE9num\xE9ration des entr\xE9es analogiques accessibles par la librairie. Utiliser la fonction <tt>YAnButton.nextAnButton()</tt> pour it\xE9rer sur les autres entr\xE9es analogiques.</p>',ret:'un pointeur sur un objet <tt>YAnButton</tt>, correspondant \xE0 la premi\xE8re entr\xE9e analogique accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de entr\xE9es analogiques disponibles.'};
doc['AnButton']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'anbutton.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['AnButton']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27entr\xE9e analogique (pas plus de 6 caract\xE8res).',lib:'anbutton.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27entr\xE9e analogique (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27entr\xE9e analogique (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['AnButton']['get_analogCalibration']={syn:'Permet de savoir si une proc\xE9dure de calibration est actuellement en cours.',lib:'anbutton.get_analogCalibration()',pro:'int get_analogCalibration()',cmt:'<p>Permet de savoir si une proc\xE9dure de calibration est actuellement en cours.</p>',ret:'soit <tt>Y_ANALOGCALIBRATION_OFF</tt>, soit <tt>Y_ANALOGCALIBRATION_ON</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ANALOGCALIBRATION_INVALID</tt>.'};
doc['AnButton']['get_calibratedValue']={syn:'Retourne la valeur calibr\xE9e de l\x27entr\xE9e (entre 0 et 1000 inclus).',lib:'anbutton.get_calibratedValue()',pro:'int get_calibratedValue()',cmt:'<p>Retourne la valeur calibr\xE9e de l\x27entr\xE9e (entre 0 et 1000 inclus).</p>',ret:'un entier repr\xE9sentant la valeur calibr\xE9e de l\x27entr\xE9e (entre 0 et 1000 inclus)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CALIBRATEDVALUE_INVALID</tt>.'};
doc['AnButton']['get_calibrationMax']={syn:'Retourne la valeur maximale observ\xE9e durant la calibration (entre 0 et 4095 inclus).',lib:'anbutton.get_calibrationMax()',pro:'int get_calibrationMax()',cmt:'<p>Retourne la valeur maximale observ\xE9e durant la calibration (entre 0 et 4095 inclus).</p>',ret:'un entier repr\xE9sentant la valeur maximale observ\xE9e durant la calibration (entre 0 et 4095 inclus)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CALIBRATIONMAX_INVALID</tt>.'};
doc['AnButton']['get_calibrationMin']={syn:'Retourne la valeur minimale observ\xE9e durant la calibration (entre 0 et 4095 inclus).',lib:'anbutton.get_calibrationMin()',pro:'int get_calibrationMin()',cmt:'<p>Retourne la valeur minimale observ\xE9e durant la calibration (entre 0 et 4095 inclus).</p>',ret:'un entier repr\xE9sentant la valeur minimale observ\xE9e durant la calibration (entre 0 et 4095 inclus)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CALIBRATIONMIN_INVALID</tt>.'};
doc['AnButton']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'anbutton.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['AnButton']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'anbutton.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['AnButton']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'anbutton.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['AnButton']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'anbutton.get_anbuttonDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['AnButton']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'anbutton.get_anbuttonId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['AnButton']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'anbutton.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['AnButton']['get_isPressed']={syn:'Retourne vrai si l\x27entr\xE9e (consid\xE9r\xE9e comme binaire) est active (contact ferm\xE9), et faux sinon.',lib:'anbutton.get_isPressed()',pro:'int get_isPressed()',cmt:'<p>Retourne vrai si l\x27entr\xE9e (consid\xE9r\xE9e comme binaire) est active (contact ferm\xE9), et faux sinon.</p>',ret:'soit <tt>Y_ISPRESSED_FALSE</tt>, soit <tt>Y_ISPRESSED_TRUE</tt>, selon vrai si l\x27entr\xE9e (consid\xE9r\xE9e comme binaire) est active (contact ferm\xE9), et faux sinon',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ISPRESSED_INVALID</tt>.'};
doc['AnButton']['get_lastTimePressed']={syn:'Retourne le temps absolu (nombre de millisecondes) entre la mise sous tension du module et la derni\xE8re pression observ\xE9e du bouton \xE0 l\x27entr\xE9e (transition du contact de ouvert \xE0 ferm\xE9).',lib:'anbutton.get_lastTimePressed()',pro:'long get_lastTimePressed()',cmt:'<p>Retourne le temps absolu (nombre de millisecondes) entre la mise sous tension du module et la derni\xE8re pression observ\xE9e du bouton \xE0 l\x27entr\xE9e (transition du contact de ouvert \xE0 ferm\xE9).</p>',ret:'un entier repr\xE9sentant le temps absolu (nombre de millisecondes) entre la mise sous tension du module et la derni\xE8re pression observ\xE9e du bouton \xE0 l\x27entr\xE9e (transition du contact de ouvert \xE0 ferm\xE9)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LASTTIMEPRESSED_INVALID</tt>.'};
doc['AnButton']['get_lastTimeReleased']={syn:'Retourne le temps absolu (nombre de millisecondes) entre la mise sous tension du module et le dernier rel\xE2chement observ\xE9e du bouton \xE0 l\x27entr\xE9e (transition du contact de ferm\xE9 \xE0 ouvert).',lib:'anbutton.get_lastTimeReleased()',pro:'long get_lastTimeReleased()',cmt:'<p>Retourne le temps absolu (nombre de millisecondes) entre la mise sous tension du module et le dernier rel\xE2chement observ\xE9e du bouton \xE0 l\x27entr\xE9e (transition du contact de ferm\xE9 \xE0 ouvert).</p>',ret:'un entier repr\xE9sentant le temps absolu (nombre de millisecondes) entre la mise sous tension du module et le dernier rel\xE2chement observ\xE9e du bouton \xE0 l\x27entr\xE9e (transition du contact de ferm\xE9 \xE0 ouvert)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LASTTIMERELEASED_INVALID</tt>.'};
doc['AnButton']['get_logicalName']={syn:'Retourne le nom logique de l\x27entr\xE9e analogique.',lib:'anbutton.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27entr\xE9e analogique.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27entr\xE9e analogique',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['AnButton']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'anbutton.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['AnButton']['get_pulseCounter']={syn:'Retourne la valeur du compteur d\x27impulsions.',lib:'anbutton.get_pulseCounter()',pro:'long get_pulseCounter()',cmt:'<p>Retourne la valeur du compteur d\x27impulsions.</p>',ret:'un entier repr\xE9sentant la valeur du compteur d\x27impulsions',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PULSECOUNTER_INVALID</tt>.'};
doc['AnButton']['get_pulseTimer']={syn:'Retourne le timer du compteur d\x27impulsions (ms) ',lib:'anbutton.get_pulseTimer()',pro:'long get_pulseTimer()',cmt:'<p>Retourne le timer du compteur d\x27impulsions (ms)</p>',ret:'un entier repr\xE9sentant le timer du compteur d\x27impulsions (ms)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['AnButton']['get_rawValue']={syn:'Retourne la valeur mesur\xE9e de l\x27entr\xE9e telle-quelle (entre 0 et 4095 inclus).',lib:'anbutton.get_rawValue()',pro:'int get_rawValue()',cmt:'<p>Retourne la valeur mesur\xE9e de l\x27entr\xE9e telle-quelle (entre 0 et 4095 inclus).</p>',ret:'un entier repr\xE9sentant la valeur mesur\xE9e de l\x27entr\xE9e telle-quelle (entre 0 et 4095 inclus)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RAWVALUE_INVALID</tt>.'};
doc['AnButton']['get_sensitivity']={syn:'Retourne la sensibilit\xE9 pour l\x27entr\xE9e (entre 1 et 255 inclus) pour le d\xE9clanchement de callbacks.',lib:'anbutton.get_sensitivity()',pro:'int get_sensitivity()',cmt:'<p>Retourne la sensibilit\xE9 pour l\x27entr\xE9e (entre 1 et 255 inclus) pour le d\xE9clanchement de callbacks.</p>',ret:'un entier repr\xE9sentant la sensibilit\xE9 pour l\x27entr\xE9e (entre 1 et 255 inclus) pour le d\xE9clanchement de callbacks',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_SENSITIVITY_INVALID</tt>.'};
doc['AnButton']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'anbutton.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['AnButton']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'anbutton.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['AnButton']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'anbutton.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AnButton']['nextAnButton']={syn:'Continue l\x27\xE9num\xE9ration des entr\xE9es analogiques commenc\xE9e \xE0 l\x27aide de <tt>yFirstAnButton()</tt>.',lib:'anbutton.nextAnButton()',pro:'YAnButton nextAnButton()',cmt:'<p>Continue l\x27\xE9num\xE9ration des entr\xE9es analogiques commenc\xE9e \xE0 l\x27aide de <tt>yFirstAnButton()</tt>.</p>',ret:'un pointeur sur un objet <tt>YAnButton</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['AnButton']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'anbutton.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['AnButton']['resetCounter']={syn:'r\xE9initialise le compteur d\x27impulsions et son timer ',lib:'anbutton.resetCounter()',pro:'int resetCounter()',cmt:'<p>r\xE9initialise le compteur d\x27impulsions et son timer</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AnButton']['set_analogCalibration']={syn:'Enclenche ou d\xE9clenche le proc\xE9dure de calibration.',lib:'anbutton.set_analogCalibration()',pro:'int set_analogCalibration(int <span id=pn>newval</span>)',cmt:'<p>Enclenche ou d\xE9clenche le proc\xE9dure de calibration. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module \xE0 la fin de la calibration si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'soit <tt>Y_ANALOGCALIBRATION_OFF</tt>, soit <tt>Y_ANALOGCALIBRATION_ON</tt>'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AnButton']['set_calibrationMax']={syn:'Modifie la valeur maximale de calibration pour l\x27entr\xE9e (entre 0 et 4095 inclus), sans lancer la calibration automatique.',lib:'anbutton.set_calibrationMax()',pro:'int set_calibrationMax(int <span id=pn>newval</span>)',cmt:'<p>Modifie la valeur maximale de calibration pour l\x27entr\xE9e (entre 0 et 4095 inclus), sans lancer la calibration automatique. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'un entier repr\xE9sentant la valeur maximale de calibration pour l\x27entr\xE9e (entre 0 et 4095 inclus), sans lancer la calibration automatique'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AnButton']['set_calibrationMin']={syn:'Modifie la valeur minimale de calibration pour l\x27entr\xE9e (entre 0 et 4095 inclus), sans lancer la calibration automatique.',lib:'anbutton.set_calibrationMin()',pro:'int set_calibrationMin(int <span id=pn>newval</span>)',cmt:'<p>Modifie la valeur minimale de calibration pour l\x27entr\xE9e (entre 0 et 4095 inclus), sans lancer la calibration automatique. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'un entier repr\xE9sentant la valeur minimale de calibration pour l\x27entr\xE9e (entre 0 et 4095 inclus), sans lancer la calibration automatique'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AnButton']['set_logicalName']={syn:'Modifie le nom logique de l\x27entr\xE9e analogique.',lib:'anbutton.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27entr\xE9e analogique. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27entr\xE9e analogique'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AnButton']['set_sensitivity']={syn:'Modifie la sensibilit\xE9 pour l\x27entr\xE9e (entre 1 et 255 inclus) pour le d\xE9clanchement de callbacks.',lib:'anbutton.set_sensitivity()',pro:'int set_sensitivity(int <span id=pn>newval</span>)',cmt:'<p>Modifie la sensibilit\xE9 pour l\x27entr\xE9e (entre 1 et 255 inclus) pour le d\xE9clanchement de callbacks. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'un entier repr\xE9sentant la sensibilit\xE9 pour l\x27entr\xE9e (entre 1 et 255 inclus) pour le d\xE9clanchement de callbacks'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['AnButton']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'anbutton.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: AnButton)
//--- (generated code: Voltage)
doc['Voltage']={'':{syn:'Interface de la fonction Voltage',inc:'import com.yoctopuce.YoctoAPI.YVoltage;',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
doc['Voltage']['FindVoltage']={syn:'Permet de retrouver un capteur de tension d\x27apr\xE8s un identifiant donn\xE9.',lib:'YVoltage.FindVoltage()',pro:'YVoltage FindVoltage(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de tension d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le capteur de tension soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YVoltage.isOnline()</tt> pour tester si le capteur de tension est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de tension sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YVoltage</tt> qui permet ensuite de contr\xF4ler le capteur de tension.'};
doc['Voltage']['FirstVoltage']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de tension accessibles par la librairie.',lib:'YVoltage.FirstVoltage()',pro:'YVoltage FirstVoltage()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de tension accessibles par la librairie. Utiliser la fonction <tt>YVoltage.nextVoltage()</tt> pour it\xE9rer sur les autres capteurs de tension.</p>',ret:'un pointeur sur un objet <tt>YVoltage</tt>, correspondant \xE0 le premier capteur de tension accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de tension disponibles.'};
doc['Voltage']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'voltage.calibrateFromPoints()',pro:'int calibrateFromPoints(ArrayList&lt;Double&gt; <span id=pn>rawValues</span>,&nbsp;ArrayList&lt;Double&gt; <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. </p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voltage']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'voltage.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Voltage']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de tension (pas plus de 6 caract\xE8res).',lib:'voltage.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de tension (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de tension (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Voltage']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'voltage.get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Voltage']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'voltage.get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Voltage']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'voltage.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Voltage']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'voltage.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Voltage']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'voltage.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Voltage']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'voltage.get_voltageDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Voltage']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'voltage.get_voltageId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Voltage']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'voltage.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Voltage']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e.',lib:'voltage.get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur maximale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Voltage']['get_logicalName']={syn:'Retourne le nom logique du capteur de tension.',lib:'voltage.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de tension.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de tension',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Voltage']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e.',lib:'voltage.get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur minimale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Voltage']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'voltage.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Voltage']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'voltage.get_resolution()',pro:'double get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Voltage']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'voltage.get_unit()',pro:'String get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Voltage']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'voltage.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Voltage']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'voltage.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Voltage']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'voltage.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voltage']['nextVoltage']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de tension commenc\xE9e \xE0 l\x27aide de <tt>yFirstVoltage()</tt>.',lib:'voltage.nextVoltage()',pro:'YVoltage nextVoltage()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de tension commenc\xE9e \xE0 l\x27aide de <tt>yFirstVoltage()</tt>.</p>',ret:'un pointeur sur un objet <tt>YVoltage</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Voltage']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'voltage.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Voltage']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'voltage.set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voltage']['set_logicalName']={syn:'Modifie le nom logique du capteur de tension.',lib:'voltage.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de tension. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de tension'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voltage']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'voltage.set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voltage']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'voltage.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Voltage)
//--- (generated code: Network)
doc['Network']={'':{syn:'Interface de la fonction Network',inc:'import com.yoctopuce.YoctoAPI.YNetwork;',cmt:'<p>Les objets YNetwork permettent de controller les param\xE8tres TCP/IP des modules Yoctopuce dot\xE9s d\x27une interface r\xE9seau.</p>'}};
doc['Network']['FindNetwork']={syn:'Permet de retrouver une interface r\xE9seau d\x27apr\xE8s un identifiant donn\xE9.',lib:'YNetwork.FindNetwork()',pro:'YNetwork FindNetwork(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver une interface r\xE9seau d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que l\x27interface r\xE9seau soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YNetwork.isOnline()</tt> pour tester si l\x27interface r\xE9seau est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27interface r\xE9seau sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YNetwork</tt> qui permet ensuite de contr\xF4ler l\x27interface r\xE9seau.'};
doc['Network']['FirstNetwork']={syn:'Commence l\x27\xE9num\xE9ration des interfaces r\xE9seau accessibles par la librairie.',lib:'YNetwork.FirstNetwork()',pro:'YNetwork FirstNetwork()',cmt:'<p>Commence l\x27\xE9num\xE9ration des interfaces r\xE9seau accessibles par la librairie. Utiliser la fonction <tt>YNetwork.nextNetwork()</tt> pour it\xE9rer sur les autres interfaces r\xE9seau.</p>',ret:'un pointeur sur un objet <tt>YNetwork</tt>, correspondant \xE0 la premi\xE8re interface r\xE9seau accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de interfaces r\xE9seau disponibles.'};
doc['Network']['callbackLogin']={syn:'Contacte le callback de notification et sauvegarde un laisser-passer pour s\x27y connecter.',lib:'network.callbackLogin()',pro:'int callbackLogin(String <span id=pn>username</span>, String <span id=pn>password</span>)',cmt:'<p>Contacte le callback de notification et sauvegarde un laisser-passer pour s\x27y connecter. Le mot de passe ne sera pas stock\xE9 dans le module, mais seulement une version hash\xE9e non r\xE9versible. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{username:'nom d\x27utilisateur pour s\x27identifier au callback',password:'mot de passe pour s\x27identifier au callback'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'network.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Network']['get_adminPassword']={syn:'Retourne une cha\xEEne de hash si un mot de passe a \xE9t\xE9 configur\xE9 pour l\x27utilisateur \x22admin\x22, ou sinon une cha\xEEne vide.',lib:'network.get_adminPassword()',pro:'String get_adminPassword()',cmt:'<p>Retourne une cha\xEEne de hash si un mot de passe a \xE9t\xE9 configur\xE9 pour l\x27utilisateur \x22admin\x22, ou sinon une cha\xEEne vide.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant une cha\xEEne de hash si un mot de passe a \xE9t\xE9 configur\xE9 pour l\x27utilisateur \x22admin\x22, ou sinon une cha\xEEne vide',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADMINPASSWORD_INVALID</tt>.'};
doc['Network']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27interface r\xE9seau (pas plus de 6 caract\xE8res).',lib:'network.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27interface r\xE9seau (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27interface r\xE9seau (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Network']['get_callbackCredentials']={syn:'Retourne une version hash\xE9e du laisser-passer pour le callback de notification si il a \xE9t\xE9 configur\xE9, ou sinon une cha\xEEne vide.',lib:'network.get_callbackCredentials()',pro:'String get_callbackCredentials()',cmt:'<p>Retourne une version hash\xE9e du laisser-passer pour le callback de notification si il a \xE9t\xE9 configur\xE9, ou sinon une cha\xEEne vide.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant une version hash\xE9e du laisser-passer pour le callback de notification si il a \xE9t\xE9 configur\xE9, ou sinon une cha\xEEne vide',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CALLBACKCREDENTIALS_INVALID</tt>.'};
doc['Network']['get_callbackEncoding']={syn:'Retourne l\x27encodage \xE0 utiliser pour repr\xE9senter les valeurs notifi\xE9es par callback.',lib:'network.get_callbackEncoding()',pro:'int get_callbackEncoding()',cmt:'<p>Retourne l\x27encodage \xE0 utiliser pour repr\xE9senter les valeurs notifi\xE9es par callback.</p>',ret:'une valeur parmi <tt>Y_CALLBACKENCODING_FORM</tt>, <tt>Y_CALLBACKENCODING_JSON</tt>, <tt>Y_CALLBACKENCODING_JSON_ARRAY</tt>, <tt>Y_CALLBACKENCODING_CSV</tt> et <tt>Y_CALLBACKENCODING_YOCTO_API</tt> repr\xE9sentant l\x27encodage \xE0 utiliser pour repr\xE9senter les valeurs notifi\xE9es par callback',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CALLBACKENCODING_INVALID</tt>.'};
doc['Network']['get_callbackMaxDelay']={syn:'Retourne l\x27attente maximale entre deux notifications par callback, en secondes.',lib:'network.get_callbackMaxDelay()',pro:'int get_callbackMaxDelay()',cmt:'<p>Retourne l\x27attente maximale entre deux notifications par callback, en secondes.</p>',ret:'un entier repr\xE9sentant l\x27attente maximale entre deux notifications par callback, en secondes',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CALLBACKMAXDELAY_INVALID</tt>.'};
doc['Network']['get_callbackMethod']={syn:'Retourne la m\xE9thode HTTP \xE0 utiliser pour signaler les changements d\x27\xE9tat par callback.',lib:'network.get_callbackMethod()',pro:'int get_callbackMethod()',cmt:'<p>Retourne la m\xE9thode HTTP \xE0 utiliser pour signaler les changements d\x27\xE9tat par callback.</p>',ret:'une valeur parmi <tt>Y_CALLBACKMETHOD_POST</tt>, <tt>Y_CALLBACKMETHOD_GET</tt> et <tt>Y_CALLBACKMETHOD_PUT</tt> repr\xE9sentant la m\xE9thode HTTP \xE0 utiliser pour signaler les changements d\x27\xE9tat par callback',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CALLBACKMETHOD_INVALID</tt>.'};
doc['Network']['get_callbackMinDelay']={syn:'Retourne l\x27attente minimale entre deux notifications par callback, en secondes.',lib:'network.get_callbackMinDelay()',pro:'int get_callbackMinDelay()',cmt:'<p>Retourne l\x27attente minimale entre deux notifications par callback, en secondes.</p>',ret:'un entier repr\xE9sentant l\x27attente minimale entre deux notifications par callback, en secondes',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CALLBACKMINDELAY_INVALID</tt>.'};
doc['Network']['get_callbackUrl']={syn:'Retourne l\x27adresse (URL) de callback \xE0 notifier lors de changement d\x27\xE9tat significatifs.',lib:'network.get_callbackUrl()',pro:'String get_callbackUrl()',cmt:'<p>Retourne l\x27adresse (URL) de callback \xE0 notifier lors de changement d\x27\xE9tat significatifs.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27adresse (URL) de callback \xE0 notifier lors de changement d\x27\xE9tat significatifs',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CALLBACKURL_INVALID</tt>.'};
doc['Network']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'network.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Network']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'network.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Network']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'network.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Network']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'network.get_networkDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Network']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'network.get_networkId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Network']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'network.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Network']['get_ipAddress']={syn:'Retourne l\x27adresse IP utilis\xE9e par le module Yoctopuce.',lib:'network.get_ipAddress()',pro:'String get_ipAddress()',cmt:'<p>Retourne l\x27adresse IP utilis\xE9e par le module Yoctopuce. Il peut s\x27agir d\x27une adresse configur\xE9e statiquement, ou d\x27une adresse re\xE7ue par un serveur DHCP.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27adresse IP utilis\xE9e par le module Yoctopuce',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_IPADDRESS_INVALID</tt>.'};
doc['Network']['get_logicalName']={syn:'Retourne le nom logique de l\x27interface r\xE9seau, qui correspond au nom r\xE9seau du module.',lib:'network.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27interface r\xE9seau, qui correspond au nom r\xE9seau du module.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27interface r\xE9seau, qui correspond au nom r\xE9seau du module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Network']['get_macAddress']={syn:'Retourne l\x27adresse MAC de l\x27interface r\xE9seau, unique pour chaque module.',lib:'network.get_macAddress()',pro:'String get_macAddress()',cmt:'<p>Retourne l\x27adresse MAC de l\x27interface r\xE9seau, unique pour chaque module. L\x27adresse MAC est aussi pr\xE9sente sur un autocollant sur le module, repr\xE9sent\xE9e en chiffres et en code-barres.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27adresse MAC de l\x27interface r\xE9seau, unique pour chaque module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_MACADDRESS_INVALID</tt>.'};
doc['Network']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'network.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Network']['get_primaryDNS']={syn:'Retourne l\x27adresse IP du serveur de nom primaire que le module doit utiliser.',lib:'network.get_primaryDNS()',pro:'String get_primaryDNS()',cmt:'<p>Retourne l\x27adresse IP du serveur de nom primaire que le module doit utiliser.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27adresse IP du serveur de nom primaire que le module doit utiliser',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PRIMARYDNS_INVALID</tt>.'};
doc['Network']['get_readiness']={syn:'Retourne l\x27\xE9tat de fonctionnement atteint par l\x27interface r\xE9seau.',lib:'network.get_readiness()',pro:'int get_readiness()',cmt:'<p>Retourne l\x27\xE9tat de fonctionnement atteint par l\x27interface r\xE9seau. Le niveau z\xE9ro (DOWN_0) signifie qu\x27aucun support r\xE9seau mat\xE9riel. Soit il n\x27y a pas de signal sur le cable r\xE9seau, soit le point d\x27acc\xE8s sans fil choisi n\x27est pas d\xE9tect\xE9. Le niveau 1 (LIVE_1) est atteint lorsque le r\xE9seau est d\xE9tect\xE9, mais n\x27est pas encore connect\xE9. Pour un r\xE9seau sans fil, cela confirme la l\x27existence du SSID configur\xE9. Le niveau 2 (LINK_2) est atteint lorsque le support mat\xE9riel du r\xE9seau est fonctionnel. Pour une connection r\xE9seau filaire, le niveau 2 signifie que le cable est connect\xE9 aux deux bouts. Pour une connection \xE0 un point d\x27acc\xE8s r\xE9seau sans fil, il d\xE9montre que les param\xE8tres de s\xE9curit\xE9s configur\xE9s sont corrects. Pour une connection sans fil en mode ad-hoc, cela signifie qu\x27il y a au moins un partenaire sur le r\xE9seau ad-hoc. Le niveau 3 (DHCP_3) est atteint lorsque qu\x27une adresse IP a \xE9t\xE9 obtenue par DHCP. Le niveau 4 (DNS_4) est atteint lorsqu\x27un serveur DNS est joignable par le r\xE9seau. Le niveau 5 (WWW_5) est atteint lorsque la connectivit\xE9 globale \xE0 internet est av\xE9r\xE9e par l\x27obtention de l\x27heure courante sur une serveur NTP.</p>',ret:'une valeur parmi <tt>Y_READINESS_DOWN</tt>, <tt>Y_READINESS_EXISTS</tt>, <tt>Y_READINESS_LINKED</tt>, <tt>Y_READINESS_LAN_OK</tt> et <tt>Y_READINESS_WWW_OK</tt> repr\xE9sentant l\x27\xE9tat de fonctionnement atteint par l\x27interface r\xE9seau',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_READINESS_INVALID</tt>.'};
doc['Network']['get_router']={syn:'Retourne l\x27adresse IP du routeur (passerelle) utilis\xE9 par le module (<i>default gateway</i>).',lib:'network.get_router()',pro:'String get_router()',cmt:'<p>Retourne l\x27adresse IP du routeur (passerelle) utilis\xE9 par le module (<i>default gateway</i>).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27adresse IP du routeur (passerelle) utilis\xE9 par le module (<i>default gateway</i>)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ROUTER_INVALID</tt>.'};
doc['Network']['get_secondaryDNS']={syn:'Retourne l\x27adresse IP du serveur de nom secondaire que le module doit utiliser.',lib:'network.get_secondaryDNS()',pro:'String get_secondaryDNS()',cmt:'<p>Retourne l\x27adresse IP du serveur de nom secondaire que le module doit utiliser.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27adresse IP du serveur de nom secondaire que le module doit utiliser',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_SECONDARYDNS_INVALID</tt>.'};
doc['Network']['get_subnetMask']={syn:'Retourne le masque de sous-r\xE9seau utilis\xE9 par le module.',lib:'network.get_subnetMask()',pro:'String get_subnetMask()',cmt:'<p>Retourne le masque de sous-r\xE9seau utilis\xE9 par le module.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le masque de sous-r\xE9seau utilis\xE9 par le module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_SUBNETMASK_INVALID</tt>.'};
doc['Network']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'network.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Network']['get_userPassword']={syn:'Retourne une cha\xEEne de hash si un mot de passe a \xE9t\xE9 configur\xE9 pour l\x27utilisateur \x22user\x22, ou sinon une cha\xEEne vide.',lib:'network.get_userPassword()',pro:'String get_userPassword()',cmt:'<p>Retourne une cha\xEEne de hash si un mot de passe a \xE9t\xE9 configur\xE9 pour l\x27utilisateur \x22user\x22, ou sinon une cha\xEEne vide.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant une cha\xEEne de hash si un mot de passe a \xE9t\xE9 configur\xE9 pour l\x27utilisateur \x22user\x22, ou sinon une cha\xEEne vide',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_USERPASSWORD_INVALID</tt>.'};
doc['Network']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'network.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Network']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'network.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['nextNetwork']={syn:'Continue l\x27\xE9num\xE9ration des interfaces r\xE9seau commenc\xE9e \xE0 l\x27aide de <tt>yFirstNetwork()</tt>.',lib:'network.nextNetwork()',pro:'YNetwork nextNetwork()',cmt:'<p>Continue l\x27\xE9num\xE9ration des interfaces r\xE9seau commenc\xE9e \xE0 l\x27aide de <tt>yFirstNetwork()</tt>.</p>',ret:'un pointeur sur un objet <tt>YNetwork</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Network']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'network.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Network']['set_adminPassword']={syn:'Modifie le mot de passe pour l\x27utilisateur \x22admin\x22, qui devient alors instantan\xE9ment n\xE9cessaire pour toute alt\xE9ration de l\x27\xE9tat du module.',lib:'network.set_adminPassword()',pro:'int set_adminPassword(String <span id=pn>newval</span>)',cmt:'<p>Modifie le mot de passe pour l\x27utilisateur \x22admin\x22, qui devient alors instantan\xE9ment n\xE9cessaire pour toute alt\xE9ration de l\x27\xE9tat du module. Si la valeur fournie est une cha\xEEne vide, plus aucun mot de passe n\x27est n\xE9cessaire. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le mot de passe pour l\x27utilisateur \x22admin\x22, qui devient alors instantan\xE9ment n\xE9cessaire pour toute alt\xE9ration de l\x27\xE9tat du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_callbackCredentials']={syn:'Modifie le laisser-passer pour se connecter \xE0 l\x27adresse de callback.',lib:'network.set_callbackCredentials()',pro:'int set_callbackCredentials(String <span id=pn>newval</span>)',cmt:'<p>Modifie le laisser-passer pour se connecter \xE0 l\x27adresse de callback. Le laisser-passer doit \xEAtre fourni tel que retourn\xE9 par la fonction <tt>get_callbackCredentials</tt>, sous la forme <tt>username:hash</tt>. La valeur du hash d\xE9pend de la m\xE9thode d\x27autorisation impl\xE9ment\xE9e par le callback. Pour une autorisation de type Basic, le hash est le MD5 de la cha\xEEne <tt>username:password</tt>. Pour une autorisation de type Digest, le hash est le MD5 de la cha\xEEne <tt>username:realm:password</tt>. Pour une utilisation simplifi\xE9e, utilisez la fonction <tt>callbackLogin</tt>. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le laisser-passer pour se connecter \xE0 l\x27adresse de callback'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_callbackEncoding']={syn:'Modifie l\x27encodage \xE0 utiliser pour repr\xE9senter les valeurs notifi\xE9es par callback.',lib:'network.set_callbackEncoding()',pro:'int set_callbackEncoding(int <span id=pn>newval</span>)',cmt:'<p>Modifie l\x27encodage \xE0 utiliser pour repr\xE9senter les valeurs notifi\xE9es par callback.</p>',par:{newval:'une valeur parmi <tt>Y_CALLBACKENCODING_FORM</tt>, <tt>Y_CALLBACKENCODING_JSON</tt>, <tt>Y_CALLBACKENCODING_JSON_ARRAY</tt>, <tt>Y_CALLBACKENCODING_CSV</tt> et <tt>Y_CALLBACKENCODING_YOCTO_API</tt> repr\xE9sentant l\x27encodage \xE0 utiliser pour repr\xE9senter les valeurs notifi\xE9es par callback'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_callbackMaxDelay']={syn:'Modifie l\x27attente maximale entre deux notifications par callback, en secondes.',lib:'network.set_callbackMaxDelay()',pro:'int set_callbackMaxDelay(int <span id=pn>newval</span>)',cmt:'<p>Modifie l\x27attente maximale entre deux notifications par callback, en secondes.</p>',par:{newval:'un entier repr\xE9sentant l\x27attente maximale entre deux notifications par callback, en secondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_callbackMethod']={syn:'Modifie la m\xE9thode HTTP \xE0 utiliser pour signaler les changements d\x27\xE9tat par callback.',lib:'network.set_callbackMethod()',pro:'int set_callbackMethod(int <span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9thode HTTP \xE0 utiliser pour signaler les changements d\x27\xE9tat par callback.</p>',par:{newval:'une valeur parmi <tt>Y_CALLBACKMETHOD_POST</tt>, <tt>Y_CALLBACKMETHOD_GET</tt> et <tt>Y_CALLBACKMETHOD_PUT</tt> repr\xE9sentant la m\xE9thode HTTP \xE0 utiliser pour signaler les changements d\x27\xE9tat par callback'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_callbackMinDelay']={syn:'Modifie l\x27attente minimale entre deux notifications par callback, en secondes.',lib:'network.set_callbackMinDelay()',pro:'int set_callbackMinDelay(int <span id=pn>newval</span>)',cmt:'<p>Modifie l\x27attente minimale entre deux notifications par callback, en secondes.</p>',par:{newval:'un entier repr\xE9sentant l\x27attente minimale entre deux notifications par callback, en secondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_callbackUrl']={syn:'Modifie l\x27adresse (URL) de callback \xE0 notifier lors de changement d\x27\xE9tat significatifs.',lib:'network.set_callbackUrl()',pro:'int set_callbackUrl(String <span id=pn>newval</span>)',cmt:'<p>Modifie l\x27adresse (URL) de callback \xE0 notifier lors de changement d\x27\xE9tat significatifs. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27adresse (URL) de callback \xE0 notifier lors de changement d\x27\xE9tat significatifs'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_logicalName']={syn:'Modifie le nom logique de l\x27interface r\xE9seau, qui correspond au nom r\xE9seau du module.',lib:'network.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27interface r\xE9seau, qui correspond au nom r\xE9seau du module. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27interface r\xE9seau, qui correspond au nom r\xE9seau du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_primaryDNS']={syn:'Modifie l\x27adresse IP du serveur de nom primaire que le module doit utiliser.',lib:'network.set_primaryDNS()',pro:'int set_primaryDNS(String <span id=pn>newval</span>)',cmt:'<p>Modifie l\x27adresse IP du serveur de nom primaire que le module doit utiliser. En mode DHCP, si une valeur est sp\xE9cifi\xE9e, elle remplacera celle re\xE7ue du serveur DHCP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27adresse IP du serveur de nom primaire que le module doit utiliser'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_secondaryDNS']={syn:'Modifie l\x27adresse IP du serveur de nom secondaire que le module doit utiliser.',lib:'network.set_secondaryDNS()',pro:'int set_secondaryDNS(String <span id=pn>newval</span>)',cmt:'<p>Modifie l\x27adresse IP du serveur de nom secondaire que le module doit utiliser. En mode DHCP, si une valeur est sp\xE9cifi\xE9e, elle remplacera celle re\xE7ue du serveur DHCP. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27adresse IP du serveur de nom secondaire que le module doit utiliser'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'network.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Network']['set_userPassword']={syn:'Modifie le mode de passe pour l\x27utilisateur \x22user\x22, qui devient alors instantan\xE9ment n\xE9cessaire pour tout acc\xE8s au module.',lib:'network.set_userPassword()',pro:'int set_userPassword(String <span id=pn>newval</span>)',cmt:'<p>Modifie le mode de passe pour l\x27utilisateur \x22user\x22, qui devient alors instantan\xE9ment n\xE9cessaire pour tout acc\xE8s au module. Si la valeur fournie est une cha\xEEne vide, plus aucun mot de passe n\x27est n\xE9cessaire. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le mode de passe pour l\x27utilisateur \x22user\x22, qui devient alors instantan\xE9ment n\xE9cessaire pour tout acc\xE8s au module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['useDHCP']={syn:'Modifie la configuration de l\x27interface r\xE9seau pour utiliser une adresse assign\xE9e automatiquement par le serveur DHCP.',lib:'network.useDHCP()',pro:'int useDHCP(String <span id=pn>fallbackIpAddr</span>,&nbsp;int <span id=pn>fallbackSubnetMaskLen</span>,&nbsp;String <span id=pn>fallbackRouter</span>)',cmt:'<p>Modifie la configuration de l\x27interface r\xE9seau pour utiliser une adresse assign\xE9e automatiquement par le serveur DHCP. En attendant qu\x27une adresse soit re\xE7ue (et ind\xE9finiment si aucun serveur DHCP ne r\xE9pond), le module utilisera les param\xE8tres IP sp\xE9cifi\xE9s \xE0 cette fonction. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{fallbackIpAddr:'adresse IP \xE0 utiliser si aucun serveur DHCP ne r\xE9pond',fallbackSubnetMaskLen:'longueur du masque de sous-r\xE9seau \xE0 utiliser si aucun serveur DHCP ne r\xE9pond. Par exemple, la valeur 24 repr\xE9sente 255.255.255.0.',fallbackRouter:'adresse de la passerelle \xE0 utiliser si aucun serveur DHCP ne r\xE9pond'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Network']['useStaticIP']={syn:'Modifie la configuration de l\x27interface r\xE9seau pour utiliser une adresse IP assign\xE9e manuellement (adresse IP statique).',lib:'network.useStaticIP()',pro:'int useStaticIP(String <span id=pn>ipAddress</span>,&nbsp;int <span id=pn>subnetMaskLen</span>,&nbsp;String <span id=pn>router</span>)',cmt:'<p>Modifie la configuration de l\x27interface r\xE9seau pour utiliser une adresse IP assign\xE9e manuellement (adresse IP statique). N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{ipAddress:'adresse IP \xE0 utiliser par le module',subnetMaskLen:'longueur du masque de sous-r\xE9seau \xE0 utiliser. Par exemple, la valeur 24 repr\xE9sente 255.255.255.0.',router:'adresse IP de la passerelle \xE0 utiliser (\x22default gateway\x22)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Network)
//--- (generated code: Wireless)
doc['Wireless']={'':{syn:'Interface de la fonction Wireless',inc:'import com.yoctopuce.YoctoAPI.YWireless;'}};
doc['Wireless']['FindWireless']={syn:'Permet de retrouver une interface r\xE9seau sans fil d\x27apr\xE8s un identifiant donn\xE9.',lib:'YWireless.FindWireless()',pro:'YWireless FindWireless(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver une interface r\xE9seau sans fil d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que l\x27interface r\xE9seau sans fil soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YWireless.isOnline()</tt> pour tester si l\x27interface r\xE9seau sans fil est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27interface r\xE9seau sans fil sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YWireless</tt> qui permet ensuite de contr\xF4ler l\x27interface r\xE9seau sans fil.'};
doc['Wireless']['FirstWireless']={syn:'Commence l\x27\xE9num\xE9ration des interfaces r\xE9seau sans fil accessibles par la librairie.',lib:'YWireless.FirstWireless()',pro:'YWireless FirstWireless()',cmt:'<p>Commence l\x27\xE9num\xE9ration des interfaces r\xE9seau sans fil accessibles par la librairie. Utiliser la fonction <tt>YWireless.nextWireless()</tt> pour it\xE9rer sur les autres interfaces r\xE9seau sans fil.</p>',ret:'un pointeur sur un objet <tt>YWireless</tt>, correspondant \xE0 la premi\xE8re interface r\xE9seau sans fil accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de interfaces r\xE9seau sans fil disponibles.'};
doc['Wireless']['adhocNetwork']={syn:'Modifie la configuration de l\x27interface r\xE9seau sans fil pour cr\xE9er un r\xE9seau sans fil sans point d\x27acc\xE8s, en mode \x22ad-hoc\x22.',lib:'wireless.adhocNetwork()',pro:'int adhocNetwork(String <span id=pn>ssid</span>, String <span id=pn>securityKey</span>)',cmt:'<p>Modifie la configuration de l\x27interface r\xE9seau sans fil pour cr\xE9er un r\xE9seau sans fil sans point d\x27acc\xE8s, en mode \x22ad-hoc\x22. Si une clef d\x27acc\xE8s est sp\xE9cifi\xE9e, le r\xE9seau sera prot\xE9g\xE9 par une s\xE9curit\xE9 WEP128 (l\x27utilisation de WPA n\x27est pas standardis\xE9e en mode ad-hoc). N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{ssid:'nom du r\xE9seau sans fil \xE0 cr\xE9er',securityKey:'cl\xE9 d\x27acc\xE8s de r\xE9seau, sous forme de cha\xEEne de caract\xE8res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Wireless']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'wireless.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Wireless']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27interface r\xE9seau sans fil (pas plus de 6 caract\xE8res).',lib:'wireless.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27interface r\xE9seau sans fil (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27interface r\xE9seau sans fil (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Wireless']['get_channel']={syn:'Retourne le num\xE9ro du canal 802.',lib:'wireless.get_channel()',pro:'int get_channel()',cmt:'<p>Retourne le num\xE9ro du canal 802.11 utilis\xE9, ou 0 si le r\xE9seau s\xE9lectionn\xE9 n\x27a pas \xE9t\xE9 trouv\xE9.</p>',ret:'un entier repr\xE9sentant le num\xE9ro du canal 802',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CHANNEL_INVALID</tt>.'};
doc['Wireless']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'wireless.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Wireless']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'wireless.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Wireless']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'wireless.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Wireless']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'wireless.get_wirelessDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Wireless']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'wireless.get_wirelessId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Wireless']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'wireless.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Wireless']['get_linkQuality']={syn:'Retourne la qualit\xE9 de la connection, exprim\xE9e en pourcents.',lib:'wireless.get_linkQuality()',pro:'int get_linkQuality()',cmt:'<p>Retourne la qualit\xE9 de la connection, exprim\xE9e en pourcents.</p>',ret:'un entier repr\xE9sentant la qualit\xE9 de la connection, exprim\xE9e en pourcents',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LINKQUALITY_INVALID</tt>.'};
doc['Wireless']['get_logicalName']={syn:'Retourne le nom logique de l\x27interface r\xE9seau sans fil.',lib:'wireless.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27interface r\xE9seau sans fil.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27interface r\xE9seau sans fil',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Wireless']['get_message']={syn:'Retourne le dernier message de diagnostique de l\x27interface au r\xE9seau sans fil.',lib:'wireless.get_message()',pro:'String get_message()',cmt:'<p>Retourne le dernier message de diagnostique de l\x27interface au r\xE9seau sans fil.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le dernier message de diagnostique de l\x27interface au r\xE9seau sans fil',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_MESSAGE_INVALID</tt>.'};
doc['Wireless']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'wireless.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Wireless']['get_security']={syn:'Retourne l\x27algorithme de s\xE9curit\xE9 utilis\xE9 par le r\xE9seau sans-fil s\xE9lectionn\xE9.',lib:'wireless.get_security()',pro:'int get_security()',cmt:'<p>Retourne l\x27algorithme de s\xE9curit\xE9 utilis\xE9 par le r\xE9seau sans-fil s\xE9lectionn\xE9.</p>',ret:'une valeur parmi <tt>Y_SECURITY_UNKNOWN</tt>, <tt>Y_SECURITY_OPEN</tt>, <tt>Y_SECURITY_WEP</tt>, <tt>Y_SECURITY_WPA</tt> et <tt>Y_SECURITY_WPA2</tt> repr\xE9sentant l\x27algorithme de s\xE9curit\xE9 utilis\xE9 par le r\xE9seau sans-fil s\xE9lectionn\xE9',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_SECURITY_INVALID</tt>.'};
doc['Wireless']['get_ssid']={syn:'Retourne le nom (SSID) du r\xE9seau sans-fil s\xE9lectionn\xE9.',lib:'wireless.get_ssid()',pro:'String get_ssid()',cmt:'<p>Retourne le nom (SSID) du r\xE9seau sans-fil s\xE9lectionn\xE9.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom (SSID) du r\xE9seau sans-fil s\xE9lectionn\xE9',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_SSID_INVALID</tt>.'};
doc['Wireless']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'wireless.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Wireless']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'wireless.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Wireless']['joinNetwork']={syn:'Modifie la configuration de l\x27interface r\xE9seau sans fil pour se connecter \xE0 un point d\x27acc\xE8s sans fil existant (mode \x22infrastructure\x22).',lib:'wireless.joinNetwork()',pro:'int joinNetwork(String <span id=pn>ssid</span>, String <span id=pn>securityKey</span>)',cmt:'<p>Modifie la configuration de l\x27interface r\xE9seau sans fil pour se connecter \xE0 un point d\x27acc\xE8s sans fil existant (mode \x22infrastructure\x22). N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{ssid:'nom du r\xE9seau sans fil \xE0 utiliser',securityKey:'cl\xE9 d\x27acc\xE8s au r\xE9seau, sous forme de cha\xEEne de caract\xE8res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Wireless']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'wireless.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Wireless']['nextWireless']={syn:'Continue l\x27\xE9num\xE9ration des interfaces r\xE9seau sans fil commenc\xE9e \xE0 l\x27aide de <tt>yFirstWireless()</tt>.',lib:'wireless.nextWireless()',pro:'YWireless nextWireless()',cmt:'<p>Continue l\x27\xE9num\xE9ration des interfaces r\xE9seau sans fil commenc\xE9e \xE0 l\x27aide de <tt>yFirstWireless()</tt>.</p>',ret:'un pointeur sur un objet <tt>YWireless</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Wireless']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'wireless.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Wireless']['set_logicalName']={syn:'Modifie le nom logique de l\x27interface r\xE9seau sans fil.',lib:'wireless.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27interface r\xE9seau sans fil. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27interface r\xE9seau sans fil'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Wireless']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'wireless.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Wireless)
//--- (generated code: Led)
doc['Led']={'':{syn:'Interface de la fonction Led',inc:'import com.yoctopuce.YoctoAPI.YLed;',cmt:'<p>La librairie de programmation Yoctopuce permet non seulement d\x27allumer la led \xE0 une intensit\xE9 donn\xE9e, mais aussi de la faire osciller \xE0 plusieurs fr\xE9quences.</p>'}};
doc['Led']['FindLed']={syn:'Permet de retrouver une led d\x27apr\xE8s un identifiant donn\xE9.',lib:'YLed.FindLed()',pro:'YLed FindLed(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver une led d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que la led soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YLed.isOnline()</tt> pour tester si la led est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence la led sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YLed</tt> qui permet ensuite de contr\xF4ler la led.'};
doc['Led']['FirstLed']={syn:'Commence l\x27\xE9num\xE9ration des leds accessibles par la librairie.',lib:'YLed.FirstLed()',pro:'YLed FirstLed()',cmt:'<p>Commence l\x27\xE9num\xE9ration des leds accessibles par la librairie. Utiliser la fonction <tt>YLed.nextLed()</tt> pour it\xE9rer sur les autres leds.</p>',ret:'un pointeur sur un objet <tt>YLed</tt>, correspondant \xE0 la premi\xE8re led accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de leds disponibles.'};
doc['Led']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'led.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Led']['get_advertisedValue']={syn:'Retourne la valeur courante de la led (pas plus de 6 caract\xE8res).',lib:'led.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante de la led (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de la led (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Led']['get_blinking']={syn:'Retourne le mode de signalisation de la led.',lib:'led.get_blinking()',pro:'int get_blinking()',cmt:'<p>Retourne le mode de signalisation de la led.</p>',ret:'une valeur parmi <tt>Y_BLINKING_STILL</tt>, <tt>Y_BLINKING_RELAX</tt>, <tt>Y_BLINKING_AWARE</tt>, <tt>Y_BLINKING_RUN</tt>, <tt>Y_BLINKING_CALL</tt> et <tt>Y_BLINKING_PANIC</tt> repr\xE9sentant le mode de signalisation de la led',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_BLINKING_INVALID</tt>.'};
doc['Led']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'led.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Led']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'led.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Led']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'led.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Led']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'led.get_ledDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Led']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'led.get_ledId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Led']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'led.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Led']['get_logicalName']={syn:'Retourne le nom logique de la led.',lib:'led.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique de la led.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la led',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Led']['get_luminosity']={syn:'Retourne l\x27intensit\xE9 de la led en pour cent.',lib:'led.get_luminosity()',pro:'int get_luminosity()',cmt:'<p>Retourne l\x27intensit\xE9 de la led en pour cent.</p>',ret:'un entier repr\xE9sentant l\x27intensit\xE9 de la led en pour cent',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LUMINOSITY_INVALID</tt>.'};
doc['Led']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'led.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Led']['get_power']={syn:'Retourne l\x27\xE9tat courant de la led.',lib:'led.get_power()',pro:'int get_power()',cmt:'<p>Retourne l\x27\xE9tat courant de la led.</p>',ret:'soit <tt>Y_POWER_OFF</tt>, soit <tt>Y_POWER_ON</tt>, selon l\x27\xE9tat courant de la led',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_POWER_INVALID</tt>.'};
doc['Led']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'led.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Led']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'led.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Led']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'led.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Led']['nextLed']={syn:'Continue l\x27\xE9num\xE9ration des leds commenc\xE9e \xE0 l\x27aide de <tt>yFirstLed()</tt>.',lib:'led.nextLed()',pro:'YLed nextLed()',cmt:'<p>Continue l\x27\xE9num\xE9ration des leds commenc\xE9e \xE0 l\x27aide de <tt>yFirstLed()</tt>.</p>',ret:'un pointeur sur un objet <tt>YLed</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Led']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'led.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Led']['set_blinking']={syn:'Modifie le mode de signalisation de la led.',lib:'led.set_blinking()',pro:'int set_blinking(int <span id=pn>newval</span>)',cmt:'<p>Modifie le mode de signalisation de la led.</p>',par:{newval:'une valeur parmi <tt>Y_BLINKING_STILL</tt>, <tt>Y_BLINKING_RELAX</tt>, <tt>Y_BLINKING_AWARE</tt>, <tt>Y_BLINKING_RUN</tt>, <tt>Y_BLINKING_CALL</tt> et <tt>Y_BLINKING_PANIC</tt> repr\xE9sentant le mode de signalisation de la led'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Led']['set_logicalName']={syn:'Modifie le nom logique de la led.',lib:'led.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de la led. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de la led'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Led']['set_luminosity']={syn:'Modifie l\x27intensit\xE9 lumineuse de la led (en pour cent).',lib:'led.set_luminosity()',pro:'int set_luminosity(int <span id=pn>newval</span>)',cmt:'<p>Modifie l\x27intensit\xE9 lumineuse de la led (en pour cent).</p>',par:{newval:'un entier repr\xE9sentant l\x27intensit\xE9 lumineuse de la led (en pour cent)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Led']['set_power']={syn:'Modifie l\x27\xE9tat courant de la led.',lib:'led.set_power()',pro:'int set_power(int <span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat courant de la led.</p>',par:{newval:'soit <tt>Y_POWER_OFF</tt>, soit <tt>Y_POWER_ON</tt>, selon l\x27\xE9tat courant de la led'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Led']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'led.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Led)
//--- (generated code: Voc)
doc['Voc']={'':{syn:'Interface de la fonction Voc',inc:'import com.yoctopuce.YoctoAPI.YVoc;',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
doc['Voc']['FindVoc']={syn:'Permet de retrouver un capteur de Compos\xE9s Organiques Volatils d\x27apr\xE8s un identifiant donn\xE9.',lib:'YVoc.FindVoc()',pro:'YVoc FindVoc(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de Compos\xE9s Organiques Volatils d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le capteur de Compos\xE9s Organiques Volatils soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YVoc.isOnline()</tt> pour tester si le capteur de Compos\xE9s Organiques Volatils est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de Compos\xE9s Organiques Volatils sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YVoc</tt> qui permet ensuite de contr\xF4ler le capteur de Compos\xE9s Organiques Volatils.'};
doc['Voc']['FirstVoc']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de Compos\xE9s Organiques Volatils accessibles par la librairie.',lib:'YVoc.FirstVoc()',pro:'YVoc FirstVoc()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de Compos\xE9s Organiques Volatils accessibles par la librairie. Utiliser la fonction <tt>YVoc.nextVoc()</tt> pour it\xE9rer sur les autres capteurs de Compos\xE9s Organiques Volatils.</p>',ret:'un pointeur sur un objet <tt>YVoc</tt>, correspondant \xE0 le premier capteur de Compos\xE9s Organiques Volatils accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de Compos\xE9s Organiques Volatils disponibles.'};
doc['Voc']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'voc.calibrateFromPoints()',pro:'int calibrateFromPoints(ArrayList&lt;Double&gt; <span id=pn>rawValues</span>,&nbsp;ArrayList&lt;Double&gt; <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. </p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voc']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'voc.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Voc']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de Compos\xE9s Organiques Volatils (pas plus de 6 caract\xE8res).',lib:'voc.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de Compos\xE9s Organiques Volatils (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de Compos\xE9s Organiques Volatils (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Voc']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'voc.get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Voc']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'voc.get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Voc']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'voc.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Voc']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'voc.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Voc']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'voc.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Voc']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'voc.get_vocDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Voc']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'voc.get_vocId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Voc']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'voc.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Voc']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e.',lib:'voc.get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur maximale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Voc']['get_logicalName']={syn:'Retourne le nom logique du capteur de Compos\xE9s Organiques Volatils.',lib:'voc.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de Compos\xE9s Organiques Volatils.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de Compos\xE9s Organiques Volatils',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Voc']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e.',lib:'voc.get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur minimale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Voc']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'voc.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Voc']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'voc.get_resolution()',pro:'double get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Voc']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'voc.get_unit()',pro:'String get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Voc']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'voc.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Voc']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'voc.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Voc']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'voc.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voc']['nextVoc']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de Compos\xE9s Organiques Volatils commenc\xE9e \xE0 l\x27aide de <tt>yFirstVoc()</tt>.',lib:'voc.nextVoc()',pro:'YVoc nextVoc()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de Compos\xE9s Organiques Volatils commenc\xE9e \xE0 l\x27aide de <tt>yFirstVoc()</tt>.</p>',ret:'un pointeur sur un objet <tt>YVoc</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Voc']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'voc.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Voc']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'voc.set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voc']['set_logicalName']={syn:'Modifie le nom logique du capteur de Compos\xE9s Organiques Volatils.',lib:'voc.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de Compos\xE9s Organiques Volatils. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de Compos\xE9s Organiques Volatils'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voc']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'voc.set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Voc']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'voc.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Voc)
//--- (generated code: Watchdog)
doc['Watchdog']={'':{syn:'Interface de la fonction Watchdog',inc:'import com.yoctopuce.YoctoAPI.YWatchdog;',cmt:'<p>La fonction WatchDog est g\xE9r\xE9e comme un relais qui couperait bri\xE8vement l\x27alimentation d\x27un appareil apr\xE8s un d\x27attente temps donn\xE9 afin de provoquer une r\xE9initialisation compl\xE8te de cet appareil. Il suffit d\x27appeler le watchdog \xE0 intervale r\xE9gulier pour l\x27emp\xE8cher de provoquer la r\xE9initialisation. Le watchog peut aussi \xEAtre pilot\xE9 directement \xE0 l\x27aide des methode <i>pulse</i> et <i>delayedpulse</i> pour \xE9teindre un appareil pendant un temps donn\xE9.</p>'}};
doc['Watchdog']['FindWatchdog']={syn:'Permet de retrouver un watchdog d\x27apr\xE8s un identifiant donn\xE9.',lib:'YWatchdog.FindWatchdog()',pro:'YWatchdog FindWatchdog(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver un watchdog d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le watchdog soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YWatchdog.isOnline()</tt> pour tester si le watchdog est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le watchdog sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YWatchdog</tt> qui permet ensuite de contr\xF4ler le watchdog.'};
doc['Watchdog']['FirstWatchdog']={syn:'Commence l\x27\xE9num\xE9ration des watchdog accessibles par la librairie.',lib:'YWatchdog.FirstWatchdog()',pro:'YWatchdog FirstWatchdog()',cmt:'<p>Commence l\x27\xE9num\xE9ration des watchdog accessibles par la librairie. Utiliser la fonction <tt>YWatchdog.nextWatchdog()</tt> pour it\xE9rer sur les autres watchdog.</p>',ret:'un pointeur sur un objet <tt>YWatchdog</tt>, correspondant \xE0 le premier watchdog accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de watchdog disponibles.'};
doc['Watchdog']['delayedPulse']={syn:'Pr\xE9-programme une impulsion ',lib:'watchdog.delayedPulse()',pro:'int delayedPulse(int <span id=pn>ms_delay</span>, int <span id=pn>ms_duration</span>)',cmt:'<p>Pr\xE9-programme une impulsion</p>',par:{ms_delay:'delai d\x27attente avant l\x27implusion, en millisecondes',ms_duration:'dur\xE9e de l\x27impulsion, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'watchdog.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Watchdog']['get_advertisedValue']={syn:'Retourne la valeur courante du watchdog (pas plus de 6 caract\xE8res).',lib:'watchdog.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante du watchdog (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du watchdog (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Watchdog']['get_autoStart']={syn:'Retourne l\x27\xE9tat du watchdog \xE0 la mise sous tension du module.',lib:'watchdog.get_autoStart()',pro:'int get_autoStart()',cmt:'<p>Retourne l\x27\xE9tat du watchdog \xE0 la mise sous tension du module.</p>',ret:'soit <tt>Y_AUTOSTART_OFF</tt>, soit <tt>Y_AUTOSTART_ON</tt>, selon l\x27\xE9tat du watchdog \xE0 la mise sous tension du module',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_AUTOSTART_INVALID</tt>.'};
doc['Watchdog']['get_countdown']={syn:'Retourne le nombre de millisecondes restantes avant le d\xE9clenchement d\x27une impulsion pr\xE9programm\xE9e par un appel \xE0 delayedPulse().',lib:'watchdog.get_countdown()',pro:'long get_countdown()',cmt:'<p>Retourne le nombre de millisecondes restantes avant le d\xE9clenchement d\x27une impulsion pr\xE9programm\xE9e par un appel \xE0 delayedPulse(). Si aucune impulsion n\x27est programm\xE9e, retourne z\xE9ro.</p>',ret:'un entier repr\xE9sentant le nombre de millisecondes restantes avant le d\xE9clenchement d\x27une impulsion pr\xE9programm\xE9e par un appel \xE0 delayedPulse()',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_COUNTDOWN_INVALID</tt>.'};
doc['Watchdog']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'watchdog.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Watchdog']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'watchdog.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Watchdog']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'watchdog.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Watchdog']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'watchdog.get_watchdogDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Watchdog']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'watchdog.get_watchdogId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Watchdog']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'watchdog.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Watchdog']['get_logicalName']={syn:'Retourne le nom logique du watchdog.',lib:'watchdog.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique du watchdog.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du watchdog',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Watchdog']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'watchdog.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Watchdog']['get_output']={syn:'Retourne l\x27\xE9tat de la sortie du watchdog, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.',lib:'watchdog.get_output()',pro:'int get_output()',cmt:'<p>Retourne l\x27\xE9tat de la sortie du watchdog, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.</p>',ret:'soit <tt>Y_OUTPUT_OFF</tt>, soit <tt>Y_OUTPUT_ON</tt>, selon l\x27\xE9tat de la sortie du watchdog, lorsqu\x27il est utilis\xE9 comme un simple interrupteur',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_OUTPUT_INVALID</tt>.'};
doc['Watchdog']['get_pulseTimer']={syn:'Retourne le nombre de millisecondes restantes avant le retour \xE0 la position de repos (\xE9tat A), durant la g\xE9n\xE9ration d\x27une impulsion mesur\xE9e.',lib:'watchdog.get_pulseTimer()',pro:'long get_pulseTimer()',cmt:'<p>Retourne le nombre de millisecondes restantes avant le retour \xE0 la position de repos (\xE9tat A), durant la g\xE9n\xE9ration d\x27une impulsion mesur\xE9e. Si aucune impulsion n\x27est en cours, retourne z\xE9ro.</p>',ret:'un entier repr\xE9sentant le nombre de millisecondes restantes avant le retour \xE0 la position de repos (\xE9tat A), durant la g\xE9n\xE9ration d\x27une impulsion mesur\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_PULSETIMER_INVALID</tt>.'};
doc['Watchdog']['get_running']={syn:'Retourne l\x27\xE9tat du watchdog.',lib:'watchdog.get_running()',pro:'int get_running()',cmt:'<p>Retourne l\x27\xE9tat du watchdog.</p>',ret:'soit <tt>Y_RUNNING_OFF</tt>, soit <tt>Y_RUNNING_ON</tt>, selon l\x27\xE9tat du watchdog',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RUNNING_INVALID</tt>.'};
doc['Watchdog']['get_state']={syn:'Retourne l\x27\xE9tat du watchdog (A pour la position de repos, B pour l\x27\xE9tat actif).',lib:'watchdog.get_state()',pro:'int get_state()',cmt:'<p>Retourne l\x27\xE9tat du watchdog (A pour la position de repos, B pour l\x27\xE9tat actif).</p>',ret:'soit <tt>Y_STATE_A</tt>, soit <tt>Y_STATE_B</tt>, selon l\x27\xE9tat du watchdog (A pour la position de repos, B pour l\x27\xE9tat actif)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_STATE_INVALID</tt>.'};
doc['Watchdog']['get_triggerDelay']={syn:'Retourne le d\xE9lai d\x27attente avant qu\x27un reset ne soit automatiquement g\xE9n\xE9r\xE9 par le watchog, en millisecondes.',lib:'watchdog.get_triggerDelay()',pro:'long get_triggerDelay()',cmt:'<p>Retourne le d\xE9lai d\x27attente avant qu\x27un reset ne soit automatiquement g\xE9n\xE9r\xE9 par le watchog, en millisecondes.</p>',ret:'un entier repr\xE9sentant le d\xE9lai d\x27attente avant qu\x27un reset ne soit automatiquement g\xE9n\xE9r\xE9 par le watchog, en millisecondes',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_TRIGGERDELAY_INVALID</tt>.'};
doc['Watchdog']['get_triggerDuration']={syn:'Retourne la dur\xE9e d\x27un reset g\xE9n\xE9r\xE9 par le watchog, en millisecondes.',lib:'watchdog.get_triggerDuration()',pro:'long get_triggerDuration()',cmt:'<p>Retourne la dur\xE9e d\x27un reset g\xE9n\xE9r\xE9 par le watchog, en millisecondes.</p>',ret:'un entier repr\xE9sentant la dur\xE9e d\x27un reset g\xE9n\xE9r\xE9 par le watchog, en millisecondes',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_TRIGGERDURATION_INVALID</tt>.'};
doc['Watchdog']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'watchdog.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Watchdog']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'watchdog.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Watchdog']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'watchdog.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['nextWatchdog']={syn:'Continue l\x27\xE9num\xE9ration des watchdog commenc\xE9e \xE0 l\x27aide de <tt>yFirstWatchdog()</tt>.',lib:'watchdog.nextWatchdog()',pro:'YWatchdog nextWatchdog()',cmt:'<p>Continue l\x27\xE9num\xE9ration des watchdog commenc\xE9e \xE0 l\x27aide de <tt>yFirstWatchdog()</tt>.</p>',ret:'un pointeur sur un objet <tt>YWatchdog</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Watchdog']['pulse']={syn:'Commute le relais \xE0 l\x27\xE9tat B (actif) pour un dur\xE9e sp\xE9cifi\xE9e, puis revient ensuite spontan\xE9ment vers l\x27\xE9tat A (\xE9tat de repos).',lib:'watchdog.pulse()',pro:'int pulse(int <span id=pn>ms_duration</span>)',cmt:'<p>Commute le relais \xE0 l\x27\xE9tat B (actif) pour un dur\xE9e sp\xE9cifi\xE9e, puis revient ensuite spontan\xE9ment vers l\x27\xE9tat A (\xE9tat de repos).</p>',par:{ms_duration:'dur\xE9e de l\x27impulsion, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'watchdog.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Watchdog']['resetWatchdog']={syn:'R\xE9initialise le WatchDog.',lib:'watchdog.resetWatchdog()',pro:'int resetWatchdog()',cmt:'<p>R\xE9initialise le WatchDog. Quand le watchdog est en fonctionnement cette fonction doit \xEAtre appel\xE9e \xE0 interval r\xE9gulier, pour emp\xE9cher que le watdog ne se d\xE9clenche</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['set_autoStart']={syn:'Modifie l\x27\xE9tat du watching au d\xE9marrage du module.',lib:'watchdog.set_autoStart()',pro:'int set_autoStart(int <span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat du watching au d\xE9marrage du module. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> et de red\xE9marrer le module pour que le param\xE8tre soit appliqu\xE9.</p>',par:{newval:'soit <tt>Y_AUTOSTART_OFF</tt>, soit <tt>Y_AUTOSTART_ON</tt>, selon l\x27\xE9tat du watching au d\xE9marrage du module'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['set_logicalName']={syn:'Modifie le nom logique du watchdog.',lib:'watchdog.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du watchdog. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du watchdog'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['set_output']={syn:'Modifie l\x27\xE9tat de la sortie du watchdog, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.',lib:'watchdog.set_output()',pro:'int set_output(int <span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat de la sortie du watchdog, lorsqu\x27il est utilis\xE9 comme un simple interrupteur.</p>',par:{newval:'soit <tt>Y_OUTPUT_OFF</tt>, soit <tt>Y_OUTPUT_ON</tt>, selon l\x27\xE9tat de la sortie du watchdog, lorsqu\x27il est utilis\xE9 comme un simple interrupteur'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['set_running']={syn:'Modifie manuellement l\x27\xE9tat de fonctionnement du watchdog.',lib:'watchdog.set_running()',pro:'int set_running(int <span id=pn>newval</span>)',cmt:'<p>Modifie manuellement l\x27\xE9tat de fonctionnement du watchdog.</p>',par:{newval:'soit <tt>Y_RUNNING_OFF</tt>, soit <tt>Y_RUNNING_ON</tt>, selon manuellement l\x27\xE9tat de fonctionnement du watchdog'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['set_state']={syn:'Modifie l\x27\xE9tat du watchdog (A pour la position de repos, B pour l\x27\xE9tat actif).',lib:'watchdog.set_state()',pro:'int set_state(int <span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat du watchdog (A pour la position de repos, B pour l\x27\xE9tat actif).</p>',par:{newval:'soit <tt>Y_STATE_A</tt>, soit <tt>Y_STATE_B</tt>, selon l\x27\xE9tat du watchdog (A pour la position de repos, B pour l\x27\xE9tat actif)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['set_triggerDelay']={syn:'Modifie le d\xE9lai d\x27attente avant qu\x27un reset ne soit g\xE9n\xE9r\xE9 par le watchog, en millisecondes.',lib:'watchdog.set_triggerDelay()',pro:'int set_triggerDelay(long <span id=pn>newval</span>)',cmt:'<p>Modifie le d\xE9lai d\x27attente avant qu\x27un reset ne soit g\xE9n\xE9r\xE9 par le watchog, en millisecondes.</p>',par:{newval:'un entier repr\xE9sentant le d\xE9lai d\x27attente avant qu\x27un reset ne soit g\xE9n\xE9r\xE9 par le watchog, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['set_triggerDuration']={syn:'Modifie la dur\xE9e des resets g\xE9n\xE9r\xE9s par le watchog, en millisecondes.',lib:'watchdog.set_triggerDuration()',pro:'int set_triggerDuration(long <span id=pn>newval</span>)',cmt:'<p>Modifie la dur\xE9e des resets g\xE9n\xE9r\xE9s par le watchog, en millisecondes.</p>',par:{newval:'un entier repr\xE9sentant la dur\xE9e des resets g\xE9n\xE9r\xE9s par le watchog, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Watchdog']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'watchdog.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Watchdog)
//--- (generated code: Power)
doc['Power']={'':{syn:'Interface de la fonction Power',inc:'import com.yoctopuce.YoctoAPI.YPower;',cmt:'<p>La librairie de programmation Yoctopuce permet lire une valeur instantan\xE9e du capteur, ainsi que les extr\xE9mas atteints.</p>'}};
doc['Power']['FindPower']={syn:'Permet de retrouver un capteur de puissance electrique d\x27apr\xE8s un identifiant donn\xE9.',lib:'YPower.FindPower()',pro:'YPower FindPower(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver un capteur de puissance electrique d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le capteur de puissance electrique soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YPower.isOnline()</tt> pour tester si le capteur de puissance electrique est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le capteur de puissance electrique sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YPower</tt> qui permet ensuite de contr\xF4ler le capteur de puissance electrique.'};
doc['Power']['FirstPower']={syn:'Commence l\x27\xE9num\xE9ration des capteurs de puissance electrique accessibles par la librairie.',lib:'YPower.FirstPower()',pro:'YPower FirstPower()',cmt:'<p>Commence l\x27\xE9num\xE9ration des capteurs de puissance electrique accessibles par la librairie. Utiliser la fonction <tt>YPower.nextPower()</tt> pour it\xE9rer sur les autres capteurs de puissance electrique.</p>',ret:'un pointeur sur un objet <tt>YPower</tt>, correspondant \xE0 le premier capteur de puissance electrique accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de capteurs de puissance electrique disponibles.'};
doc['Power']['calibrateFromPoints']={syn:'Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur.',lib:'power.calibrateFromPoints()',pro:'int calibrateFromPoints(ArrayList&lt;Double&gt; <span id=pn>rawValues</span>,&nbsp;ArrayList&lt;Double&gt; <span id=pn>refValues</span>)',cmt:'<p>Enregistre des points de correction de mesure, typiquement pour compenser l\x27effet d\x27un bo\xEEtier sur les mesures rendues par le capteur. Il est possible d\x27enregistrer jusqu\x27\xE0 cinq points de correction. Les points de correction doivent \xEAtre fournis en ordre croissant, et dans la plage valide du capteur. Le module effectue automatiquement une interpolation lin\xE9aire de l\x27erreur entre les points sp\xE9cifi\xE9s. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9. </p><p> Pour plus de plus amples possibilit\xE9s d\x27appliquer une surcalibration aux capteurs, veuillez contacter support</p>',par:{rawValues:'tableau de nombres flottants, correspondant aux valeurs brutes rendues par le capteur pour les points de correction.',refValues:'tableau de nombres flottants, correspondant aux valeurs corrig\xE9es d\xE9sir\xE9es pour les points de correction.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Power']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'power.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Power']['get_advertisedValue']={syn:'Retourne la valeur courante du capteur de puissance electrique (pas plus de 6 caract\xE8res).',lib:'power.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante du capteur de puissance electrique (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du capteur de puissance electrique (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Power']['get_cosPhi']={syn:'Retourne le facteur de puissance (rapport entre la puissance r\xE9elle consomm\xE9e, en W, et la puissance apparente fournie, en VA).',lib:'power.get_cosPhi()',pro:'double get_cosPhi()',cmt:'<p>Retourne le facteur de puissance (rapport entre la puissance r\xE9elle consomm\xE9e, en W, et la puissance apparente fournie, en VA).</p>',ret:'une valeur num\xE9rique repr\xE9sentant le facteur de puissance (rapport entre la puissance r\xE9elle consomm\xE9e, en W, et la puissance apparente fournie, en VA)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_COSPHI_INVALID</tt>.'};
doc['Power']['get_currentRawValue']={syn:'Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).',lib:'power.get_currentRawValue()',pro:'double get_currentRawValue()',cmt:'<p>Retourne la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration).</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur brute retourn\xE9e par le capteur (sans arrondi ni calibration)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTRAWVALUE_INVALID</tt>.'};
doc['Power']['get_currentValue']={syn:'Retourne la valeur mesur\xE9e actuelle.',lib:'power.get_currentValue()',pro:'double get_currentValue()',cmt:'<p>Retourne la valeur mesur\xE9e actuelle.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur mesur\xE9e actuelle',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_CURRENTVALUE_INVALID</tt>.'};
doc['Power']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'power.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Power']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'power.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Power']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'power.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Power']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'power.get_powerDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Power']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'power.get_powerId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Power']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'power.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Power']['get_highestValue']={syn:'Retourne la valeur maximale observ\xE9e.',lib:'power.get_highestValue()',pro:'double get_highestValue()',cmt:'<p>Retourne la valeur maximale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur maximale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HIGHESTVALUE_INVALID</tt>.'};
doc['Power']['get_logicalName']={syn:'Retourne le nom logique du capteur de puissance electrique.',lib:'power.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique du capteur de puissance electrique.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de puissance electrique',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Power']['get_lowestValue']={syn:'Retourne la valeur minimale observ\xE9e.',lib:'power.get_lowestValue()',pro:'double get_lowestValue()',cmt:'<p>Retourne la valeur minimale observ\xE9e.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur minimale observ\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOWESTVALUE_INVALID</tt>.'};
doc['Power']['get_meter']={syn:'Retourne la valeur actuelle du compteur d\x27energie, calcul\xE9e par le wattm\xE8tre en int\xE9grant la consommation instantan\xE9e.',lib:'power.get_meter()',pro:'double get_meter()',cmt:'<p>Retourne la valeur actuelle du compteur d\x27energie, calcul\xE9e par le wattm\xE8tre en int\xE9grant la consommation instantan\xE9e. Ce compteur est r\xE9initialis\xE9 \xE0 chaque d\xE9marrage du module.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la valeur actuelle du compteur d\x27energie, calcul\xE9e par le wattm\xE8tre en int\xE9grant la consommation instantan\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_METER_INVALID</tt>.'};
doc['Power']['get_meterTimer']={syn:'Retourne le temps \xE9coul\xE9 depuis la derni\xE8re initilialisation du compteur d\x27\xE9nergie, en secondes ',lib:'power.get_meterTimer()',pro:'int get_meterTimer()',cmt:'<p>Retourne le temps \xE9coul\xE9 depuis la derni\xE8re initilialisation du compteur d\x27\xE9nergie, en secondes</p>',ret:'un entier repr\xE9sentant le temps \xE9coul\xE9 depuis la derni\xE8re initilialisation du compteur d\x27\xE9nergie, en secondes',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_METERTIMER_INVALID</tt>.'};
doc['Power']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'power.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Power']['get_resolution']={syn:'Retourne la r\xE9solution des valeurs mesur\xE9es.',lib:'power.get_resolution()',pro:'double get_resolution()',cmt:'<p>Retourne la r\xE9solution des valeurs mesur\xE9es. La r\xE9solution correspond \xE0 la pr\xE9cision de la repr\xE9sentation num\xE9rique des mesures. Elle n\x27est pas forc\xE9ment identique \xE0 la pr\xE9cision r\xE9elle du capteur.</p>',ret:'une valeur num\xE9rique repr\xE9sentant la r\xE9solution des valeurs mesur\xE9es',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_RESOLUTION_INVALID</tt>.'};
doc['Power']['get_unit']={syn:'Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.',lib:'power.get_unit()',pro:'String get_unit()',cmt:'<p>Retourne l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant l\x27unit\xE9 dans laquelle la valeur mesur\xE9e est exprim\xE9e',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_UNIT_INVALID</tt>.'};
doc['Power']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'power.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Power']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'power.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Power']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'power.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Power']['nextPower']={syn:'Continue l\x27\xE9num\xE9ration des capteurs de puissance electrique commenc\xE9e \xE0 l\x27aide de <tt>yFirstPower()</tt>.',lib:'power.nextPower()',pro:'YPower nextPower()',cmt:'<p>Continue l\x27\xE9num\xE9ration des capteurs de puissance electrique commenc\xE9e \xE0 l\x27aide de <tt>yFirstPower()</tt>.</p>',ret:'un pointeur sur un objet <tt>YPower</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Power']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'power.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Power']['set_highestValue']={syn:'Modifie la m\xE9moire de valeur maximale observ\xE9e.',lib:'power.set_highestValue()',pro:'int set_highestValue(double <span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur maximale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur maximale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Power']['set_logicalName']={syn:'Modifie le nom logique du capteur de puissance electrique.',lib:'power.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du capteur de puissance electrique. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du capteur de puissance electrique'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Power']['set_lowestValue']={syn:'Modifie la m\xE9moire de valeur minimale observ\xE9e.',lib:'power.set_lowestValue()',pro:'int set_lowestValue(double <span id=pn>newval</span>)',cmt:'<p>Modifie la m\xE9moire de valeur minimale observ\xE9e.</p>',par:{newval:'une valeur num\xE9rique repr\xE9sentant la m\xE9moire de valeur minimale observ\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Power']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'power.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
//--- (end of generated code: Power)
//--- (generated code: Display)
doc['Display']={'':{syn:'Interface de la fonction Display',inc:'import com.yoctopuce.YoctoAPI.YDisplay;',cmt:'<p>L\x27interface de contr\xF4le des \xE9crans Yoctopuce est con\xE7ue pour afficher facilement des informations et des images. Le module est capable de g\xE9rer seul la superposition de plusieurs couches graphiques, qui peuvent \xEAtre dessin\xE9es individuellement, sans affichage imm\xE9diat, puis librement positionn\xE9es sur l\x27\xE9cran. Il est aussi capable de rejouer des s\xE9quences de commandes pr\xE9-enregistr\xE9es (animations).</p>'}};
doc['Display']['FindDisplay']={syn:'Permet de retrouver un ecran d\x27apr\xE8s un identifiant donn\xE9.',lib:'YDisplay.FindDisplay()',pro:'YDisplay FindDisplay(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver un ecran d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que l\x27ecran soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YDisplay.isOnline()</tt> pour tester si l\x27ecran est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence l\x27ecran sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YDisplay</tt> qui permet ensuite de contr\xF4ler l\x27ecran.'};
doc['Display']['FirstDisplay']={syn:'Commence l\x27\xE9num\xE9ration des \xE9cran accessibles par la librairie.',lib:'YDisplay.FirstDisplay()',pro:'YDisplay FirstDisplay()',cmt:'<p>Commence l\x27\xE9num\xE9ration des \xE9cran accessibles par la librairie. Utiliser la fonction <tt>YDisplay.nextDisplay()</tt> pour it\xE9rer sur les autres \xE9cran.</p>',ret:'un pointeur sur un objet <tt>YDisplay</tt>, correspondant \xE0 le premier \xE9cran accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de \xE9cran disponibles.'};
doc['Display']['copyLayerContent']={syn:'Copie le contentu d\x27un couche d\x27affichage vers une autre couche.',lib:'display.copyLayerContent()',pro:'int copyLayerContent(int <span id=pn>srcLayerId</span>, int <span id=pn>dstLayerId</span>)',cmt:'<p>Copie le contentu d\x27un couche d\x27affichage vers une autre couche. La couleur et la transparence de tous les pixels de la couche de destination sont chang\xE9s pour correspondre \xE0 la couche source. Cette m\xE9thode modifie le contenu affich\xE9, mais n\x27a aucun effet sur les propri\xE9t\xE9s de l\x27objet layer lui-m\xEAme. Notez que la couche z\xE9ro n\x27a pas de transparence (elle est toujours opaque).</p>',par:{srcLayerId:'l\x27identifiant de la couche d\x27origine (un chiffre parmi 0..layerCount-1)',dstLayerId:'l\x27identifiant de la couche de destination (un chiffre parmi 0..layerCount-1)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'display.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Display']['fade']={syn:'Change la luminosit\xE9 de l\x27\xE9cran en douceur, pour produire un effet de fade-in ou fade-out.',lib:'display.fade()',pro:'int fade(int <span id=pn>brightness</span>, int <span id=pn>duration</span>)',cmt:'<p>Change la luminosit\xE9 de l\x27\xE9cran en douceur, pour produire un effet de fade-in ou fade-out.</p>',par:{brightness:'nouvelle valeur de luminosit\xE9 de l\x27\xE9cran',duration:'dur\xE9e en millisecondes de la transition.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['get_advertisedValue']={syn:'Retourne la valeur courante de l\x27ecran (pas plus de 6 caract\xE8res).',lib:'display.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante de l\x27ecran (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante de l\x27ecran (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Display']['get_brightness']={syn:'Retourne la luminosit\xE9 des leds informatives du module (valeur entre 0 et 100).',lib:'display.get_brightness()',pro:'int get_brightness()',cmt:'<p>Retourne la luminosit\xE9 des leds informatives du module (valeur entre 0 et 100).</p>',ret:'un entier repr\xE9sentant la luminosit\xE9 des leds informatives du module (valeur entre 0 et 100)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_BRIGHTNESS_INVALID</tt>.'};
doc['Display']['get_displayHeight']={syn:'Retourne la hauteur de l\x27\xE9cran, en pixels.',lib:'display.get_displayHeight()',pro:'int get_displayHeight()',cmt:'<p>Retourne la hauteur de l\x27\xE9cran, en pixels.</p>',ret:'un entier repr\xE9sentant la hauteur de l\x27\xE9cran, en pixels',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_DISPLAYHEIGHT_INVALID</tt>.'};
doc['Display']['get_displayLayer']={syn:'Retourne un objet YDisplayLayer utilisable pour dessiner sur la couche d\x27affichage correspondante.',lib:'display.get_displayLayer()',pro:'synchronized YDisplayLayer get_displayLayer(int <span id=pn>layerId</span>)',cmt:'<p>Retourne un objet YDisplayLayer utilisable pour dessiner sur la couche d\x27affichage correspondante. Le contenu n\x27est visible sur l\x27\xE9cran que lorsque la couche est active sur l\x27\xE9cran (et non masqu\xE9e par une couche sup\xE9rieure).</p>',par:{layerId:'l\x27identifiant de la couche d\x27affichage d\xE9sir\xE9e (un chiffre parmi 0..layerCount-1)'},ret:'un objet <tt>YDisplayLayer</tt>',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>null</tt>.'};
doc['Display']['get_displayType']={syn:'Retourne le type de l\x27\xE9cran: monochrome, niveaux de gris ou couleur.',lib:'display.get_displayType()',pro:'int get_displayType()',cmt:'<p>Retourne le type de l\x27\xE9cran: monochrome, niveaux de gris ou couleur.</p>',ret:'une valeur parmi <tt>Y_DISPLAYTYPE_MONO</tt>, <tt>Y_DISPLAYTYPE_GRAY</tt> et <tt>Y_DISPLAYTYPE_RGB</tt> repr\xE9sentant le type de l\x27\xE9cran: monochrome, niveaux de gris ou couleur',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_DISPLAYTYPE_INVALID</tt>.'};
doc['Display']['get_displayWidth']={syn:'Retourne la largeur de l\x27\xE9cran, en pixels.',lib:'display.get_displayWidth()',pro:'int get_displayWidth()',cmt:'<p>Retourne la largeur de l\x27\xE9cran, en pixels.</p>',ret:'un entier repr\xE9sentant la largeur de l\x27\xE9cran, en pixels',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_DISPLAYWIDTH_INVALID</tt>.'};
doc['Display']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'display.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Display']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'display.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Display']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'display.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Display']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'display.get_displayDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Display']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'display.get_displayId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Display']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'display.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Display']['get_layerCount']={syn:'Retourne le nombre des couches affichables disponibles.',lib:'display.get_layerCount()',pro:'int get_layerCount()',cmt:'<p>Retourne le nombre des couches affichables disponibles.</p>',ret:'un entier repr\xE9sentant le nombre des couches affichables disponibles',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LAYERCOUNT_INVALID</tt>.'};
doc['Display']['get_layerHeight']={syn:'Retourne la hauteur des couches affichables, en pixels.',lib:'display.get_layerHeight()',pro:'int get_layerHeight()',cmt:'<p>Retourne la hauteur des couches affichables, en pixels.</p>',ret:'un entier repr\xE9sentant la hauteur des couches affichables, en pixels',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LAYERHEIGHT_INVALID</tt>.'};
doc['Display']['get_layerWidth']={syn:'Retourne la largeur des couches affichables, en pixels.',lib:'display.get_layerWidth()',pro:'int get_layerWidth()',cmt:'<p>Retourne la largeur des couches affichables, en pixels.</p>',ret:'un entier repr\xE9sentant la largeur des couches affichables, en pixels',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LAYERWIDTH_INVALID</tt>.'};
doc['Display']['get_logicalName']={syn:'Retourne le nom logique de l\x27ecran.',lib:'display.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique de l\x27ecran.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27ecran',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Display']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'display.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Display']['get_orientation']={syn:'Retourne l\x27orientation s\xE9lectionn\xE9e pour l\x27\xE9cran.',lib:'display.get_orientation()',pro:'int get_orientation()',cmt:'<p>Retourne l\x27orientation s\xE9lectionn\xE9e pour l\x27\xE9cran.</p>',ret:'une valeur parmi <tt>Y_ORIENTATION_LEFT</tt>, <tt>Y_ORIENTATION_UP</tt>, <tt>Y_ORIENTATION_RIGHT</tt> et <tt>Y_ORIENTATION_DOWN</tt> repr\xE9sentant l\x27orientation s\xE9lectionn\xE9e pour l\x27\xE9cran',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ORIENTATION_INVALID</tt>.'};
doc['Display']['get_powerState']={syn:'Retourne l\x27\xE9tat d\x27activit\xE9 de l\x27\xE9cran.',lib:'display.get_powerState()',pro:'int get_powerState()',cmt:'<p>Retourne l\x27\xE9tat d\x27activit\xE9 de l\x27\xE9cran.</p>',ret:'soit <tt>Y_POWERSTATE_OFF</tt>, soit <tt>Y_POWERSTATE_ON</tt>, selon l\x27\xE9tat d\x27activit\xE9 de l\x27\xE9cran',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_POWERSTATE_INVALID</tt>.'};
doc['Display']['get_startupSeq']={syn:'Retourne le nom de la s\xE9quence \xE0 jouer \xE0 la mise sous tension de l\x27\xE9cran.',lib:'display.get_startupSeq()',pro:'String get_startupSeq()',cmt:'<p>Retourne le nom de la s\xE9quence \xE0 jouer \xE0 la mise sous tension de l\x27\xE9cran.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom de la s\xE9quence \xE0 jouer \xE0 la mise sous tension de l\x27\xE9cran',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_STARTUPSEQ_INVALID</tt>.'};
doc['Display']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'display.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Display']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'display.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Display']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'display.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['newSequence']={syn:'Enclanche l\x27enregistrement de toutes les commandes d\x27affichage suivantes dans une s\xE9quence, qui pourra \xEAtre rejou\xE9e ult\xE9rieurement.',lib:'display.newSequence()',pro:'int newSequence()',cmt:'<p>Enclanche l\x27enregistrement de toutes les commandes d\x27affichage suivantes dans une s\xE9quence, qui pourra \xEAtre rejou\xE9e ult\xE9rieurement. Le nom de la s\xE9quence sera donn\xE9 au moment de l\x27appel \xE0 <tt>saveSequence()</tt>, une fois la s\xE9quence termin\xE9e.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['nextDisplay']={syn:'Continue l\x27\xE9num\xE9ration des \xE9cran commenc\xE9e \xE0 l\x27aide de <tt>yFirstDisplay()</tt>.',lib:'display.nextDisplay()',pro:'YDisplay nextDisplay()',cmt:'<p>Continue l\x27\xE9num\xE9ration des \xE9cran commenc\xE9e \xE0 l\x27aide de <tt>yFirstDisplay()</tt>.</p>',ret:'un pointeur sur un objet <tt>YDisplay</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Display']['pauseSequence']={syn:'Attend pour la dur\xE9e sp\xE9cifi\xE9e (en millisecondes) avant de jouer les commandes suivantes de la s\xE9quence active.',lib:'display.pauseSequence()',pro:'int pauseSequence(int <span id=pn>delay_ms</span>)',cmt:'<p>Attend pour la dur\xE9e sp\xE9cifi\xE9e (en millisecondes) avant de jouer les commandes suivantes de la s\xE9quence active. Cette m\xE9thode peut \xEAtre utilis\xE9e lors de l\x27enregistrement d\x27une s\xE9quence d\x27affichage, pour ins\xE9rer une attente mesur\xE9e lors de l\x27ex\xE9cution (mais sans effet imm\xE9diat). Cette m\xE9thode peut aussi \xEAtre appel\xE9e dynamiquement pendant l\x27ex\xE9cution d\x27une s\xE9quence enregistr\xE9e, pour suspendre temporairement ou reprendre l\x27ex\xE9cution. Pour annuler une attente, appelez simplement la m\xE9thode avec une attente de z\xE9ro.</p>',par:{delay_ms:'la dur\xE9e de l\x27attente, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['playSequence']={syn:'Joue une s\xE9quence d\x27affichage pr\xE9alablement enregistr\xE9e \xE0 l\x27aide des m\xE9thodes <tt>newSequence()</tt> et <tt>saveSequence()</tt>.',lib:'display.playSequence()',pro:'int playSequence(String <span id=pn>sequenceName</span>)',cmt:'<p>Joue une s\xE9quence d\x27affichage pr\xE9alablement enregistr\xE9e \xE0 l\x27aide des m\xE9thodes <tt>newSequence()</tt> et <tt>saveSequence()</tt>.</p>',par:{sequenceName:'le nom de la nouvelle s\xE9quence cr\xE9\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'display.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Display']['resetAll']={syn:'Efface le contenu de l\x27\xE9cran et remet toutes les couches \xE0 leur \xE9tat initial.',lib:'display.resetAll()',pro:'int resetAll()',cmt:'<p>Efface le contenu de l\x27\xE9cran et remet toutes les couches \xE0 leur \xE9tat initial.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['saveSequence']={syn:'Termine l\x27enregistrement d\x27une s\xE9quence et la sauvegarde sur la m\xE9moire interne de l\x27\xE9cran, sous le nom choisi.',lib:'display.saveSequence()',pro:'int saveSequence(String <span id=pn>sequenceName</span>)',cmt:'<p>Termine l\x27enregistrement d\x27une s\xE9quence et la sauvegarde sur la m\xE9moire interne de l\x27\xE9cran, sous le nom choisi. La s\xE9quence peut \xEAtre rejou\xE9e ult\xE9rieurement \xE0 l\x27aide de la m\xE9thode <tt>playSequence()</tt>.</p>',par:{sequenceName:'le nom de la nouvelle s\xE9quence cr\xE9\xE9e'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['set_brightness']={syn:'Modifie la luminosit\xE9de l\x27\xE9cran.',lib:'display.set_brightness()',pro:'int set_brightness(int <span id=pn>newval</span>)',cmt:'<p>Modifie la luminosit\xE9de l\x27\xE9cran. Le param\xEAtre est une valeur entre 0 et 100. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'un entier repr\xE9sentant la luminosit\xE9de l\x27\xE9cran'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['set_logicalName']={syn:'Modifie le nom logique de l\x27ecran.',lib:'display.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique de l\x27ecran. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique de l\x27ecran'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['set_orientation']={syn:'Modifie l\x27orientation de l\x27\xE9cran.',lib:'display.set_orientation()',pro:'int set_orientation(int <span id=pn>newval</span>)',cmt:'<p>Modifie l\x27orientation de l\x27\xE9cran. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une valeur parmi <tt>Y_ORIENTATION_LEFT</tt>, <tt>Y_ORIENTATION_UP</tt>, <tt>Y_ORIENTATION_RIGHT</tt> et <tt>Y_ORIENTATION_DOWN</tt> repr\xE9sentant l\x27orientation de l\x27\xE9cran'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['set_powerState']={syn:'Modifie l\x27\xE9tat d\x27activit\xE9 de l\x27\xE9cran.',lib:'display.set_powerState()',pro:'int set_powerState(int <span id=pn>newval</span>)',cmt:'<p>Modifie l\x27\xE9tat d\x27activit\xE9 de l\x27\xE9cran.</p>',par:{newval:'soit <tt>Y_POWERSTATE_OFF</tt>, soit <tt>Y_POWERSTATE_ON</tt>, selon l\x27\xE9tat d\x27activit\xE9 de l\x27\xE9cran'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['set_startupSeq']={syn:'Modifie le nom de la s\xE9quence \xE0 jouer \xE0 la mise sous tension de l\x27\xE9cran.',lib:'display.set_startupSeq()',pro:'int set_startupSeq(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom de la s\xE9quence \xE0 jouer \xE0 la mise sous tension de l\x27\xE9cran. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom de la s\xE9quence \xE0 jouer \xE0 la mise sous tension de l\x27\xE9cran'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'display.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Display']['stopSequence']={syn:'Arr\xEAte imm\xE9diatement la s\xE9quence d\x27affichage actuellement jou\xE9e sur l\x27\xE9cran.',lib:'display.stopSequence()',pro:'int stopSequence()',cmt:'<p>Arr\xEAte imm\xE9diatement la s\xE9quence d\x27affichage actuellement jou\xE9e sur l\x27\xE9cran. L\x27affichage est laiss\xE9 tel quel.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['swapLayerContent']={syn:'Permute le contentu de deux couches d\x27affichage.',lib:'display.swapLayerContent()',pro:'int swapLayerContent(int <span id=pn>layerIdA</span>, int <span id=pn>layerIdB</span>)',cmt:'<p>Permute le contentu de deux couches d\x27affichage. La couleur et la transparence de tous les pixels des deux couches sont permut\xE9es. Cette m\xE9thode modifie le contenu affich\xE9, mais n\x27a aucun effet sur les propri\xE9t\xE9s de l\x27objet layer lui-m\xEAme. En particulier, la visibilit\xE9 des deux couches reste inchang\xE9e. Cela permet d\x27impl\xE9menter tr\xE8s efficacement un affichage par double-buffering, en utilisant une couche cach\xE9e et une couche visible. Notez que la couche z\xE9ro n\x27a pas de transparence (elle est toujours opaque).</p>',par:{layerIdA:'l\x27identifiant de la premi\xE8re couche (un chiffre parmi 0..layerCount-1)',layerIdB:'l\x27identifiant de la deuxi\xE8me couche (un chiffre parmi 0..layerCount-1)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Display']['upload']={syn:'T\xE9l\xE9charge un contenu arbitraire (par exemple une image GIF) vers le syst\xE8me de fichier de l\x27\xE9cran, au chemin d\x27acc\xE8s sp\xE9cifi\xE9.',lib:'display.upload()',pro:'int upload(String <span id=pn>pathname</span>)',cmt:'<p>T\xE9l\xE9charge un contenu arbitraire (par exemple une image GIF) vers le syst\xE8me de fichier de l\x27\xE9cran, au chemin d\x27acc\xE8s sp\xE9cifi\xE9. Si un fichier existe d\xE9j\xE0 pour le m\xEAme chemin d\x27acc\xE8s, son contenu est remplac\xE9.</p>',par:{pathname:'nom complet du fichier, y compris le chemin d\x27acc\xE8s.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Display)
//--- (generated code: DisplayLayer)
doc['DisplayLayer']={'':{syn:'Interface des objets DisplayLayer',inc:'import com.yoctopuce.YoctoAPI.YDisplay;',cmt:'<p>Un DisplayLayer est une couche de contenu affichable (images, texte, etc.). Le contenu n\x27est visible sur l\x27\xE9cran que lorsque la couche est active sur l\x27\xE9cran (et non masqu\xE9e par une couche sup\xE9rieure).</p>'}};
doc['DisplayLayer']['clear']={syn:'Efface tout le contenu de la couche de dessin, de sorte \xE0 ce qu\x27elle redevienne enti\xE8rement transparente.',lib:'displaylayer.clear()',pro:'int clear()',cmt:'<p>Efface tout le contenu de la couche de dessin, de sorte \xE0 ce qu\x27elle redevienne enti\xE8rement transparente. Cette m\xE9thode ne change pas les r\xE9glages de le couche. Si vous d\xE9sirez remettre la couche dans son \xE9tat initial, utilisez plut\xF4t la m\xE9thode <tt>reset()</tt>.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['clearConsole']={syn:'Efface le contenu de la zone de console, et repositionne le curseur de la console en haut \xE0 gauche de la zone.',lib:'displaylayer.clearConsole()',pro:'int clearConsole()',cmt:'<p>Efface le contenu de la zone de console, et repositionne le curseur de la console en haut \xE0 gauche de la zone.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['consoleOut']={syn:'Affiche un message dans la zone de console, et d\xE9place le curseur de la console \xE0 la fin du texte.',lib:'displaylayer.consoleOut()',pro:'int consoleOut(String <span id=pn>text</span>)',cmt:'<p>Affiche un message dans la zone de console, et d\xE9place le curseur de la console \xE0 la fin du texte. Le curseur revient automatiquement en d\xE9but de ligne suivante lorsqu\x27un saut de ligne est rencontr\xE9, ou lorsque la marge droite est atteinte. Lorsque le texte \xE0 afficher s\x27appr\xEAte \xE0 d\xE9passer la marge inf\xE9rieure, le contenu de la zone de console est automatiquement d\xE9cal\xE9 vers le haut afin de laisser la place \xE0 la nouvelle ligne de texte.</p>',par:{text:'le message \xE0 afficher'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawBar']={syn:'Dessine un rectangle plein \xE0 une position sp\xE9cifi\xE9e.',lib:'displaylayer.drawBar()',pro:'int drawBar(int <span id=pn>x1</span>, int <span id=pn>y1</span>, int <span id=pn>x2</span>, int <span id=pn>y2</span>)',cmt:'<p>Dessine un rectangle plein \xE0 une position sp\xE9cifi\xE9e.</p>',par:{x1:'la distance en pixels depuis la gauche de la couche jusqu\x27au bord gauche du rectangle',y1:'la distance en pixels depuis le haut de la couche jusqu\x27au bord sup\xE9rieur du rectangle',x2:'la distance en pixels depuis la gauche de la couche jusqu\x27au bord droit du rectangle',y2:'la distance en pixels depuis le haut de la couche jusqu\x27au bord inf\xE9rieur du rectangle'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawBitmap']={syn:'Dessine un bitmap \xE0 la position sp\xE9cifi\xE9e de la couche.',lib:'displaylayer.drawBitmap()',pro:'int drawBitmap(int <span id=pn>x</span>, int <span id=pn>y</span>, int <span id=pn>w</span>, int <span id=pn>bgcol</span>)',cmt:'<p>Dessine un bitmap \xE0 la position sp\xE9cifi\xE9e de la couche. Le bitmap est pass\xE9 sous forme d\x27un objet binaire, o\xF9 chaque bit correspond \xE0 un pixel, de gauche \xE0 droite et de haut en bas. Le bit de poids fort de chaque octet correspond au pixel de gauche, et le bit de poids faible au pixel le plus \xE0 droite. Les bits \xE0 1 sont dessin\xE9s avec la couleur active de la couche. Les bits \xE0 0 avec la couleur de fond sp\xE9cifi\xE9e, sauf si la valeur -1 a \xE9t\xE9 choisie, auquel cas ils ne sont pas dessin\xE9s (ils sont consid\xE9r\xE9s comme transparents). Chaque ligne commence sur un nouvel octet. La hauteur du bitmap est donn\xE9e implicitement par la taille de l\x27objet binaire.</p>',par:{x:'la distance en pixels depuis la gauche de la couche jusqu\x27au bord gauche du bitmap',y:'la distance en pixels depuis le haut de la couche jusqu\x27au bord sup\xE9rieur du bitmap',w:'la largeur du bitmap, en pixels',bgcol:'le niveau de gris \xE0 utiliser pour les bits \xE0 z\xE9ro (0 = noir, 255 = blanc), ou -1 pour lasser les pixels inchang\xE9s'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawCircle']={syn:'Dessine un cercle vide \xE0 une position sp\xE9cifi\xE9e.',lib:'displaylayer.drawCircle()',pro:'int drawCircle(int <span id=pn>x</span>, int <span id=pn>y</span>, int <span id=pn>r</span>)',cmt:'<p>Dessine un cercle vide \xE0 une position sp\xE9cifi\xE9e.</p>',par:{x:'la distance en pixels depuis la gauche de la couche jusqu\x27au centre du cercle',y:'la distance en pixels depuis le haut de la couche jusqu\x27au centre du cercle',r:'le rayon du cercle, en pixels'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawDisc']={syn:'Dessine un disque plein \xE0 une position sp\xE9cifi\xE9e.',lib:'displaylayer.drawDisc()',pro:'int drawDisc(int <span id=pn>x</span>, int <span id=pn>y</span>, int <span id=pn>r</span>)',cmt:'<p>Dessine un disque plein \xE0 une position sp\xE9cifi\xE9e.</p>',par:{x:'la distance en pixels depuis la gauche de la couche jusqu\x27au centre du disque',y:'la distance en pixels depuis le haut de la couche jusqu\x27au centre du disque',r:'le rayon du disque, en pixels'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawImage']={syn:'Dessine une image GIF \xE0 la position sp\xE9cifi\xE9e de la couche.',lib:'displaylayer.drawImage()',pro:'int drawImage(int <span id=pn>x</span>, int <span id=pn>y</span>, String <span id=pn>imagename</span>)',cmt:'<p>Dessine une image GIF \xE0 la position sp\xE9cifi\xE9e de la couche. L\x27image GIF doit avoir \xE9t\xE9 pr\xE9alablement pr\xE9charg\xE9e dans la m\xE9moire du module. Si vous rencontrez des probl\xE8mes \xE0 l\x27utilisation d\x27une image bitmap, consultez les logs du module pour voir si vous n\x27y trouvez pas un message \xE0 propos d\x27un fichier d\x27image manquant ou d\x27un format de fichier invalide.</p>',par:{x:'la distance en pixels depuis la gauche de la couche jusqu\x27au bord gauche de l\x27image',y:'la distance en pixels depuis le haut de la couche jusqu\x27au bord sup\xE9rieur de l\x27image',imagename:'le nom du fichier GIF \xE0 afficher'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawPixel']={syn:'Dessine un pixel unique \xE0 une position sp\xE9cifi\xE9e.',lib:'displaylayer.drawPixel()',pro:'int drawPixel(int <span id=pn>x</span>, int <span id=pn>y</span>)',cmt:'<p>Dessine un pixel unique \xE0 une position sp\xE9cifi\xE9e.</p>',par:{x:'la distance en pixels depuis la gauche de la couche',y:'la distance en pixels depuis le haut de la couche'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawRect']={syn:'Dessine un rectangle vide \xE0 une position sp\xE9cifi\xE9e.',lib:'displaylayer.drawRect()',pro:'int drawRect(int <span id=pn>x1</span>, int <span id=pn>y1</span>, int <span id=pn>x2</span>, int <span id=pn>y2</span>)',cmt:'<p>Dessine un rectangle vide \xE0 une position sp\xE9cifi\xE9e.</p>',par:{x1:'la distance en pixels depuis la gauche de la couche jusqu\x27au bord gauche du rectangle',y1:'la distance en pixels depuis le haut de la couche jusqu\x27au bord sup\xE9rieur du rectangle',x2:'la distance en pixels depuis la gauche de la couche jusqu\x27au bord droit du rectangle',y2:'la distance en pixels depuis le haut de la couche jusqu\x27au bord inf\xE9rieur du rectangle'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['drawText']={syn:'Affiche un texte \xE0 la position sp\xE9cifi\xE9e de la couche.',lib:'displaylayer.drawText()',pro:'int drawText(int <span id=pn>x</span>, int <span id=pn>y</span>, ALIGN <span id=pn>anchor</span>, String <span id=pn>text</span>)',cmt:'<p>Affiche un texte \xE0 la position sp\xE9cifi\xE9e de la couche. Le point du texte qui sera align\xE9 sur la position sp\xE9cifi\xE9e est appel\xE9 point d\x27ancrage, et peut \xEAtre choisi parmi plusieurs options.</p>',par:{x:'la distance en pixels depuis la gauche de la couche jusqu\x27au point d\x27ancrage du texte',y:'la distance en pixels depuis le haut de la couche jusqu\x27au point d\x27ancrage du texte',anchor:'le point d\x27ancrage du texte, choisi parmi l\x27\xE9num\xE9ration <tt>Y_ALIGN</tt>: <tt>Y_ALIGN_TOP_LEFT</tt>, <tt>Y_ALIGN_CENTER_LEFT</tt>, <tt>Y_ALIGN_BASELINE_LEFT</tt>, <tt>Y_ALIGN_BOTTOM_LEFT</tt>, <tt>Y_ALIGN_TOP_CENTER</tt>, <tt>Y_ALIGN_CENTER</tt>, <tt>Y_ALIGN_BASELINE_CENTER</tt>, <tt>Y_ALIGN_BOTTOM_CENTER</tt>, <tt>Y_ALIGN_TOP_DECIMAL</tt>, <tt>Y_ALIGN_CENTER_DECIMAL</tt>, <tt>Y_ALIGN_BASELINE_DECIMAL</tt>, <tt>Y_ALIGN_BOTTOM_DECIMAL</tt>, <tt>Y_ALIGN_TOP_RIGHT</tt>, <tt>Y_ALIGN_CENTER_RIGHT</tt>, <tt>Y_ALIGN_BASELINE_RIGHT</tt>, <tt>Y_ALIGN_BOTTOM_RIGHT</tt>.',text:'le texte \xE0 afficher'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['get_display']={syn:'Retourne l\x27YDisplay parent.',lib:'displaylayer.get_display()',pro:'YDisplay get_display()',cmt:'<p>Retourne l\x27YDisplay parent. Retourne l\x27objet YDisplay parent du YDisplayLayer courant.</p>',ret:'un objet <tt>YDisplay</tt>'};
doc['DisplayLayer']['hide']={syn:'Cache la couche de dessin.',lib:'displaylayer.hide()',pro:'int hide()',cmt:'<p>Cache la couche de dessin. L\x27etat de la couche est pr\xE9serv\xE9, mais la couche ne sera plus plus affich\xE9s \xE0 l\x27\xE9cran jusqu\x27au prochain appel \xE0 <tt>unhide()</tt>. Le fait de cacher la couche am\xE9liore les performances de toutes les primitives d\x27affichage, car il \xE9vite de consacrer inutilement des cycles de calcul \xE0 afficher les \xE9tats interm\xE9diaires (technique de double-buffering).</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['lineTo']={syn:'Dessine une ligne depuis le point de dessin courant jusqu\x27\xE0 la position sp\xE9cifi\xE9e.',lib:'displaylayer.lineTo()',pro:'int lineTo(int <span id=pn>x</span>, int <span id=pn>y</span>)',cmt:'<p>Dessine une ligne depuis le point de dessin courant jusqu\x27\xE0 la position sp\xE9cifi\xE9e. Le pixel final sp\xE9cifi\xE9 est inclus dans la ligne dessin\xE9e. Le point de dessin courant est d\xE9plac\xE9 \xE0 au point final de la ligne.</p>',par:{x:'la distance en pixels depuis la gauche de la couche jusqu\x27au point final',y:'la distance en pixels depuis le haut de la couche jusqu\x27au point final'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['moveTo']={syn:'D\xE9place le point de dessin courant de cette couche \xE0 la position sp\xE9cifi\xE9e.',lib:'displaylayer.moveTo()',pro:'int moveTo(int <span id=pn>x</span>, int <span id=pn>y</span>)',cmt:'<p>D\xE9place le point de dessin courant de cette couche \xE0 la position sp\xE9cifi\xE9e.</p>',par:{x:'la distance en pixels depuis la gauche de la couche de dessin',y:'la distance en pixels depuis le haut de la couche de dessin'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['reset']={syn:'Remet la couche de dessin dans son \xE9tat initial (enti\xE8rement transparente, r\xE9glages par d\xE9faut).',lib:'displaylayer.reset()',pro:'int reset()',cmt:'<p>Remet la couche de dessin dans son \xE9tat initial (enti\xE8rement transparente, r\xE9glages par d\xE9faut). R\xE9initialise la position du point de dessin courant au coin sup\xE9rieur gauche, et la couleur de dessin \xE0 la valeur la plus lumineuse. Si vous d\xE9sirez simplement effacer le contenu de la couche, utilisez plut\xF4t la m\xE9thode <tt>clear()</tt>.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['selectColorPen']={syn:'Choisit la couleur du crayon \xE0 utiliser pour tous les appels suivants aux fonctions de dessin.',lib:'displaylayer.selectColorPen()',pro:'int selectColorPen(int <span id=pn>color</span>)',cmt:'<p>Choisit la couleur du crayon \xE0 utiliser pour tous les appels suivants aux fonctions de dessin. La couleur est fournie sous forme de couleur RGB. Pour les \xE9crans monochromes ou en niveaux de gris, la couleur est automatiquement ramen\xE9e dans les valeurs permises.</p>',par:{color:'la couleur RGB d\xE9sir\xE9e (sous forme d\x27entier 24 bits)'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['selectEraser']={syn:'Choisit une gomme plut\xF4t qu\x27un crayon pour tous les appels suivants aux fonctions de dessin, \xE0 l\x27exception de l\x27affichage de texte et de copie d\x27images bitmaps.',lib:'displaylayer.selectEraser()',pro:'int selectEraser()',cmt:'<p>Choisit une gomme plut\xF4t qu\x27un crayon pour tous les appels suivants aux fonctions de dessin, \xE0 l\x27exception de l\x27affichage de texte et de copie d\x27images bitmaps. Tous les points dessin\xE9s \xE0 la gomme redeviennent transparents (comme ils l\x27\xE9taient lorsque la couche \xE9tait vide), rendant ainsi visibles les couches inf\xE9rieures.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['selectFont']={syn:'S\xE9lectionne la police de caract\xE8res \xE0 utiliser pour les fonctions d\x27affichage de texte suivantes.',lib:'displaylayer.selectFont()',pro:'int selectFont(String <span id=pn>fontname</span>)',cmt:'<p>S\xE9lectionne la police de caract\xE8res \xE0 utiliser pour les fonctions d\x27affichage de texte suivantes. La police est sp\xE9cifi\xE9e par le nom de son fichier. Vous pouvez utiliser l\x27une des polices pr\xE9d\xE9finies dans le module, ou une autre police que vous avez pr\xE9alablement pr\xE9charg\xE9 dans la m\xE9moire du module. Si vous rencontrez des probl\xE8mes \xE0 l\x27utilisation d\x27une police de caract\xE8res, consultez les logs du module pour voir si vous n\x27y trouvez pas un message \xE0 propos d\x27un fichier de police manquant ou d\x27un format de fichier invalide.</p>',par:{fontname:'le nom du fichier d\xE9finissant la police de caract\xE8res'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['selectGrayPen']={syn:'Choisit le niveau de gris \xE0 utiliser pour tous les appels suivants aux fonctions de dessin.',lib:'displaylayer.selectGrayPen()',pro:'int selectGrayPen(int <span id=pn>graylevel</span>)',cmt:'<p>Choisit le niveau de gris \xE0 utiliser pour tous les appels suivants aux fonctions de dessin. Le niveau de gris est fourni sous forme d\x27un chiffre allant de 0 (noir) \xE0 255 (blanc, ou la couleur la plus claire de l\x27\xE9cran, quelle qu\x27elle soit). Pour les \xE9crans monochromes (sans niveaux de gris), tout valeur inf\xE9rieure \xE0 128 conduit \xE0 un point noir, et toue valeur sup\xE9rieure ou \xE9gale \xE0 128 devient un point lumineux.</p>',par:{graylevel:'le niveau de gris d\xE9sir\xE9, de 0 \xE0 255'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['setAntialiasingMode']={syn:'Active ou d\xE9sactive l\x27anti-aliasing pour tracer les lignes et les cercles.',lib:'displaylayer.setAntialiasingMode()',pro:'int setAntialiasingMode(boolean <span id=pn>mode</span>)',cmt:'<p>Active ou d\xE9sactive l\x27anti-aliasing pour tracer les lignes et les cercles. L\x27anti-aliasing est att\xE9nue la pixelisation des images lorsqu\x27on regarde l\x27\xE9cran depuis une distance suffisante, mais peut aussi donner parfois une impression de flou lorsque l\x27\xE9cran est regard\xE9 de tr\xE8s pr\xE8s. Au final, c\x27est un choix esth\xE9tique qui vous revient. L\x27anti-aliasing est activ\xE9 par d\xE9faut pour les \xE9crans en niveaux de gris et les \xE9crans couleurs, mais vous pouvez le d\xE9sactiver si vous pr\xE9f\xE9rez. Ce r\xE9glage n\x27a pas d\x27effet sur les \xE9crans monochromes.</p>',par:{mode:'<t>true</t> pour activer l\x27antialiasing, <t>false</t> pour le d\xE9sactiver.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['setConsoleBackground']={syn:'Configure la couleur de fond utilis\xE9e par la fonction <tt>clearConsole</tt> et par le d\xE9filement automatique de la console.',lib:'displaylayer.setConsoleBackground()',pro:'int setConsoleBackground(int <span id=pn>bgcol</span>)',cmt:'<p>Configure la couleur de fond utilis\xE9e par la fonction <tt>clearConsole</tt> et par le d\xE9filement automatique de la console.</p>',par:{bgcol:'le niveau de gris \xE0 utiliser pour le fond lors de d\xE9filement (0 = noir, 255 = blanc), ou -1 pour un fond transparent'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['setConsoleMargins']={syn:'Configure les marges d\x27affichage pour la fonction <tt>consoleOut</tt>.',lib:'displaylayer.setConsoleMargins()',pro:'int setConsoleMargins(int <span id=pn>x1</span>, int <span id=pn>y1</span>, int <span id=pn>x2</span>, int <span id=pn>y2</span>)',cmt:'<p>Configure les marges d\x27affichage pour la fonction <tt>consoleOut</tt>.</p>',par:{x1:'la distance en pixels depuis la gauche de la couche jusqu\x27\xE0 la marge gauche',y1:'la distance en pixels depuis le haut de la couche jusqu\x27\xE0 la marge sup\xE9rieure',x2:'la distance en pixels depuis la gauche de la couche jusqu\x27\xE0 la marge droite',y2:'la distance en pixels depuis le haut de la couche jusqu\x27\xE0 la marge inf\xE9rieure'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['setConsoleWordWrap']={syn:'Configure le mode de retour \xE0 la ligne utilis\xE9 par la fonction <tt>consoleOut</tt>.',lib:'displaylayer.setConsoleWordWrap()',pro:'int setConsoleWordWrap(boolean <span id=pn>wordwrap</span>)',cmt:'<p>Configure le mode de retour \xE0 la ligne utilis\xE9 par la fonction <tt>consoleOut</tt>.</p>',par:{wordwrap:'<tt>true</tt> pour retourner \xE0 la ligne entre les mots seulements, <tt>false</tt> pour retourner \xE0 l\x27extr\xEAme droite de chaque ligne.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['setLayerPosition']={syn:'D\xE9place la position de la couche de dessin par rapport au coin sup\xE9rieur gauche de l\x27\xE9cran.',lib:'displaylayer.setLayerPosition()',pro:'int setLayerPosition(int <span id=pn>x</span>, int <span id=pn>y</span>, int <span id=pn>scrollTime</span>)',cmt:'<p>D\xE9place la position de la couche de dessin par rapport au coin sup\xE9rieur gauche de l\x27\xE9cran. Lorsqu\x27une dur\xE9e de d\xE9filement est configur\xE9e, la position d\x27affichage de la couche est automatiquement mise \xE0 jour durant les millisecondes suivantes pour animer le d\xE9placement.</p>',par:{x:'la distance en pixels depuis la gauche de l\x27\xE9cran jusqu\x27\xE0 l\x27origine de la couche.',y:'la distance en pixels depuis le haut de l\x27\xE9cran jusqu\x27\xE0 l\x27origine de la couche.',scrollTime:'dur\xE9e en millisecondes du d\xE9placement, ou 0 si le d\xE9placement doit \xEAtre imm\xE9diat.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['DisplayLayer']['unhide']={syn:'Affiche la couche.',lib:'displaylayer.unhide()',pro:'int unhide()',cmt:'<p>Affiche la couche. Affiche a nouveau la couche apr\xE8s la command hide.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: DisplayLayer)
//--- (generated code: Files)
doc['Files']={'':{syn:'Interface de la fonction Files',inc:'import com.yoctopuce.YoctoAPI.YFiles;',cmt:'<p>L\x27interface de stockage de fichiers permet de stocker des fichiers sur certains modules, par exemple pour personnaliser un service web (dans le cas d\x27un module connect\xE9 au r\xE9seau) ou pour ajouter un police de caract\xE8res (dans le cas d\x27un module d\x27affichage).</p>'}};
doc['Files']['FindFiles']={syn:'Permet de retrouver un syst\xE8me de fichier d\x27apr\xE8s un identifiant donn\xE9.',lib:'YFiles.FindFiles()',pro:'YFiles FindFiles(String <span id=pn>func</span>)',cmt:'<p>Permet de retrouver un syst\xE8me de fichier d\x27apr\xE8s un identifiant donn\xE9. L\x27identifiant peut \xEAtre sp\xE9cifi\xE9 sous plusieurs formes:<br> <ul> <li>NomLogiqueFonction</li> <li>NoSerieModule.IdentifiantFonction</li> <li>NoSerieModule.NomLogiqueFonction</li> <li>NomLogiqueModule.IdentifiantMat\xE9riel</li> <li>NomLogiqueModule.NomLogiqueFonction</li> </ul> Cette fonction n\x27exige pas que le syst\xE8me de fichier soit en ligne au moment ou elle est appel\xE9e, l\x27objet retourn\xE9 sera n\xE9anmoins valide. Utiliser la m\xE9thode <tt>YFiles.isOnline()</tt> pour tester si le syst\xE8me de fichier est utilisable \xE0 un moment donn\xE9. En cas d\x27ambigu\xEFt\xE9 lorsqu\x27on fait une recherche par nom logique, aucune erreur ne sera notifi\xE9e: la premi\xE8re instance trouv\xE9e sera renvoy\xE9e. La recherche se fait d\x27abord par nom mat\xE9riel, puis par nom logique.</p>',par:{func:'une cha\xEEne de caract\xE8res qui r\xE9f\xE9rence le syst\xE8me de fichier sans ambigu\xEFt\xE9'},ret:'un objet de classe <tt>YFiles</tt> qui permet ensuite de contr\xF4ler le syst\xE8me de fichier.'};
doc['Files']['FirstFiles']={syn:'Commence l\x27\xE9num\xE9ration des syst\xE8me de fichier accessibles par la librairie.',lib:'YFiles.FirstFiles()',pro:'YFiles FirstFiles()',cmt:'<p>Commence l\x27\xE9num\xE9ration des syst\xE8me de fichier accessibles par la librairie. Utiliser la fonction <tt>YFiles.nextFiles()</tt> pour it\xE9rer sur les autres syst\xE8me de fichier.</p>',ret:'un pointeur sur un objet <tt>YFiles</tt>, correspondant \xE0 le premier syst\xE8me de fichier accessible en ligne, ou <tt>null</tt> si il n\x27y a pas de syst\xE8me de fichier disponibles.'};
doc['Files']['describe']={syn:'Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>.',lib:'files.describe()',pro:'String describe()',cmt:'<p>Retourne un court texte d\xE9crivant la fonction au format <tt>TYPE(NAME)=SERIAL&#46;FUNCTIONID</tt>. Plus pr\xE9cis\xE9ment, <tt>TYPE</tt> correspond au type de fonction, <tt>NAME</tt> correspond au nom utils\xE9 lors du premier acc\xE8s a la fonction, <tt>SERIAL</tt> correspond au num\xE9ro de s\xE9rie du module si le module est connect\xE9, ou <tt>\x22unresolved\x22</tt> sinon, et <tt>FUNCTIONID</tt> correspond \xE0 l\x27identifiant mat\xE9riel de la fonction si le module est connect\xE9. Par exemple, La methode va retourner <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt> si le module est d\xE9j\xE0 connect\xE9 ou <tt>Relay(BadCustomeName.relay1)=unresolved</tt> si le module n\x27est pas d\xE9j\xE0 connect\xE9. Cette methode ne declenche aucune transaction USB ou TCP et peut donc \xEAtre utilis\xE9 dans un debuggeur.</p>',ret:'une cha\xEEne de caract\xE8res d\xE9crivant la fonction (ex: <tt>Relay(MyCustomName.relay1)=RELAYLO1-123456.relay1</tt>)'};
doc['Files']['format_fs']={syn:'R\xE9tabli le syst\xE8me de fichier dans on \xE9tat original, d\xE9fragment\xE9.',lib:'files.format_fs()',pro:'int format_fs()',cmt:'<p>R\xE9tabli le syst\xE8me de fichier dans on \xE9tat original, d\xE9fragment\xE9. enti\xE8rement vide. Tous les fichiers pr\xE9c\xE9demment charg\xE9s sont irr\xE9m\xE9diablement effac\xE9s.</p>',ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Files']['get_advertisedValue']={syn:'Retourne la valeur courante du syst\xE8me de fichier (pas plus de 6 caract\xE8res).',lib:'files.get_advertisedValue()',pro:'String get_advertisedValue()',cmt:'<p>Retourne la valeur courante du syst\xE8me de fichier (pas plus de 6 caract\xE8res).</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant la valeur courante du syst\xE8me de fichier (pas plus de 6 caract\xE8res)',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_ADVERTISEDVALUE_INVALID</tt>.'};
doc['Files']['get_errorMessage']={syn:'Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'files.get_errorMessage()',pro:'String get_errorMessage()',cmt:'<p>Retourne le message correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'une cha\xEEne de caract\xE8res correspondant au message de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Files']['get_errorType']={syn:'Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction.',lib:'files.get_errorType()',pro:'int get_errorType()',cmt:'<p>Retourne le code d\x27erreur correspondant \xE0 la derni\xE8re erreur survenue lors de l\x27utilisation de la fonction. Cette m\xE9thode est principalement utile lorsque la librairie Yoctopuce est utilis\xE9e en d\xE9sactivant la gestion des exceptions.</p>',ret:'un nombre correspondant au code de la derni\xE8re erreur qui s\x27est produit lors de l\x27utilisation de la fonction'};
doc['Files']['get_filesCount']={syn:'Retourne le nombre de fichiers pr\xE9sents dans le syst\xE8me de fichier.',lib:'files.get_filesCount()',pro:'int get_filesCount()',cmt:'<p>Retourne le nombre de fichiers pr\xE9sents dans le syst\xE8me de fichier.</p>',ret:'un entier repr\xE9sentant le nombre de fichiers pr\xE9sents dans le syst\xE8me de fichier',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FILESCOUNT_INVALID</tt>.'};
doc['Files']['get_freeSpace']={syn:'Retourne l\x27espace disponible dans le syst\xE8me de fichier pour charger des nouveaux fichiers, en octets.',lib:'files.get_freeSpace()',pro:'int get_freeSpace()',cmt:'<p>Retourne l\x27espace disponible dans le syst\xE8me de fichier pour charger des nouveaux fichiers, en octets.</p>',ret:'un entier repr\xE9sentant l\x27espace disponible dans le syst\xE8me de fichier pour charger des nouveaux fichiers, en octets',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FREESPACE_INVALID</tt>.'};
doc['Files']['get_friendlyName']={syn:'Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>.',lib:'files.get_friendlyName()',pro:'String get_friendlyName()',cmt:'<p>Retourne un identifiant global de la fonction au format <tt>NOM_MODULE&#46;NOM_FONCTION</tt>. Le cha\xEEne retourn\xE9e utilise soit les noms logiques du module et de la fonction si ils sont d\xE9finis, soit respectivement le num\xE9ro de s\xE9rie du module et l\x27identifant mat\xE9riel de la fonction (par exemple: <tt>MyCustomName.relay1</tt>)</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction en utilisant les noms logiques (ex: <tt>MyCustomName.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FRIENDLYNAME_INVALID</tt>.'};
doc['Files']['get_functionDescriptor']={syn:'Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction.',lib:'files.get_filesDescriptor()',pro:'String get_functionDescriptor()',cmt:'<p>Retourne un identifiant unique de type <tt>YFUN_DESCR</tt> correspondant \xE0 la fonction. Cet identifiant peut \xEAtre utilis\xE9 pour tester si deux instance de <tt>YFunction</tt> r\xE9f\xE9rencent physiquement la m\xEAme fonction sur le m\xEAme module.</p>',ret:'un identifiant de type <tt>YFUN_DESCR</tt>. Si la fonction n\x27a jamais \xE9t\xE9 contact\xE9e, la valeur retourn\xE9e sera <tt>Y_FUNCTIONDESCRIPTOR_INVALID</tt>'};
doc['Files']['get_functionId']={syn:'Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module.',lib:'files.get_filesId()',pro:'String get_functionId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel de la fonction, sans r\xE9f\xE9rence au module. Par example <tt>relay1</tt>.</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_FUNCTIONID_INVALID</tt>.'};
doc['Files']['get_hardwareId']={syn:'Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>.',lib:'files.get_hardwareId()',pro:'String get_hardwareId()',cmt:'<p>Retourne l\x27identifiant mat\xE9riel unique de la fonction au format <tt>SERIAL&#46;FUNCTIONID</tt>. L\x27identifiant unique est compos\xE9 du num\xE9ro de s\xE9rie du module et de l\x27identifiant mat\xE9riel de la fonction (par example <tt>RELAYLO1-123456.relay1</tt>).</p>',ret:'une cha\xEEne de caract\xE8res identifiant la fonction (ex: <tt>RELAYLO1-123456.relay1</tt>) En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_HARDWAREID_INVALID</tt>.'};
doc['Files']['get_list']={syn:'Retourne une liste d\x27objets objet YFileRecord qui d\xE9crivent les fichiers pr\xE9sents dans le syst\xE8me de fichier.',lib:'files.get_list()',pro:'ArrayList&lt;YFileRecord&gt; get_list(String <span id=pn>pattern</span>)',cmt:'<p>Retourne une liste d\x27objets objet YFileRecord qui d\xE9crivent les fichiers pr\xE9sents dans le syst\xE8me de fichier.</p>',par:{pattern:'un filtre optionel sur les noms de fichiers retourn\xE9s, pouvant contenir des ast\xE9risques et des points d\x27interrogations comme jokers. Si le pattern fourni est vide, tous les fichiers sont retourn\xE9s.'},ret:'une liste d\x27objets <tt>YFileRecord</tt>, contenant le nom complet (y compris le chemin d\x27acc\xE8s), la taille en octets et le CRC 32-bit du contenu du fichier.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne une liste vide.'};
doc['Files']['get_logicalName']={syn:'Retourne le nom logique du syst\xE8me de fichier.',lib:'files.get_logicalName()',pro:'String get_logicalName()',cmt:'<p>Retourne le nom logique du syst\xE8me de fichier.</p>',ret:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du syst\xE8me de fichier',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne <tt>Y_LOGICALNAME_INVALID</tt>.'};
doc['Files']['get_module']={syn:'Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction.',lib:'files.get_module()',pro:'YModule get_module()',cmt:'<p>Retourne l\x27objet <tt>YModule</tt> correspondant au module Yoctopuce qui h\xE9berge la fonction. Si la fonction ne peut \xEAtre trouv\xE9e sur aucun module, l\x27instance de <tt>YModule</tt> retourn\xE9e ne sera pas joignable.</p>',ret:'une instance de <tt>YModule</tt>'};
doc['Files']['get_userData']={syn:'Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>.',lib:'files.get_userData()',pro:'Object get_userData()',cmt:'<p>Retourne le contenu de l\x27attribut userData, pr\xE9c\xE9demment stock\xE9 \xE0 l\x27aide de la m\xE9thode <tt>set_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',ret:'l\x27objet stock\xE9 pr\xE9c\xE9demment par l\x27appelant.'};
doc['Files']['isOnline']={syn:'V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur.',lib:'files.isOnline()',pro:'boolean isOnline()',cmt:'<p>V\xE9rifie si le module h\xE9bergeant la fonction est joignable, sans d\xE9clencher d\x27erreur. Si les valeurs des attributs en cache de la fonction sont valides au moment de l\x27appel, le module est consid\xE9r\xE9 joignable. Cette fonction ne cause en aucun cas d\x27exception, quelle que soit l\x27erreur qui pourrait se produire lors de la v\xE9rification de joignabilit\xE9.</p>',ret:'<tt>true</tt> si la fonction est joignable, <tt>false</tt> sinon'};
doc['Files']['load']={syn:'Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e.',lib:'files.load()',pro:'int load(long <span id=pn>msValidity</span>)',cmt:'<p>Met en cache les valeurs courantes de la fonction, avec une dur\xE9e de validit\xE9 sp\xE9cifi\xE9e. Par d\xE9faut, lorsqu\x27on acc\xE8de \xE0 un module, tous les attributs des fonctions du module sont automatiquement mises en cache pour la dur\xE9e standard (5 ms). Cette m\xE9thode peut \xEAtre utilis\xE9e pour marquer occasionellement les donn\xE9es cach\xE9es comme valides pour une plus longue p\xE9riode, par exemple dans le but de r\xE9duire le trafic r\xE9seau.</p>',par:{msValidity:'un entier correspondant \xE0 la dur\xE9e de validit\xE9 attribu\xE9e aux les param\xE8tres charg\xE9s, en millisecondes'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur. En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Files']['nextFiles']={syn:'Continue l\x27\xE9num\xE9ration des syst\xE8me de fichier commenc\xE9e \xE0 l\x27aide de <tt>yFirstFiles()</tt>.',lib:'files.nextFiles()',pro:'YFiles nextFiles()',cmt:'<p>Continue l\x27\xE9num\xE9ration des syst\xE8me de fichier commenc\xE9e \xE0 l\x27aide de <tt>yFirstFiles()</tt>.</p>',ret:'un pointeur sur un objet <tt>YFiles</tt> accessible en ligne, ou <tt>null</tt> lorsque l\x27\xE9num\xE9ration est termin\xE9e.'};
doc['Files']['registerValueCallback']={syn:'Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e.',lib:'files.registerValueCallback()',pro:'void registerValueCallback(UpdateCallback <span id=pn>callback</span>)',cmt:'<p>Enregistre la fonction de callback qui est appel\xE9e \xE0 chaque changement de la valeur publi\xE9e. Ce callback n\x27est appel\xE9 que durant l\x27ex\xE9cution de <tt>ySleep</tt> ou <tt>yHandleEvents</tt>. Cela permet \xE0 l\x27appelant de contr\xF4ler quand les callback peuvent se produire. Il est important d\x27appeler l\x27une de ces deux fonctions p\xE9riodiquement pour garantir que les callback ne soient pas appel\xE9s trop tard. Pour d\xE9sactiver un callback, il suffit d\x27appeler cette m\xE9thode en lui passant un pointeur nul.</p>',par:{callback:'la fonction de callback \xE0 rappeler, ou un pointeur nul. La fonction de callback doit accepter deux arguments: l\x27object fonction dont la valeur a chang\xE9, et la cha\xEEne de caract\xE8re d\xE9crivant la nouvelle valeur publi\xE9e.'}};
doc['Files']['remove']={syn:'Efface un fichier, sp\xE9cifi\xE9 par son path complet, du syst\xE8me de fichier.',lib:'files.remove()',pro:'int remove(String <span id=pn>pathname</span>)',cmt:'<p>Efface un fichier, sp\xE9cifi\xE9 par son path complet, du syst\xE8me de fichier. A cause de la fragmentation, l\x27effacement d\x27un fichier ne lib\xE8re pas toujours la totalit\xE9 de l\x27espace qu\x27il occuppe. Par contre, la r\xE9-\xE9criture d\x27un fichier du m\xEAme nom r\xE9cup\xE9rera dans tout les cas l\x27espace qui n\x27aurait \xE9ventuellement pas \xE9t\xE9 lib\xE9r\xE9. Pour s\x27assurer de lib\xE9rer la totalit\xE9 de l\x27espace du syst\xE8me de fichier, utilisez la fonction <tt>format_fs</tt>.</p>',par:{pathname:'nom complet du fichier, y compris le chemin d\x27acc\xE8s.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Files']['set_logicalName']={syn:'Modifie le nom logique du syst\xE8me de fichier.',lib:'files.set_logicalName()',pro:'int set_logicalName(String <span id=pn>newval</span>)',cmt:'<p>Modifie le nom logique du syst\xE8me de fichier. Vous pouvez utiliser <tt>yCheckLogicalName()</tt> pour v\xE9rifier si votre param\xE8tre est valide. N\x27oubliez pas d\x27appeler la m\xE9thode <tt>saveToFlash()</tt> du module si le r\xE9glage doit \xEAtre pr\xE9serv\xE9.</p>',par:{newval:'une cha\xEEne de caract\xE8res repr\xE9sentant le nom logique du syst\xE8me de fichier'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
doc['Files']['set_userData']={syn:'Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>.',lib:'files.set_userData()',pro:'void set_userData(Object <span id=pn>data</span>)',cmt:'<p>Enregistre un contexte libre dans l\x27attribut userData de la fonction, afin de le retrouver plus tard \xE0 l\x27aide de la m\xE9thode <tt>get_userData</tt>. Cet attribut n\x27es pas utilis\xE9 directement par l\x27API. Il est \xE0 la disposition de l\x27appelant pour stocker un contexte.</p>',par:{data:'objet quelconque \xE0 m\xE9moriser'}};
doc['Files']['upload']={syn:'T\xE9l\xE9charge un contenu vers le syst\xE8me de fichier, au chemin d\x27acc\xE8s sp\xE9cifi\xE9.',lib:'files.upload()',pro:'int upload(String <span id=pn>pathname</span>)',cmt:'<p>T\xE9l\xE9charge un contenu vers le syst\xE8me de fichier, au chemin d\x27acc\xE8s sp\xE9cifi\xE9. Si un fichier existe d\xE9j\xE0 pour le m\xEAme chemin d\x27acc\xE8s, son contenu est remplac\xE9.</p>',par:{pathname:'nom complet du fichier, y compris le chemin d\x27acc\xE8s.'},ret:'<tt>YAPI_SUCCESS</tt> si l\x27op\xE9ration se d\xE9roule sans erreur.',ext:'En cas d\x27erreur, d\xE9clenche une exception ou retourne un code d\x27erreur n\xE9gatif.'};
//--- (end of generated code: Files)
//--- (end of generated code)

 function isClassMethod(str_method)
 { return str_method.charAt(0) == str_method.charAt(0).toUpperCase();
 }

 // add function aliases to the substitution list
 for(classname in doc)
 { for(funcname in doc[classname])
   { if(isClassMethod(funcname))
     { // class method, generate shortcut
       sub['y'+funcname] = doc[classname][funcname].lib;
     }
   }
 }

 function ApplySub(text,classname)
 { var pos, endpos = 0, key, rep;
   if(sub['null'] != 'null') text = text.replace('<tt>null</tt>','<tt>'+sub['null']+'</tt>');
   if(UseShortcuts) return text;
   if(classname.substr(0,1)!='Y') classname = 'Y'+classname;
   while((pos = text.toLowerCase().indexOf('<tt>',endpos)) >= endpos) {
       pos += 4;
       endpos = text.indexOf('</', pos);
       key = text.substr(pos,endpos-pos).match(/[\w_]+/);
       if(key)
       { key = key[0];
         rep = sub[key];
         if(!rep && key.substr(0,2)=='Y_' && sub['YAPI_SUCCESS']) {
           rep = sub['YAPI_SUCCESS'].replace('YAPI',classname).replace('SUCCESS',key.substr(2,key.length));
         }
         if(rep) text = text.substr(0, pos)+rep+text.substr(endpos);
       }
   }
   return text;
 }

 function SetPosition(o,x,y)
 { var it=document.getElementById(o);
   if (!it) throw  "SetPosition: "+o+" element does not exist."
   it.style.top  = y;
   it.style.left  = x;
 } 	 

function GetPositionX(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionX: "+o+" element does not exist."
   return parseInt(it.style.left);  
 }	  
 
function GetPositionY(o)
 { var it=document.getElementById(o);
   if (!it) throw  "GetPositionY: "+o+" element does not exist."
   return parseInt(it.style.top);  
 }	  

function  GetWidth(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetWidth: "+o+" element does not exist."
    return parseInt(it.style.width);
 } 
 
function  GetHeight(o)
 {	var it=document.getElementById(o);
    if (!it) throw  "GetHeight: "+o+" element does not exist."
    return parseInt(it.style.height);
 }
 
function  SetHeight(o,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetHeight: "+o+" element does not exist." 
    h=parseInt(h);
    if (h<0) h=0;
	it.style.height  =  h+ "px";
 } 
 
function  SetWidth(o,w)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetWidth: "+o+" element does not exist."  
    w = parseInt(w);
    if (w<0) w=0;
	it.style.width  = parseInt(w) + "px";
 }
 
function  SetLeft(o,l)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetLeft: "+o+" element does not exist."  
    it.style.left  = parseInt(l) + "px";
 }

function  SetTop(o,t)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetTop: "+o+" element does not exist."  
    it.style.top  = parseInt(t) + "px";
 } 

function  SetSize(o,w,h)
 {	var it=document.getElementById(o);
    if (!it) throw  "SetSize: "+o+" element does not exist."  
    w= parseInt(w);
    if (w<0) w=0;
    h=parseInt(h);
    if (h<0) h=0;
    it.style.width   = w;
	it.style.height  = h;
 }
 
function  GetWindowWidth()
 {	 return parseInt(document.body.clientWidth);
 }

function  GetWindowHeight()
 {	 return parseInt(document.body.clientHeight);
 }
 
function computeWinWH()
 { WinW             = GetWindowWidth() ;  
   if (WinW<600) WinW=600;
   WinH             = GetWindowHeight(); 
   if (WinH<400) WinH=400;
} 

 
 function getInnerHeight()   
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollHeight, D.documentElement.scrollHeight),
        Math.max(D.body.offsetHeight, D.documentElement.offsetHeight),
        Math.max(D.body.clientHeight, D.documentElement.clientHeight)
    );  
 }		
 
 function getInnerWidth()   
 {  var D = document;
    return Math.max(
        Math.max(D.body.scrollWidth, D.documentElement.scrollWidth),
        Math.max(D.body.offsetWidth, D.documentElement.offsetWidth),
        Math.max(D.body.clientWidth, D.documentElement.clientWidth)
    );

 }

function onResize(fct) 
  { fct();
    resizeCallBacks[resizeCallBacks.length]=fct; 
  }
  
function windowResized()
  { computeWinWH()
    for (var i=0;i<resizeCallBacks.length;i++) 
      resizeCallBacks[i]();
  }  

function jsQuote(str_in) 
{ str_in = str_in+'';
  var str_out   = ''; 
  for (i=0;i<str_in.length;i++) 
   { 
     var ascii = str_in.charCodeAt(i);
     if ((ascii>=32)&&(ascii<=127)&&(ascii!=34)&&(ascii!=39)) str_out =str_out+str_in.charAt(i);
     else 
      { var hex = ascii.toString(16).toUpperCase();
        if (hex.length==1) hex = '0'+hex;
        str_out = str_out + String.fromCharCode(92) + 'x'+ hex; 
      }  
   } 
   return str_out; 
  }  
 

function resizeMargin()
 { 
   SetSize("MarginLayer",marginSize,WinH-110);
   SetLeft("FunctionsLayer",marginSize);
   SetSize("FunctionsLayer",WinW-marginSize,WinH-110);
 } 
 
function resizeSeparator()
 { SetHeight("separatorLayer",WinH-110); 
 }
 
function positionObject(int_x,int_y)
 { this.x = int_x;
   this.y = int_y;
 } 
 
function GetEventPosition(event)
 { var x,y;
   if (event.changedTouches) 
    { x = event.changedTouches[0].pageX;
      y = event.changedTouches[0].pageY;
    }
   else
    {  x = event.PageX;
       y = event.PageY;
      if (!x)
        { x= event.clientX + document.body.scrollLeft;
         y= event.clientY + document.body.scrollTop;
        }
    }  
  return new positionObject(x,y);
 } 
 
  
function EnableDrag(var_element,onDragMove,onDragEnd)
  {  
   //onDragMove & onDragMove are optinnals callbacks fct(DomElement,position) where position is an associtative array "x","y   
   if (document.addEventListener)
      { var_element.addEventListener("mousedown",Drag_start,false);
        var_element.addEventListener("touchstart",Drag_start,false);
      }  
   else 
     if (document.attachEvent)
       var_element.attachEvent("onmousedown",Drag_start);
       
   if (onDragMove)  var_element.onDragMove = onDragMove;    
   if (onDragEnd)   var_element.onDragEnd  = onDragEnd;    
  }
  
 var LastDraggedObject = null;  
  
 function DraggedObject(obj_element,obj_elmtInitialPos,obj_mouseInitalPos) 
  {this.element         = obj_element;
   this.elmtInitialPos  = obj_elmtInitialPos;
   this.elmtCurrentPos  = new positionObject(obj_elmtInitialPos.x,obj_elmtInitialPos.y);
   this.mouseInitialPos = obj_mouseInitalPos;    
  }

function Drag_start(event)
 {
   if (!event) event = window.event;
   var source = event.srcElement;
   
   if (event.button!=undefined)
    { if ((event.button!=1) && (document.attachEvent)) return;  // ie;
      if ((event.button!=0) && (document.addEventListener)) return;  // other;
    }
   
   if (!source) source= this;
   if (!source) return;
   var originalsource=source;
   while (source.tagName!="DIV")
      { if (source.tagName=="A") return false;  // there is a link (a probably a button) on the way:  cancel drag
        source=source.parentNode;
      }
      
   if (event.preventDefault)   event.preventDefault();  
   source.style.cursor="col-resize";
   lastDraggedObject      = new DraggedObject( source, 
                                               new positionObject(parseInt(source.style.left),parseInt(source.style.top)),
                                               GetEventPosition(event)
                                              );
   if (document.addEventListener)
    { document.addEventListener("mousemove",Drag_mouseCapture,false);
      document.addEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.addEventListener("touchmove",Drag_mouseCapture,false);
      document.addEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else  
   if (document.attachEvent)
    { document.attachEvent("onmousemove",Drag_mouseCapture);
      document.attachEvent("onmouseup",Drag_stopMouseCapture);
    } 
   document.onmouseup   =   Drag_stopMouseCapture;
 } 
 
 
function Drag_mouseCapture(event)
 { 
   if (!event) event = window.event;
   var position = GetEventPosition(event);
   if (event.preventDefault) event.preventDefault(); 

 
   var x = (lastDraggedObject.elmtInitialPos.x + position.x -  lastDraggedObject.mouseInitialPos.x);
   var y = (lastDraggedObject.elmtInitialPos.y + position.y -  lastDraggedObject.mouseInitialPos.y); 
   
   var iw = getInnerWidth()
   var ih = getInnerHeight();
   var w  = lastDraggedObject.element.offsetWidth;
   var h  = lastDraggedObject.element.offsetHeight;
   
   if (x>iw-w) x=iw-w;
   if (y>ih-h) y=ih-h;
   if (x<0) x=0;
   if (y<0) y=0;
   
   var p = {x:x,y:y};
  
   if (lastDraggedObject.element.onDragMove)
      lastDraggedObject.element.onDragMove(lastDraggedObject.element,p);
    
   lastDraggedObject.elmtCurrentPos.x   = p.x;
   lastDraggedObject.elmtCurrentPos.y   = p.y;
    
   lastDraggedObject.element.style.left = p.x+"px";  
   lastDraggedObject.element.style.top  = p.y+"px";  
 }

function Drag_stopMouseCapture()
 { 
   if (document.removeEventListener)
    { document.removeEventListener("mousemove",Drag_mouseCapture,false);
      document.removeEventListener("mouseup",  Drag_stopMouseCapture,false);
      document.removeEventListener("touchmove",Drag_mouseCapture,false);
      document.removeEventListener("touchend", Drag_stopMouseCapture,false);
    }
   else
   if (document.detachEvent) 
    { document.detachEvent("onmousemove",Drag_mouseCapture);
      document.detachEvent("onmouseup",Drag_stopMouseCapture);
    }
 
  if (lastDraggedObject) 
    { lastDraggedObject.element.style.cursor='col-resize';   
      if (lastDraggedObject.element.onDragEnd)
       lastDraggedObject.element.onDragEnd(lastDraggedObject.element,{x:lastDraggedObject.elmtCurrentPos.x,y:lastDraggedObject.elmtCurrentPos.y});
    }
   lastDraggedObject = null;
 }  
 
 function marginMove(el,pos)
  {pos.y = 80;
   if (pos.x<100) pos.x=100;
   if (pos.x>WinW-100) pos.x=WinW-100;
   marginSize=pos.x;
   resizeMargin() 
  }
  
 function proto(str_classindex, m)
  {
      var funcproto = doc[str_classindex][m].pro;
      if(isClassMethod(m)) {
          if(UseShortcuts) {
              funcproto = funcproto.replace(m, 'y'+m);
          } else if(doc[str_classindex][m].lib.substr(0,1) == '[' && funcproto.substr(0,1) != '+') {
              var params = doc[str_classindex][m].par;
              var methodpos = funcproto.search(m);
              var endrettype = methodpos;
              while(endrettype > 0 && funcproto.substr(endrettype-1,1)==' ') endrettype--;
              var newproto = "+("+funcproto.substr(0,endrettype)+") "+m;
              var pos = methodpos+m.length;
              for(var p in params) {
                  pos += funcproto.slice(pos).search(/[A-Za-z]/);
                  var argpos = pos + funcproto.slice(pos).search('<span');
                  var endargtype = argpos;
                  while(endargtype > pos && funcproto.substr(endargtype-1,1)==' ') endargtype--;
                  var endarg = argpos + funcproto.slice(argpos).search(/[,)]/);
                  newproto += ": ("+funcproto.slice(pos, endargtype)+") "+funcproto.slice(argpos,endarg)+" ";
                  pos = endarg;
              }
              funcproto = newproto;
          }
      }
      return funcproto
  }

 var lastindex_shown = "";
 var lastname_shown = null;
 function Show(str_classindex,str_name)
  { 
    if ((str_classindex=='')&&(str_name==''))
      { document.getElementById("FunctionsLayerInner").innerHTML =NotFound;
        return;
      }
  
    var fcthtml='';
    fcthtml = "";
    lastindex_shown =str_classindex; 
    if (str_name)
       { lastname_shown = str_name;
         var fct = doc[str_classindex][str_name];
         var funcname = fct.lib;
         var funcproto = proto(str_classindex, str_name);
         if(UseShortcuts && isClassMethod(str_name)) {
             funcname = 'y'+str_name+'()';
         }
         fcthtml = "<span class='funcHeader'>"+funcname+'</span>'
                   +"<br><br><span class='prototype'>"+funcproto+'</span>'
                   +'<br><br>'+ApplySub(fct.cmt,str_classindex);
         if (fct.par) 
          {  fcthtml += "<span class='paramAndRet'>"+ParamLabel+'</span><br>\n';
             fcthtml +='<table class="paramtable">'
             for (var p in  fct.par)
                 fcthtml +='<tr><td class="pn">'+p+'</td><td> : '+ApplySub(fct.par[p],str_classindex)+'</td></tr>\n';
             fcthtml +='</table><br>'   
          }      

         if (fct.ret)
          { fcthtml += "<span class='paramAndRet'>"+ReturnLabel+'</span><br>\n';
            fcthtml +='<p class="paramtable">'+ApplySub(fct.ret,str_classindex)+'</p>\n';
          }              
        
         if (fct.ext)  fcthtml+=ApplySub(fct.ext,str_classindex);
      }
     else
     if (str_classindex!='')
     {  fcthtml = "<span class='funcHeader'>"+str_classindex+'</span><br>'
                + "<p>"+ApplySub(doc[str_classindex][''].syn,str_classindex)+"</p>"
                + "<p>"+IncludeLabel+"</p>"
                + "<p  class='include'>"+doc[str_classindex][''].inc+"</p>"
                + "<p>"+ApplySub(doc[str_classindex][''].cmt,str_classindex)+"</p>";
        for (m in doc[str_classindex]) {
          if (m!='') {
            var funcproto = proto(str_classindex, m);
            fcthtml +="<p class='methodlist'><a class='protoindex' href='javascript:Show(\""+str_classindex+"\",\""+m+"\")'>"+funcproto+'</a><br>'
                    +"<span class='synlist'>"+ApplySub(doc[str_classindex][m].syn,str_classindex)+'</span></p>';
          }
        }
     }      
     document.getElementById("FunctionsLayerInner").innerHTML =  fcthtml; 
  } 
  
  function expand(source,openonly)
  { if (document.getElementById(source.id+"List").style.display=='' && !openonly)
     { document.getElementById(source.id+"List").style.display='none';
       document.getElementById(source.id).src=plusimage;
     }
    else  
     { document.getElementById(source.id+"List").style.display='';
       document.getElementById(source.id).src=minusimage;
     }    
  } 
  
 function ShowFunctions(str_currentClassName)
  { var marginhtml = "";
    for (var classname in doc)
    {  var icon = plusimage;
       var fct  = "expand";
       var display = "none"
       if (str_currentClassName==classname) 
         {  icon = minusimage;
            fct  = "expand";
            display = ""
        }
       marginhtml = marginhtml+"<span class='classheader'>&nbsp;<img class='expandColapse' id='"+classname+"' onclick='"+fct+"(this)' src='"+icon+"'/> ";
       marginhtml = marginhtml+"<a href='javascript:Show(\""+classname+"\",\"\");' id='"+classname+"' onclick='"+fct+"(this,true)'>"+classname+'</a></span><br>';
       marginhtml = marginhtml+ "<div id='"+classname+"List' class='methodsList' style='display:"+display+"'>";
        
       for (var method in doc[classname])
       { if (method!='')
         { var funcname = doc[classname][method].lib;
           if(UseShortcuts && isClassMethod(method)) funcname = 'y'+method+'()';
           marginhtml = marginhtml+"<a id="+classname+'.'+method+" style='display:block' href='javascript:Show(\""+classname+"\",\""+method+"\");'>"+funcname+'</a>';
         }  
       }
       marginhtml = marginhtml+'</div>'  
    }
  
    document.getElementById("MarginLayer").innerHTML = marginhtml; 
  }
  
 function fctMatch(classname,method,values)
  { var found    = new Array()
    var tosearch = new Array()
    
    for (var i=0;i<values.length;i++)
     if (values[i]!='' && values[i]!='y')
      { if(values[i].substr(0,3) == '[y]')
          tosearch[tosearch.length] = values[i].substr(3,values[i].length);
        else
          tosearch[tosearch.length] = values[i];
      }
    
    for (var i=0;i<tosearch.length;i++) 
       {  var expr     = new RegExp(tosearch[i], "i");
          var fct = doc[classname][method]
          var found = classname.search(expr)>=0;
          if (!found) found=method.search(expr)>=0;

          if (!found && fct.inc)
            {if (!found && fct.syn) found=fct.syn.search(expr)>=0;
             if (!found) found=fct.inc.search(expr)>=0;
            }            
          
          if (!found && fct.pro) found=fct.pro.search(expr)>=0;
          if (fct.par)
             for (var p in  fct.par)
              { if (!found) found=p.search(expr)>=0;
                if (!found) found=fct.par[p].search(expr)>=0;
              }              
          if (fct.ret)
              { if (!found) found=fct.ret.search(expr)>=0;
              }
          if (!found && fct.cmt)found=fct.cmt.search(expr)>=0;    
          if (!found && fct.ext)found=fct.ext.search(expr)>=0;
          
          if (!found) return false;
       }       
    
  
    return true;

  }
 
 var searchTimer = null; 
 
 function doSearch()
  { searchTimer = null; 
    var value= document.forms['yoctoForm'].elements['search'].value;
    
    if (value=='')
     { for (var classname in doc)
        { var container = document.getElementById(classname+"List");
          for (var method in doc[classname])
           if (method!='')
             { var it = document.getElementById(classname+'.'+method);
               if (it) it.style.display="block";
             }
          document.getElementById(classname).style.visibility='visible';
          var container = document.getElementById(classname+"List");
          if (container["originalDisplay"]!="")
           { document.getElementById(classname+"List").style.display='none';
             document.getElementById(classname).src=plusimage;
           }
          else
           { document.getElementById(classname+"List").style.display='';
             document.getElementById(classname).src=minusimage;
           } 
          container["originalDisplay"]=null;           
        }
        Show(lastindex_shown,lastname_shown);
       return;        
      }   
      
    var firstindex = '';
    var firstname  = '';
    qvalue = value;
    value = '';
    for(var i = 0; i < qvalue.length; i++) {
        var c = qvalue.charAt(i);
        if(c == '\\' || c == '[' || c == ']' || c == '(' || c == ')') {
            value += '.';
        } else {
          if (c!=' ')  value+='['+qvalue.charAt(i)+']';
                   else value+=' ';
        }
    }
    for (var classname in doc)
     { var  matchfound=false;
       var container = document.getElementById(classname+"List");
       if (!container["originalDisplay"]) container["originalDisplay"]=null;
       if (container["originalDisplay"]==null) container["originalDisplay"] = container.style.display;
       values = value.split(' ');  
       for (var method in doc[classname])
       
         { var it  = document.getElementById(classname+'.'+method);
           var match = fctMatch(classname,method,values);
               if (match)
                 {  if (it) it.style.display="block";
                     matchfound=true;
                    if (firstindex=='') {firstindex=classname; firstname = method;}        
                 } 
              else 
                 { if (it) it.style.display="none";
                 } 
         } 
        
      if  (matchfound) 
          { document.getElementById(classname+"List").style.display='';
            document.getElementById(classname).src=minusimage;
            document.getElementById(classname).style.visibility='visible';
          }
         else
          { document.getElementById(classname+"List").style.display='none';
            document.getElementById(classname).style.visibility='hidden';
            document.getElementById(classname).src=plusimage;
          }
     }
   
    Show(firstindex,firstname); 
        
    
  }
  
 function initSearch()
  { if (searchTimer!=null)  clearTimeout(searchTimer);
    searchTimer = setTimeout('doSearch()',500);
  }  
  
 function sortObject(o) {
    var sorted = {}, key, a = [];
    for (key in o) {
        if (key != 'YAPI' && o.hasOwnProperty(key)) {
                a.push(key);
        }
    }

    a.sort();
     if (o['YAPI']) sorted['YAPI']=o['YAPI'];
    for (key = 0; key < a.length; key++) {
        sorted[a[key]] = o[a[key]];
    }
    return sorted;
}

 function OOcheckboxChange()
  { UseShortcuts =  document.forms["yoctoForm"].elements["OOcheckbox"].checked;
    ShowFunctions(lastindex_shown); 
    Show(lastindex_shown,lastname_shown); 

  }
  

 
 
 -->
</SCRIPT>

</HEAD>

<BODY>

<div id="BannerLayer">
<table width=100% >
<tr><td rowspan=2>
<img alt="Yocto-Api :-)" style='margin-left:5px;'src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAk4AAABCCAYAAAChBFmnAAAALHRFWHRDcmVhdGlvbiBUaW1lAFR1ZSAxMyBEZWMgMjAxMSAwNzo0OTo1NSArMDEwMFnEsZUAAAAHdElNRQfbDA0HDiVTf5zcAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABGdBTUEAALGPC/xhBQAAEn5JREFUeNrtnQ2wVVUVxxcRWIr4gaQkxmNkBk1LSygaabzOEKAhGpKioFKDIaX2SGu0KJ8TTozzRCwbFXFk4gF+JuIXok6k4kAiaeGIhPpIbWQUE8dGEYHW/5194Pq49919PvbZ59z7/82sOe/de87Za+9z9rn/sz/WFiGEEEIIIYQQQgghpAgsUFuvdqHDNH6k9rJam1o33xkmhBBCCIlDX7Vn1A5QW+MwnefUDjRp9fWdaUIIIYSQuCxWe1vtB47Of6baNrWNarf5ziwhhBBCSBLGqO1S6+Hg3CUJRNNsYRcdIYQQQuoAl8LpIbWlvjNICCGEkMbjM74diEE/tb/7doIQQgghjcdnPaePAeRD1Qar9TGfbZFgttyzals9+0cIIYQQshsfwgnjks5Qm6p2slrPKvt9rPYXtVvUlkjQ9UcIIYQQ4g1Xwmmb2fZS+2/Z599Uu0ntaxbngKAaZWyt2o/VVvspptqUSqXrddMc8bC31IasWLHizYx9/Z1urohwyBz1cXrMtAboZoLaILXD1A4x26Ys81yFT9TeMPaOBNcD8cfu0PxuztoZLavjdDPac1lVKhPMXl2iZfJKgrzVxYuPlkGiCSmsD/WFXs8LdDPfYtf31Jq0HHPZi5LT+ol7EPfiW2a7Tu2etH8vbfNeXvddzUrrrfaq2nK189R2qF2uhh/suGJtu9ov1c5Ve0DtKke+x0YvAMIwTIh4GB5Mw7KqUOrjT3UzJ8Ih89S3yIFMzQ9Eq9r4LPKVMvgBma92heZ9i+vEtKyO1M0dakN8Z7wGy9Qmx/kRzemDOTJxhRPrQ/2h13Qf3bRLIHxtuFHL7xLfflfJS1HqJ+7FeRLci6n8ZsYRTq4Gh7+vNk7tNLU/qaE15lpJ1sLVw5zjq458ToNJavdEPOYotQdNJXSKpoH4V60RDkFeLoqRDoQA3g6K+CMBcJ9OUXte89In6cm6wpTV85J/0QTQGrbGdZnUG6wPdQta7W1FE7hIy2+wb6cLDu5F/Cat0rLcz5cTLmfVPSlBWAKMZ0IXVhqtWzhHd7VD3RdNdFSRomUNLU4PRjx0uFqb3gjdXfmm5z5RglYNW/EK0TTB5CkqSKeXq7xkSH+1mx2nUbSyyqJM6o2iXeNq8Nob9Hl6uEQb7gDw7I3S2k+qgwaH+b4Sdx2OAM1qPROfZW/w9nOSY99jUSaeno54KN5Go7QGWWPGzqCbxVY0Yd9YosmkVYTWE1vOcPWWrefFmL8ilhXKJJcvL3mD9aFuman2uRjHjdby+65v5+uE8aZ+ZY5L4YQf6VvFzQB0tMzgzcdFgM3EqOD4nwTdGlHFU7PeCJel6YvpJoAQsn3jhc/jY7Y0icl3PYH7d4Sjc7s6r2tQJvV2nV1Rb+Xksj4UAn2mnqCbyQlOMcdl70KD4aX726VwOl/taIfnP8qkkUuMeEI35fqIh7ZqpTo7DR9MqwC6DW374SGaRhvf4zIoDd9zxlGOzlvksiqy71lSj+Xkqj4UhaTdbbgnos7AJpU53keiLoXTpRn4n0UasTEzUEoSXTxhvFOirkgzcA6iyfYhhwHKSUUTiDJYsig0OTpvkcuqybcDBaHI17gaTb4d8IWZYDM8hVPNYJdnKnh5MXEVxwktTVnMfvuK2jFqL2aQViwwdVsrSEkCYWL7EMV1wUw7hCmInDfTDIygobZjKyDs0hBNEiGPTSmklQbtHn3Na1m1O/Ap7TzY+Ogi3ajk9RpXo71AvmaKmfk8y2JXxGw6sMY++B7jpKb5zldEmhyeG8NJUF/QvX2x2I0hc+lPVSoJJwRkeyfheb8j7mJElYM0Rkpy4dRX7W1XTpaJpxVi/yDFTfS4HhYnQGab2I9DgGgqpRjgzip/mt6mlNJLRHBZatLkKPlclpWLMkk7D5Y+5uE+y+U1robn+pB30L1Wq4UDwRoxRGOVxfmmaHnfGOfl2BcZ3Kcoiye0XBDw0qZLNM4A/cR07qpbIEFwSQRyHGNhp6oNrHDeLGeRfD3h8bepLZUg3pQz9IbD+nslCSqWLXjoQjwdYHuAiWBuG4QTN2eaogn0T/FceaHJ0XmL3I1Tj9fZBfVYTk2+Hcga061mE35gpj5PscLFEot9GZ6gOjbl543OwukbaqdI0FrxgIU9pPYvtd90Ok9ThnkYmOBYtFidZPI8zLWjRjxhFsAHEQ6zDpBpZuTZDjqEgBvBpRQIIaQm6Far1f2GpYnCOFctlucdoc/t031nLm/kpQW2Gp2FE+IIPab2Cwmm+teyL0iwrMrVEtxYIdYtJClQ62buitlqX1J7QhzFUOqM3hArJejDjSKeagbI1O8mRsgDRFPJCDlCCCFV0GcrxtFOsdi1JQzjotsXJBgyYUNrFitHkPToLJwQd2mo2u0SBK+sZRgXhKVVHlb7ldpvPeQh7ho7EE0/kWDtO8TlmJuVw0Y8oeXpkwiHVQ2QaQKqzbc8DwQbRRMhhNiB526tiVTP6zN1YafPWsTuGc/wBAUjjXAEH6lhimYonm7KOA/vxjgGogmj9iGaoq4tlwpayR6VYCxSFPG0V4DMiEupQDSNpmgiCUBrJQKqcmwGqXv0+TpK7IKYzuj8gT5nXxH7VqcrGI2/OKQVjgDiCS1P90mMRWETsjHi/teJZ9EUohXrXq0sEyL6gWbdN/TYO82CkTjWJip4KJpW+swzKQztEixMu75suz6tFckJyTtmaITNC4JWixUPVfkOQ1iw+Hut39owPMGFvvNNapNmHKdtat9T+7MEs+2y4tkI++ZGNIUY8YRm2ihv8G1m2jBiitjMzEKr1hiKJmJJr5RiehFSZDCuySaAcEu1L9DqhJADYtcVN9mEJ3jBd8Z9o+UwwLcPXZF2AEyIJ3TbPSLB1PssQFMqHvI7u9inm9nvLDUMos6FaArRinKDEUK24gnX7Q7LfSGasGDvX33nkxQDiibiEn3WxR2XWhG9X1OPGWhCwMy02HWJxbMVL7joiakVcygMT3By2vkpIGf4dqArXEQOR7fdORJEyq7YZ3vEEUdI9+7dZdOmTbJrV+U61K1bNxkwYIDs2LFDXn/99a7SQwEjnEBXY4WQSLvZ9xEHeU6MEU9oPbKJFWJLKJru9Z0/QggpEBizdEiNffB8bal1IhMAGWEKbFqdECv5bAzF8F0AWWNamZokiBF5seVhH/nw1dWSKxhAOl1tUafPd82ePfut5ubmfhBGy5cvl3PPPVe2bNnyqZ369OkjixYtkpEjR3YIq7lz58q0adOqiSw0g/5c7eMu/Nkl8WffZYZWliv15sFbSVozLCZTNBFCiD36DD5S7H642yJ0q6HVCV1/NuNRZ6kPaMna5rssKpRN3n5H230k6nKRX0Qff6b8g549ez48ffr0HhBNAMJo4cKFEv4P8HdbW1vHd+H/U6dOlbFjx1ZKA91Vl0igOnd2YXm72FXRygLBOS+FUzVXmB5LCCGkayByanWrobXJpiuvAxNo2DbOXpPa5b4LoSBEnRyWCi6FE7hKykRL79690RfcI/x/8eLF8tRTT8nAgXuCf+PvlStXdrQ4lTNixF5Lr2G5kKxn8GUF8pVkHBZE0w2+M0EIIUWiVCphJYnxFrveaMINRAHjl96z3JfhCex43keiroXT42r/LPsfUVU7utTWr18vEydOlGuuuUZee+213Tvg75kzZ8qkSZM69gnBmKhOQJHX5dRoE302apiCkBkUTYQQEgubCTro4ZgV9cQmlIftBKBecdJoQLxM9HItnMDuxXO3bt2KBXk7mtYOOugg2X///Ts+33fffXfvHP6N77BPyKpVn1pseq3aXT4KLCuMeEL8j6cjHDZHj7vGt++EEFI0SqXSBbo53mLXWQnW+IRwsl3oHeEJTvBdLjnmHl+hG7IQTg+Hf2zfvn3c0qVLserxrkMPPVTWrVvX0VXXv/+eBcTxNz7Dd9gHbNy4Ue6+++7yc14rBRq3FBczONAmam24/3TfPhNCSNFQgbKf2LXwoKstdtR80+oUpSWJEforg+6oyb4Sz0I4bZAgzhL4/Lhx4y5cu3Ztx8rH/fr1k/vvv19efnnPCiD4G5/hOwABNWbMGPnwww/DXbA+3n2+CixrGFOHEEKcg6EfNsGEW1KIno/QBLatTsMRnsBryeQLDMpH+Q3z+dvoKhxBOWgZ2h2ccseOHYOGDh26a/DgwfLuu+/K5s17t3i2trbKggUL5OCDD5YNGzZ0xHIq40HpOvQAISQB+qDGoMNVxlaorQtXfSckKS4CViZB7/fDxS5+HsTOzSnkf5umiVYn29ak1ryGJ8gAlPlGYxgIju65N307FUc4oUkTa6R1t9gXFQRxBT4Vu2Lnzp3dXnrppS4PhKCqJKqUv3kpKUIahyZjE8z/H+iDe42UiSmuWUfqCJvwAwAtUh+ZVR6yBGNZIOyuzjrhCjRlmNZbeRWLUYUTIm/fLsGChL7IZUESUsfgxackZcso6Y8HFvw92rdjhCTBDL6e5NsPCxCeYJ7v1hZNf5PvgsgDUYQT1qBDUMu5EiyWu93iGLQ4fVGCRXWnqu2Tgs/oi4Zw2xnxOEwhfUzt1RR8IKTRsVn8lJC8U5TB12gRQ8vYeb4dIfbCCaIJESn/oHZZxDSw0NxqCVqq7lf7UgJ/MV6qj9qlMY5FFyMqCW68XC3ySwghJFvMoOvhvv2IwCT1GYE3V/t2pNGxEU6haPqjRBdN5WBg17fVVkrQZxuFDyRQ2xBf/4mZPmYQXid71s+jeCKEkAZEBQh6P6yXTMkRePn/lm8nGp1a4QjC7jkspPuzFNL7twTh7D+JcMz7EgguBHaMK5oAuvYQ5wgCcJHYhdUnhBBSf2Ah9UG+nYjBMBV9E3070eh0JZxC0RSne64r0Mw4t+x/BBS7VYIxULghrlT7R9n3eCtIcz0aiidCCGlQzBpwNuEH8sosE7CTeKJaV12SMU02IBbGNLXn1E6VIKhlOVhFGuOhThE3XWphhG1226UPhLDPWZcusA1WF5V31A7xnbmYuCqTeoP1IX+0SLGvSRie4Ne+HWlUOgunC9UuUjtWko9p6gpEE0dAvdmyt2gC6MrDGneIAeVq+mW5eMJNeIsELV8kGXioFvmhVIl2R+dFWRVVOLX7dqAgsD7kiFKpdIxupljsCsE7TILZ2FnRIvbLiFxuwhMwPIAHOgsnCCXcLM+KO9EEwlACH3axD+I1fSrquAMwbus0tRESdCFSOCUHPxQ1p6prpS/SWoPtjs6Lsjq21k45Lat23w4UBNaHfIHB1TaTomaoKHnZYr/U0HsAoXYQK9FGaIfhCc7J0kcS0HmME6JyP6L2pDTAIromj0+aPDMieTq0+3agQHl6w3fGEtDu24GC0O7bAeYpQIXJKAlekmuBBWQTL60SFRVqWyTa2KsJmqcTs/aT7K28z1frK5W7z+qVHzZgnl1S9PEPlWgv2HmzYKNvBwoC60MOUIGBJcJsg102e1ybcZ4EXYlDLPdHnoZ68rVhqTSrLi8CAl103Yy5Ji95rgce9+2AA5Y5Om+Ry8pVmdQbRb7G1SjitcfYXZto98tUND3qy0kj2JojHDJEReEFvvxtVGrFcfIJBpDjLeFM344Qe7TiPyFBU3e9sMzVAEw9L4LBFrGslvleM6sosD74R4XFARIMvK4FJiVd7ttf81xoi3DILJNHkhF5Fk542FyvNl/tdN/OkEggPtYHvp1IAXSzTHacRtHKKosyqTeKdo2rUdRrP0PsZq9iltqLvp01QMC9Z7nvYVLsuFSFw5dw6mXS/rjGfrh5MNPtTrWxnnwlETEPn+PV1vj2JQHojjhe87LZZSIFK6tMyqTeKNg1rkYhr32pVDpS7Lq+IFJm+PY3xJRzS4RDmk1eSQbYLvKbJuh++73aVrVnauyLWW/hgr53qZ2lttSDzyQiWvFf0c1QrczH6Xa0BOMLmiQI3oatj3uvEojT0i7BDDds0dK5xPjfqGXlvUzqjRxe42rU27XHlH2bsp1pZrXlCSx1hoHiNUOWyJ7wBN/37TRJH4gmBLZEs/XJEY7DAHFEMUelZssTIYQQQuqeuKIphOKJEEIIIQ1BUtEUQvFECCGEkLomLdEUUi6exvjOHCGEEEJIWqQtmkIgnhAS/321Pr4zSQghhBCSFFeiKaS3BLPuRvnOKCGEEEJIUuaKO9EEekggnNhdRwghhJBC82UJ1ppzKWoonAghhBCSKa4ihw+UYBzSct8ZJIQQQghJC1fCaZLaO2oTHfp+XgZpEEIIIYQ4pa8ES6lgtWaXazPh3AeatPr6zjQhhBBC6h8XLU5vq2Fdo9Vqtzj0HedeZdJ622E6hBBCCCEd/B8r9kLFREQWUAAAAABJRU5ErkJggg==" />
</td><td style='vertical-align:top;text-align:right'>
<a class='extLink' href='http://www.yoctopuce.com'>www.yoctopuce.com</a>
</td>
</tr>
<tr><td  id='langdt'></td></TR>
</table>
</div>
<div id="MarginLayer"></div>
<div id="FunctionsLayer"><div id="FunctionsLayerInner"></div></div>
<div id="FooterLayer"><form name='yoctoForm'>
<table width=100% style='margin-top:3px;'>
<tr><td>
<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAANwAAADcBYx2BhQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGgSURBVCiRjdC9a1NhFAbw8973ed7bewm859KKc4oFwUUwk0uMkICC4gfYIjSDQhaH+ge4BOFCwEUpQsCtEEkHURCHigQjcQo4FFyKHYWsflGaq9elStVr9Yzn4cf5MHmeS1G12+1gNBrdJLkMYIHkNoD+ZDLpDAaDzBRBY4yp1+tPSZ4los0QhzYEH0+RcgLAq3K5fLoQNhqNGwBWY3d85fBM+vxHf8fdPWnc5gOSt4KiNUkukuHb/UhEZGZ35TVs/MZau1gIrbXzLph7UZTBzL4EMF8IAWwZfjrz9duu+T0L3Ic6gK2/rboGmCM77vbF/Rizqw1SjgFY++M5lUqF4/F42mw2HwJYAsJ3sHMb5JcaKEcBPIvj+NwvsFqtni+VSj3vfb/X611vtVrXACxbaxecc9sk+51O536e5/lPWKvVLkRRtJ4kCVX1c5ZlSbfbnRadIiIS7E26FEXRuqpSVafe+6sHIREROxwOL8dx3FdVJkky9d5fSdP0yUFIRCQIw/CeqkJVM+/9Upqmj/+FREQCVb2jqu/30KP/QSIi3wFqcn4o9hAuDAAAAABJRU5ErkJggg==" />
<input name='search' onkeyup='initSearch()'></form> 
</td><td id ='oosyntax' ></td><td id='version'>
</td>
</table>

</div>
<div id="separatorLayer" style='top:80px;left:250px'></div>

<SCRIPT type="text/JavaScript" language="javascript1.5"> 
<!--
document.getElementById('langdt').innerHTML = Language;
document.getElementById('version').innerHTML = Version;

computeWinWH();

onResize(function(){SetWidth("BannerLayer",WinW)});
onResize(resizeMargin);
onResize(function(){SetWidth("FooterLayer",WinW);SetTop("FooterLayer",WinH-30);});
onResize(resizeSeparator);
EnableDrag(document.getElementById("separatorLayer"),marginMove,marginMove);  
if (UseShortcuts!=null)
 { var td = document.getElementById("oosyntax");
   var widget ='<input type="checkbox" id="OOcheckbox" checked onclick="OOcheckboxChange(this);"> ' + AbbrevLabel;
   td.innerHTML = widget;
   td.title =AbbrevHint;
   td.alt =AbbrevHint;
   
 
 }
doc = sortObject(doc);
ShowFunctions(); 
Show(doc["YAPI"]?"YAPI":"Module",""); 


window.onresize = windowResized;  
-->  
</script>

</BODY>


</HEAD>

